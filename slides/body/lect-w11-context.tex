%!TEX encoding = UTF-8 Unicode
%!TEX root = ../lect-w11.tex

%%%

\Subsection{\TODO Kontextuella abstraktioner}

 

\begin{Slide}{\TODO Behovet av att abstrahera över kontext}\SlideFontSmall
\begin{itemize}\SlideFontTiny
\item \TODO
\end{itemize}
\end{Slide}




\Subsection{\TODO kolla om finns annan plats: Array}

\begin{Slide}{Repetition: Den primitiva typen Array i JVM}
\begin{itemize}
\item Primitiva arrayer (\code{Array} i Scala, \code{[]} i Java) har \Emph{fördelar}:%
\footnote{\href{http://stackoverflow.com/questions/2843928/benefits-of-arrays}{stackoverflow.com/questions/2843928/benefits-of-arrays}}
\begin{itemize}\SlideFontSmall
\item Det är den snabbaste indexerbara datastrukturen i JVM: att läsa och uppdatera ett element på en viss plats är mycket effektivt om man vet platsens index.
\item Fungerar lika bra med både primitiva värden och objektreferenser
\end{itemize}
\item ... men också \Alert{nackdelar}:
\begin{itemize}\SlideFontSmall
\item Man måste bestämma sig för antalet element som ska allokeras när man gör \code{new}.
\item Man kan ta i lite extra när man allokerar om man behöver plats för fler senare, men då måste man hålla reda på hur många platser man använder och veta var nästa lediga plats finns.
\item Det är krångligt att stoppa in \Eng{insert} och ta bort \Eng{delete} element.
\item Vill man ha fler platser måste man allokera en helt ny, större array och kopiera över alla befintliga element.
\end{itemize}

\end{itemize}
\end{Slide}



\begin{Slide}{Exempel: Polygon med primitiv array i Java}
\begin{Code}[numberstyle=,numbers=left,language=Java]
public class Polygon {
    private Point[] vertices; // array med hörnpunkter
    private int n;            // antalet hörnpunkter

    /** Skapar en polygon */
    public Polygon() {
        vertices = new Point[1];
        n = 0;
    }

    ...
\end{Code}
\end{Slide}

\begin{Slide}{Polygon med primitiv array i Java: stoppa in sist och vid behov skapa mer plats}\SlideFontSmall
Implementera:\\
\jcode{private void extend()                // dubbla storleken}\\
\jcode{public void addVertex(int x, int y)  // lägg till hörnpunkt}
\pause
\begin{Code}[numberstyle=,numbers=left,language=Java]
    private void extend(){
        Point[] oldVertices = vertices;
        vertices = new Point[2 * vertices.length]; // skapa dubbel plats
        for (int i = 0; i < oldVertices.length; i++) {  // kopiera
            vertices[i] = oldVertices[i];
        }
    }

    public void addVertex(int x, int y) {
        if (n == vertices.length) extend();
        vertices[n] = new Point(x, y);
        n++;
    }
\end{Code}
\end{Slide}


\begin{Slide}{Polygon med primitiv array i Java: stoppa in mitt i på angiven plats }\SlideFontSmall
Implementera:\\
\jcode{/** Sätt in hörnpunkt på plats pos */}\\
\jcode{public void insertVertex(int pos, int x, int y)}
\pause
\begin{Code}[numberstyle=,numbers=left,language=Java]
    public void insertVertex(int pos, int x, int y) {
        if (n == vertices.length) extend();   // utöka vid behov
        for (int i = n; i > pos; i--) {       // flytta element bakifrån
            vertices[i] = vertices[i - 1];
        }
        vertices[pos] = new Point(x, y);
        n++;
    }
\end{Code}
\end{Slide}


\Subsection{Scanner}

\begin{Slide}{Scanna filer och strängar med \texttt{java.util.Scanner}}\SlideFontTiny
\setlength{\leftmargini}{0pt}
\begin{itemize}
\item I Scala kan man läsa från fil så här (se quickref sid 3 längst ner):

\begin{Code}
val names = scala.io.Source.fromFile("src/names.txt").getLines.toVector
\end{Code}

\item Klassen \code{java.util.Scanner} kan också läsa från fil (se Java Snabbref sid 4):


\begin{Code}
def readFromFile(fileName: String): Vector[String] = {
  val file = new java.io.File(fileName)
  val scan = new java.util.Scanner(file)
  val buffer = scala.collection.mutable.ArrayBuffer.empty[String]
  while (scan.hasNext) {
    buffer += scan.next
  }
  scan.close
  buffer.toVector
}
\end{Code}

\item Med \code{new java.util.Scanner(System.in)} kan man även scanna tangentbordet.

\item Med \code{new java.util.Scanner("hej 42")} kan man även scanna en sträng.

\item Scanna \code{Int} och \code{Double} med metoderna \code{nextInt} och \code{nextDouble}. Se doc: \href{https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html}{\SlideFontTiny docs.oracle.com/javase/8/docs/api/java/util/Scanner.html}
\end{itemize}
\end{Slide}


\begin{Slide}{Exempel: Scanner}
\begin{REPL}
scala> val scan = new java.util.Scanner("hej 42 42.0   42 slut")

scala> scan.hasNext
res0: Boolean = true

scala> scan.hasNextInt
res1: Boolean = false

scala> scan.next
res2: String = hej

scala> scan.hasNextInt
res3: Boolean = true

scala> scan.nextInt
res4: Int = 42

scala> while (scan.hasNext) println(scan.next)
42.0
42
slut
\end{REPL}
\end{Slide}


\Subsection{\TODO flytta till fördjupning eller bara i java-appendix?: scala.jdk.CollectionConverters}

\begin{Slide}{Hjälp att använda Java-samlingar i Scala med \texttt{CollectionConverters}}\SlideFontSmall
Med hjälp av \code{import scala.jdk.CollectionConverters._} \\
får man smidig \Emph{interoperabilitet} med Java och dess standardbibliotek, \\
speciellt metoderna \Alert{\code{asJava}} och \Alert{\code{asScala}}:
\begin{REPL}
scala> import scala.jdk.CollectionConverters._

scala> Vector(1,2,3).asJava
res0: java.util.List[Int] = [1, 2, 3]

scala> val xs = new java.util.ArrayList[String]()
xs: java.util.ArrayList[String] = []

scala> xs.add("hej")
res1: Boolean = true

scala> xs.asScala
res2: scala.collection.mutable.Buffer[String] = Buffer(hej)
\end{REPL}

\noindent Läs mer här: %
\ifkompendium\\\fi%
\scriptsize%
\url{https://docs.scala-lang.org/overviews/collections-2.13/conversions-between-java-and-scala-collections.html}

\end{Slide}




\Subsection{ArrayList}

\begin{Slide}{Generiska samlingar i Java}
\begin{itemize}
\item Från och med version 5 av Java (2004) så introducerades \Emph{generics} vilket möjliggör skapandet av klasser som kan erbjuda generell behandling av olika typer av objekt.

\item Generiska klasser i Java känns igen med syntaxen \code{Klassnamn<Typ>}, till exempel  \code{ArrayList<Point>}

\item Fördjupning: \href{https://docs.oracle.com/javase/tutorial/extra/generics/intro.html}{docs.oracle.com/javase/tutorial/extra/generics/intro.html}, mer om detta i fördjupningskursen.

\end{itemize}
\end{Slide}

\begin{Slide}{Om ArrayList i Java}\SlideFontSmall
\code{java.util.ArrayList} liknar \code{scala.collection.mutable.ArrayBuffer} som båda har dessa fördelar:
\begin{itemize}
\item Lagrar sina element internt i snabbindexerade primitiva arrayer.
\item Fungerar för alla typer av objekt.
\item Utökar samlingens storlek av sig själv vid behov.
\end{itemize}
Det finns dock vissa nackdelar med \code{ArrayList} i Java\\(som inte gäller för \code{ArrayBuffer} i Scala):
\begin{itemize}
\item Fungerar \Alert{inte} rakt av med primitiva typer \code{int}, \code{double}, \code{char}, ... \\ (men det finns sätt komma runt detta, tack vare s.k. wrapper-klasser och autoboxing; mer om detta snart)

\item Namnet \code{ArrayList} är inte helt lyckat, eftersom ordet ''lista'' normalt används för länkade snarare än array-liknande strukturer.
\end{itemize}
\end{Slide}

\begin{Slide}{Polygon med ArrayList i Java}\SlideFontSmall
Klassen \code{Polygon}, nu med ett attribut av typen \code{ArrayList<Point>}:
\begin{Code}[numberstyle=,language=Java]
public class Polygon {
    private ArrayList<Point> vertices; // lista med hörnpunkter

    /** Skapar en polygon */
    public Polygon() {
        vertices = new ArrayList<Point>();
    }

    ...
\end{Code}
Det behövs inget attribut \code{n} eftersom vi inte själva behöver hålla reda på antalet allokerade platser: allokering, insättning, och utökning av antalet platser sköts helt automatiskt av \code{ArrayList}-klassen vid behov.
\end{Slide}

\begin{Slide}{Viktiga operationer på ArrayList (Urval)}
\begin{JavaSpec}{class ArrayList}
/** Skapar en ny lista */
ArrayList<E>();

/** Tar reda på elementet på plats pos */
E get(int pos);

/** Lägger in objektet obj sist */
void add(E obj);

/** Lägger in obj på plats pos; efterföljande flyttas */
void add(int pos, E obj);

/** Tar bort elementet på plats pos och returnerar det */
E remove(int pos);

/** Tar reda på antalet element i listan */
int size();
\end{JavaSpec}
Lär dig vad som finns om ArrayList i snabbreferensen för Java\\
\SlideFontSmall Överkurs för den nyfikne: kolla implementation av ArrayList här: \\ {\SlideFontTiny\url{http://www.docjar.com/html/api/java/util/ArrayList.java.html}}
\end{Slide}


\begin{Slide}{Övning ArrayList: new och add}
Skriv Java-kod som skapar en lista med element av typen \code{Point} och lägger in tre punkter i listan med koordinaterna:\\ (50, 50), (50,10) och (30, 40).
\pause
~\\~\\ Lösning: \ifkompendium\else\\~\\\fi
\begin{Code}[numberstyle=,language=Java]
ArrayList<Point> vertices = new ArrayList<Point>();
vertices.add(new Point(50, 50));
vertices.add(new Point(50, 10));
vertices.add(new Point(30, 40));
\end{Code}
\end{Slide}


\begin{Slide}{For-each-sats i Java:}\SlideFontSmall
\begin{itemize}
\item  Antag att vi vill gå igenom alla element i en lista.
\begin{Code}[numberstyle=,language=Java]
        ArrayList<String> words = new ArrayList<String>();
\end{Code}
\item Det finns två olika typer av \jcode{for}-satser i Java som kan göra detta:
\begin{itemize}\SlideFontSmall
\item  Vanlig \jcode{for}-sats:
\begin{Code}[numberstyle=,language=Java]
for (int i = 0; i < words.size(); i++) {
    System.out.println(i + ": " + words.get(i));
}
\end{Code}

\item  Så kallad \Emph{for-each-sats} med denna syntax:\\
\jcode+for (Elementtyp element: samling) { ... }+ \\
\vspace{1em}Exempel:
\begin{Code}[numberstyle=,language=Java]
for (String s: words) {
    System.out.println(s);
}
\end{Code}
Men vi får ingen indexvariabel då...
\end{itemize}
\end{itemize}
\end{Slide}


\begin{Slide}{Polygon med ArrayList: metoderna blir enklare}
\begin{Code}[numberstyle=,language=Java]
    public void addVertex(int x, int y) {
        vertices.add(new Point(x, y));
    }

    public void move(int dx, int dy) {
        for (Point p: vertices){
            p.move(dx, dy);
        }
    }

    public void insertVertex(int pos, int x, int y) {
        vertices.add(pos, new Point(x, y));
    }

    public void removeVertex(int pos) {
        vertices.remove(pos);
    }
\end{Code}

Se hela lösningen här:
\href{https://github.com/lunduniversity/introprog/tree/master/compendium/examples/scalajava/list/Polygon.java}{compendium/examples/scalajava/list/Polygon.java}
\end{Slide}

\begin{Slide}{Polygon med ArrayList: iterera över alla hörnpunkter i draw med indexering}
\begin{Code}[numberstyle=,language=Java]
    public void draw(SimpleWindow w) {
        if (vertices.size() == 0) {
            return;
        }
        Point start = vertices.get(0);
        w.moveTo(start.getX(), start.getY());
        for (int i = 1; i < vertices.size(); i++) {
            w.lineTo(vertices.get(i).getX(),
                     vertices.get(i).getY());
        }
        w.lineTo(start.getX(), start.getY());
    }
\end{Code}

Övning: Skriv om med for-each-sats.
\end{Slide}

\begin{Slide}{Polygon med ArrayList: iterera över alla hörnpunkter i draw med foreach-sats}
\begin{Code}[numberstyle=,language=Java]
    public void draw(SimpleWindow w) {
        if (vertices.size() == 0) {
            return;
        }
        Point start = vertices.get(0);
        w.moveTo(start.getX(), start.getY());
        for (Point p: vertices){
            w.lineTo(p.getX(), p.getY());
        }
        w.lineTo(start.getX(), start.getY());
    }
\end{Code}

Se hela lösningen här:
\href{https://github.com/lunduniversity/introprog/tree/master/compendium/examples/scalajava/list/Polygon.java}{compendium/examples/scalajava/list/Polygon.java}
\end{Slide}




\begin{Slide}{Övning ArrayList: implementera metoden hasVertex}
Skriv kod som implementerar denna metod i klassen \code{Polygon}:
\begin{Code}[numberstyle=,language=Java]
/** Undersöker om polygonen har någon hörnpunkt med koordinaterna x, y. */
public boolean hasVertex(int x, int y) {
    ???
}
\end{Code}
\end{Slide}

\begin{Slide}{Lösning ArrayList: implementera metoden hasVertex}
\begin{Code}[numberstyle=,language=Java]
    public boolean hasVertex(int x, int y) {
        for (Point p: vertices) {
            if (p.getX() == x && p.getY() == y) {
                return true;
            }
        }
        return false;
    }
\end{Code}
\end{Slide}


\begin{Slide}{For-each-sats med array}
For-each-sats fungerar även med primitiv array:
\begin{Code}[numberstyle=,language=Java]
        String[] stringArray = {"hej", "på", "dej"};
        for (String s: stringArray) {
            System.out.println(s);
        }
\end{Code}
\end{Slide}





\Subsection{Autoboxing}



\begin{Slide}{Generiska klasser (t.ex. ArrayList) med primitiva typer}
Detta går tyvärr \Alert{INTE} i Java: \\
  \sout{\texttt{ArrayList<int> list = new ArrayList<int>();}}
  
\pause
\begin{itemize}\SlideFontSmall
\item Hur gör man om man vill ha heltalselement (eller andra primitiva värden) i en generisk samling?

\item Javas lösning på problemet består av två delar:
\begin{itemize}\SlideFontSmall
\item Klasser som packar in primitiva typer, \Eng{wrapper classes}
\item Speciella regler för implicita konverteringar, s.k. ''auto-boxing'' \Eng{Boxing / Unboxing conversions}
\end{itemize}
\end{itemize}
\SlideFontTiny\vspace{1em}
Ofta fungerar det fint, men det finns fallgropar.\\
(Om du är nyfiken på alla intrikata detaljer, se
\href{https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html}{Java tutorial} och   \href{https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7}{Javaspecifikationen}.)
\end{Slide}

\begin{Slide}{Wrapper-klassen \code{Integer}}\SlideFontSmall
En skiss av klassen \code{Integer} \\ (ligger i paketet \href{http://docs.oracle.com/javase/8/docs/api/java/lang/package-summary.html}{\code{java.lang}} och importeras därmed implicit):

\ifkompendium\vspace{1em}\fi%
\begin{minipage}{0.65\textwidth}
\begin{Code}[numberstyle=,language=Java,backgroundcolor=\color{white},
  frame=none]
public class Integer {
    private int value;

    public static final MIN_VALUE = -2147483648;
    public static final MAX_VALUE = 2147483647;

    public Integer(int value) {
        this.value = value;
    }

    public int intValue() {
        return value;
    }
    ...
}
\end{Code}
\end{minipage}
\begin{minipage}{0.33\textwidth}
\centering\includegraphics[width=0.95\textwidth]{../img/box}
\end{minipage}
Javadoc för klasen \code{Integer} finns här: \\
\SlideFontTiny\url{http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html}
\end{Slide}





\begin{Slide}{Wrapper-klasser i \code{java.lang}}\SlideFontSmall
\begin{tabular}{l | l}
\Emph{Primitiv typ}                  & \Emph{Inpackad typ}                 \\ \hline

 boolean & Boolean\\
 byte & Byte\\
 short& Short\\
 char & Character\\
 int & Integer\\
 long & Long\\
 float & Float\\
 double & Double\\
\end{tabular}
\end{Slide}


\begin{Slide}{Övning: primitiva versus inpackade typer}
Med papper och penna:
\begin{itemize}
\item Deklarera en variabel med namnet \code{gurka} av den primitiva heltalstypen och initiera den till värdet 42.
\item Deklarera en referensvariabel med namnet  \code{tomat} av den inpackade (''wrappade'') heltalstypen och initiera den till värdet 43.
\item Rita hur det ser ut i minnet.
\end{itemize}
\end{Slide}

\begin{Slide}{Exempel: Lista med heltal utan autoboxning}
\lstinputlisting[language=Java, basicstyle=\small\ttfamily\SlideFontSize{6.7}{8.5},backgroundcolor=\color{white},frame=none
]{../compendium/examples/scalajava/generics/TestIntegerList.java}
\SlideFontTiny Koden finns här: \href{https://github.com/lunduniversity/introprog/tree/master/compendium/examples/scalajava/generics/TestIntegerList.java}{compendium/examples/scalajava/TestIntegerList.java}
\end{Slide}




\begin{Slide}{Specialregler för wrapper-klasser}\SlideFontSmall

\begin{itemize}
\item Om ett \code{int}-värde förekommer där det behövs ett \code{Integer}-objekt, så lägger kompilatorn \Alert{automatiskt} ut kod som skapar ett \code{Integer}-objekt som packar in värdet.
\item Om ett \code{Integer}-objekt förekommer där det behövs ett \code{int}-värde, lägger kompilatorn \Alert{automatiskt} ut kod som anropar metoden \code{intValue()}.
\end{itemize}
Samma gäller mellan alla primitiva typer och dess wrapper-klasser:

\begin{tabular}{r c l}
 {\lstinline!boolean!} &$\Leftrightarrow$& {\lstinline!Boolean!} \\
 {\lstinline!byte!} &$\Leftrightarrow$& {\lstinline!Byte!}\\
 {\lstinline!short!}&$\Leftrightarrow$& {\lstinline!Short!}\\
 {\lstinline!char!} &$\Leftrightarrow$& {\lstinline!Character!}\\
 {\lstinline!int!} &$\Leftrightarrow$& {\lstinline!Integer!}\\
 {\lstinline!long!} &$\Leftrightarrow$& {\lstinline!Long!}\\
 {\lstinline!float!} &$\Leftrightarrow$& {\lstinline!Float!}\\
 {\lstinline!double!} &$\Leftrightarrow$&{\lstinline!Double!}\\
\end{tabular}

\end{Slide}






\begin{Slide}{Exempel: Lista med heltal och autoboxing}
\lstinputlisting[language=Java, basicstyle=\small\ttfamily\SlideFontSize{6}{8}
,backgroundcolor=\color{white},
  frame=none]{../compendium/examples/scalajava/generics/TestIntegerListAutoboxing.java}
\SlideFontTiny Koden finns här: \href{https://github.com/lunduniversity/introprog/tree/master/compendium/examples/scalajava/generics/TestIntegerList.java}{scalajava/generics/TestIntegerListAutoboxing.java}
\end{Slide}

\begin{Slide}{Fallgropar vid autoboxing}
\begin{itemize}
\item Jämförelser med \code{==} och \code{!=} \\
\href{https://github.com/lunduniversity/introprog/blob/master/compendium/examples/scalajava/generics/TestPitfall1.java}
{\SlideFontSmall  compendium/examples/scalajava/generics/TestPitfall1.java}
\item[]
\item Kompilatorn hittar inte förväxlad parameterordning, t.ex. \code{add(pos, item)} i fel ordning: \sout{\code{add(item, pos)}}\\
\href{https://github.com/lunduniversity/introprog/blob/master/compendium/examples/scalajava/generics/TestPitfall2.java}
{\SlideFontSmall compendium/examples/scalajava/generics/TestPitfall2.java}
\end{itemize}
\end{Slide}

\Subsection{Equals}
\begin{Slide}{Fallgrop med samlingar: metoden contains kräver implementation av equals}\SlideFontSmall
Antag att vi vill implementera \code{hasVertex()} i klassen \code{Polygon} genom att använda metoden \code{contains} på en lista. Hur gör vi då?
\pause
\begin{Code}[numberstyle=,language=Java]
public boolean hasVertex(int x, int y) {
    return vertices.contains(new Point(x, y)); // FUNKAR INTE om ...
    // ... inte Point har en equals som kollar innehållslikhet
}
\end{Code}
Vi behöver implementera metoden \code{equals(Object obj)} i klassen \code{Point} som kollar innehållslikhet och ersätter den \code{equals} som finns i \code{Object} som kollar referenslikhet, eftersom metoden \code{contains} i klassen \code{ArrayList} anropar \code{equals} när den letar igenom listan efter lika objekt. \\
Se exempel här: \href{https://github.com/lunduniversity/introprog/tree/master/compendium/examples/scalajava/generics/TestPitfall3.java}{compendium/examples/scalajava/generics/TestPitfall3.java} \\


\vspace{1em}{\SlideFontTiny\noindent Det krävs ofta även att man även ersätter  \href{http://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java}{\code{hashCode}}, mer om det i fortsättningskursen.}
\end{Slide}


\begin{Slide}{Fördjupning: Fullständigt recept för \texttt{equals}}
För den nyfikne inför fortsättningskursen efter jul: 

\vspace{1em}\noindent
Läs om fallgropar för att implementera equals i \Emph{Java} här: \\
\href{http://www.artima.com/lejava/articles/equality.html}{www.artima.com/lejava/articles/equality.html}


\vspace{1em}\noindent
Läs receptet för att implementera equals i \Emph{Scala} här: \\
\href{http://www.artima.com/pins1ed/object-equality.html#28.4}{www.artima.com/pins1ed/object-equality.html\#28.4}
\end{Slide}



\Subsection{Fördjupning diverse}


\begin{Slide}{Fördjupning: Villkorsuttryck i Java}\SlideFontSmall
Det går att använda villkorsuttryck i Java, men med syntax från språket C:
\begin{multicols}{2}
  \noindent\Emph{Scala}
\begin{CodeSmall}[basicstyle=\ttfamily\SlideFontSize{6}{8},backgroundcolor=\color{white},
  frame=none]
var r = math.random()
var answer = if (r > 0.5) 42 else 0
\end{CodeSmall}

\columnbreak

\noindent\Emph{Java}
\begin{CodeSmall}[language=Java,basicstyle=\ttfamily\SlideFontSize{6}{8},backgroundcolor=\color{white},
  frame=none]
double r = Math.random();
int answer = (r > 0.5) ? 42 : 0;
\end{CodeSmall}
\end{multicols}

\end{Slide}




\begin{Slide}{Fördjupning: Typtest och typkonvertering}

\begin{multicols}{2}
  \noindent\Emph{Scala}
\begin{CodeSmall}[basicstyle=\small\ttfamily\SlideFontSize{6}{8},backgroundcolor=\color{white},
  frame=none]
var x = "hej"

var isString = x.isInstanceOf[String]

var y = 42

var z = y.asInstanceOf[Double]

\end{CodeSmall}

\columnbreak

\noindent\Emph{Java}
\begin{CodeSmall}[language=Java,basicstyle=\small\ttfamily\SlideFontSize{6}{8},backgroundcolor=\color{white},
  frame=none]
String x = "hej";

boolean isString = x instanceof String;

int y = 42;

double z = (double) y;
\end{CodeSmall}
\end{multicols}


\end{Slide}


\begin{Slide}{Fördjupning: Fånga undantag i Scala och Java}
Typisk skillnad mellan Scala och Java:\\konstruktioner som är \Emph{uttryck} i Scala är ofta \Alert{satser} i Java.
\begin{multicols}{2}
  \noindent\Emph{Scala}
\begin{CodeSmall}[basicstyle=\ttfamily\SlideFontSize{6}{8},backgroundcolor=\color{white},
  frame=none]
val a = try { 2 / 0 } catch {
  case e: ArithmeticException => 0
}

val b = try { 4 / 2 } catch {
  case e: ArithmeticException => 0
}
\end{CodeSmall}

\columnbreak

\noindent\Emph{Java}
\begin{CodeSmall}[language=Java,basicstyle=\ttfamily\SlideFontSize{6}{8},backgroundcolor=\color{white},
  frame=none]
int a;
try {
    a = 2 / 0;
} catch (ArithmeticException e) {
    a = 0;
}

int b;
try {
    b = 4 / 2;
} catch (ArithmeticException e) {
    b = 0;
}

\end{CodeSmall}
\end{multicols}

Mer om undantag \Eng{exceptions} i fortsättningskursen.
\end{Slide}




\begin{Slide}{Fördjupning: Gränssnittet \texttt{List} i Java}\SlideFontSmall
\begin{itemize}
\item I Java finns inte \code{trait} och inmixning.

\item I stället finns \jcode{interface} som liknar \code{trait} men är mer begränsad vad gäller vilka medlemmar som får finnas.

\item Man kan bara göra \code{extends} på exakt en annan klass, men man kan i Java göra \jcode{implements} på flera \jcode{interface}.\\(Jämför Scalas \code{with} på \code{trait}s)

\item Exempel:
\begin{Code}[language=Java,backgroundcolor=\color{white},
  frame=none]
public class ArrayList<E> extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
\end{Code}

\item Att implementera ett gränssnitt innebär att uppfylla ett kontrakt som utlovar att vissa speciella metoder finns tillgängliga.

\item Gränssninttet \code{List} uppfylls av en av dess implementationer \code{ArrayList} \\

på liknande sätt i Scala där gränssnittet \code{Seq} uppfylls av \code{Vector} etc.

\item[] \jcode{List<String> xs = new ArrayList<String>();}

\item I Hangman-övningen:

\item[]\jcode{Set<Character> found = new HashSet<Character>();}

\item Mer om gränssnitt i fördjupningskursen.

\end{itemize}
\end{Slide}

\begin{Slide}{Fördjupning: Skapa generisk Array}\SlideFontTiny
\begin{itemize}
\item I Java kan man \Alert{inte} skapa en primitiv array av godtycklig typ enligt generisk typparameter: \sout{\code{T[] xs = new T[42]}}

\item Man måste istället skapa en array av den mest generella referenstypen: \\
\code{Object[] xs = new Object[42]} \\
och sedan typtesta och typkonvertera under körtid; se t.ex. implementationen av \code{ArrayList} på rad 119: \href{http://developer.classpath.org/doc/java/util/ArrayList-source.html}{http://developer.classpath.org/doc/java/util/ArrayList-source.html}

\item[]
\pause
\item Detta går faktiskt att göra i Scala med hjälp av \code{reflect.ClassTag} \pause så här: \\
\begin{REPLnonum}[basicstyle=\ttfamily\SlideFontSize{6}{8}\color{white}]
scala> def fyll[T](n: Int, x: T): Array[T] = Array.fill(n)(x)
<console>:11: error: No ClassTag available for T

scala> def fyll[T: reflect.ClassTag](n: Int, x: T): Array[T] = Array.fill(n)(x)
fyll: [T](x: T)(implicit evidence: scala.reflect.ClassTag[T])Array[T]

scala> fyll(42, "hej")
res2: Array[String] = Array(hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej, hej)

scala> fyll(42, 1)
res3: Array[Int] = Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)

\end{REPLnonum}


\end{itemize}


\end{Slide}
