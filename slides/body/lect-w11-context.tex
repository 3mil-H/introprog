%!TEX encoding = UTF-8 Unicode
%!TEX root = ../lect-w11.tex

%%%


\Subsection{Att sätta gränser för typer}

\begin{Slide}{Olika sätt att begränsa typer}
Det finns i Scala flera olika sätt att att begränsa vilka typer du vill tillåta. En översikt av några möjligheter:
\begin{itemize}
  \item Ge \Emph{övre} gräns för typparametrar \Eng{lower bound}
  \item Ge \Emph{undre} gräns för typparametrar \Eng{upper bound}
  \item Ge en \Emph{kontextgräns} för typparametrar i relation till givna typer \Eng{context bound}
  \item Begränsa möjlig inmixning vid deklaration av en trait med en \Emph{egentyp} \Eng{self type} 
\end{itemize}
\end{Slide}

\begin{Slide}{Övre och undre typgränser}
Med typoperatorerna \code{<:} och \code{>:} går det att begränsa vilka typer som kan bindas till en typparameter i generiska strukturer. Antag att \code{T} är en typparameter och \code{U} och \code{L} är konkreta typer. 
\begin{itemize}
  \item med \code{T <: U} blir \code{U} en övre gräns \Eng{upper bound} för \code{T}  
  \item med \code{T >: L} blir \code{L} en undre gräns \Eng{lower bound} för \code{T}  
  \item Minnesregel för typgränser: kolon på slutet.
\end{itemize} 
\pause
Exempel: 
\begin{Code}
  trait Grönsak { def vikt: Int }

  def f[T <: Grönsak](x: T): Int = x.vikt
\end{Code}

Notera att kompilatorn använder den övre typgränsen för att konstatera att metoden \code{vikt} är tillgänglig via den generiska parametern \code{x}.

\end{Slide}

\begin{Slide}{Exempel på övre och undre typgränser}

\begin{Code}
class Djur
class Katt extends Djur 
class Hund extends Djur
class Robothund extends Hund

def testUpperBound[T <: Hund](x: T) = println(x)
def testLowerBound[T >: Hund](x: T) = println(x)
\end{Code}

\begin{REPL}
scala> testUpperBound[Katt](Katt())
-- Error:
1 |testUpperBound[Katt](Katt())
  |          ^
  |          Type argument Katt does not conform to upper bound Hund

scala> testLowerBound[Robothund](Robothund())
-- Error:
1 |testLowerBound[Robothund](Robothund())
  |          ^
  |          Type argument Robothund does not conform to lower bound Hund
\end{REPL}

\end{Slide}

\begin{Slide}{Typbegränsning med egentyp \Eng{self type}}\SlideFontSmall
\begin{itemize}\SlideFontTiny
  \item Det går att få ett explicit, valfritt namn, t.ex. \code{self},  på ''min egen typ'' genom att skriva~\code{ self => }~i kroppen på en trait eller klass. 
  \item Detta kallas \Emph{egentyp} \Eng{self type}. 
  \item Användbart vid inmixning: du kan begränsa egentypen med en typannotering.
\begin{Code}
trait Grönsak { def vikt: Int }
trait KanSkalas:
  self: Grönsak =>
  def viktEfterSkalning = 0.99 * vikt 
\end{Code}
\begin{REPLsmall}
scala> val g = new Grönsak with KanSkalas { val vikt = 100 }
val g: Grönsak & KanSkalas = anon1@70a91d72
                                                                                    
scala> g.viktEfterSkalning
val res0: Double = 99.0
\end{REPLsmall}
\item Även om \code{KanSkalas} \Alert{inte} gör \code{extends} så är \Emph{ändå} \code{vikt} tillgänglig i dess kropp, eftersom vi kräver att den egna typen är en \code{Grönsak}.
\item Kan användas för att göra s.k. \Emph{beroendeinjektion} \Eng{dependency injection}.\\\url{https://en.wikipedia.org/wiki/Dependency_injection}
\end{itemize}

\end{Slide}



\Subsection{Flexibla generiska typer: varians}

\ifkompendium\else
\begin{SlideSimple}{Vad är varians?}
\hspace*{-2cm}\includegraphics[width=1.4\textwidth]{../img/pet-carrier.jpg}  
\end{SlideSimple}
\fi 

\begin{Slide}{Vad är varians?}

\begin{center}
Är en kattbur också en djurbur?

\includegraphics[width=0.75\textwidth]{../img/pet-carrier.jpg}  

Om vi tillåter \Emph{varians} kan vi göra generiska typer mer flexibla.

\end{center}

\end{Slide}

\begin{Slide}{Varians}
  \TODO Varians \\ \url{https://docs.scala-lang.org/scala3/book/types-variance.html}
\end{Slide}

\begin{Slide}{Typjoker \Eng{wildcard type}}\SlideFontSmall
Generiska typer är normalt \Emph{invarianta} och kan därmed inte utan speciella åtgärder variera mellan mer eller mindre specifika typer. %(mer om varians senare).
\begin{REPLsmall}
scala> case class Box[A](a: A)

scala> var xs = Vector.empty[Box[Any]]

scala> def add[A](b: Box[A]): Unit = xs = xs :+ b
-- Error:
1 |def add[A](b: Box[A]): Unit = xs = xs :+ b
  |                                         ^
  |                                         Found:    (b : Box[A])
  |                                         Required: Box[Any]
\end{REPLsmall}  
Till vår räddning: En \Emph{typjoker} \Eng{wildcard type} anges med ett frågetecken och betecknar en helt okänd typ, vars varians ej kontrolleras av kompilatorn.
\begin{REPLsmall}
scala> var xs = Vector.empty[Box[?]]

scala> def add[A](b: Box[A]): Unit = xs = xs :+ b

scala> add(Box(42)); add(Box("hej")); xs
val res2: Vector[Box[?]] = Vector(Box(42), Box(hej))
\end{REPLsmall}
Använd bara typpjoker om det verkligen behövs, eftersom ingen typkontroll alls sker.
\end{Slide}



\Subsection{Kontextuella abstraktioner}

 
\begin{Slide}{Kontextuella abstraktioner: \texttt{given}, \texttt{using}}\SlideFontSmall
\begin{itemize}\SlideFontTiny
\item \TODO \code{given} \code{using}
\end{itemize}
\end{Slide}

\begin{Slide}{Kontextgränser}
\TODO \code{T: Ordering}
\end{Slide}





\begin{Slide}{Sortera samlingar: saknad implicit ordning}
\TODO migrera till Scala 3, implicit -> given
\begin{REPL}
scala> case class Gurka(namn: String, vikt: Int)
defined class Gurka

scala> val xs = Vector(Gurka("a", 100), Gurka("b", 50), Gurka("c", 100))

scala> xs.sorted
<console>:15: error: No implicit Ordering defined for Gurka.
       xs.sorted
          ^
\end{REPL}
\pause
Detta kan fixas genom att tillhandahålla en \Emph{implicit} ordning för \code{Gurka}:
\begin{Code}
implicit object minGurkOrdning extends Ordering[Gurka] {
  def compare(x: Gurka, y: Gurka): Int =
    if (x == y) 0
    else if (x.vikt < y.vikt) -1
    else 1
}
\end{Code}
\end{Slide}


\begin{Slide}{Sortera samlingar: given implicit ordning}
\TODO migrera till Scala 3

\begin{REPL}
scala> case class Gurka(namn: String, vikt: Int)
defined class Gurka

scala> val xs = Vector(Gurka("a", 100), Gurka("b", 50), Gurka("c", 100))

scala> implicit object minGurkOrdning extends Ordering[Gurka] {
         def compare(x: Gurka, y: Gurka): Int =
           if (x == y) 0
           else if (x.vikt < y.vikt) -1
           else 1
       }

scala> xs.sorted
res0: scala.collection.immutable.Vector[Gurka] =
        Vector(Gurka(b,50), Gurka(a,100), Gurka(c,100))
\end{REPL}
{\SlideFontTiny Se exempel på olika bekvämare sätt att definiera en ordning för dina egna typer: \\
\url{https://stackoverflow.com/questions/19345030/}}
\end{Slide}


\Subsection{Applikationsprogrammeringsgränssnitt (api)}
\begin{Slide}{Vad är ett bra api?}
\TODO Beskriv kvalitetsegenskaper hos ett bra api\\
\href{https://stackoverflow.com/questions/469161/how-do-you-define-a-good-or-bad-api}{https://stackoverflow.com/questions/469161/how-do-you-define-a-good-or-bad-api}  
\end{Slide}




