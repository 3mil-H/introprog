%!TEX encoding = UTF-8 Unicode
%!TEX root = ../lect-week14.tex

%%%

\Subsection{Tentatips}
\begin{Slide}{Före tentan:}\SlideFontSmall
\begin{enumerate}
\item Repetera övningar och labbar i kompendiet.
\item Läs igenom föreläsningsanteckningar.
\item Studera \Emph{snabbref} \Alert{mycket noga} så att du vet vad som är givet och var det står, så att du kan hitta det du behöver snabbt.
\item Skapa och \Emph{memorera} en personlig \Emph{checklista} med programmeringsfel du brukar göra, som även inkluderar småfel, så som glömda parenteser och semikolon, och annat som en kompilator/IDE normalt hittar.
\item Tänk igenom hur du ska disponera dina 5 timmar på tentan.
\item Gör minst en extenta som om det vore \Alert{skarpt läge}:
\begin{enumerate}\SlideFontTiny
\item Avsätt 5 ostörda timmar (stäng av telefon, dator etc).
\item Inga hjälpmedel. Bara snabbref.
\item Förbered dryck och tilltugg.
\end{enumerate}
\end{enumerate}
\end{Slide}

\begin{Slide}{På tentan:} \SlideFontTiny
\begin{enumerate}
\item Läs igenom \Alert{hela} tentan först. \\ \Emph{Varför?} Förstå helheten. Delarna hänger ihop.
\item Notera och begrunda specifika begrepp och definitioner. \\ \Emph{Varför?} Begreppen är avgörande för förståelsen av uppgiften.
\item Notera förenklingar, antaganden och specialfall. \\ \Emph{Varför?} Uppgiften blir mkt enklare om du inte behöver hantera dessa.
\item \Alert{Fråga} tentamensansvarig om du inte förstår uppgiften -- speciellt om det finns misstänkta felaktigheter eller förmodat oavsiktliga oklarheter. \\ \Emph{Varför?} Det är inte lätt att konstruera en ''perfekt'' tenta. \\ Du får fråga vad du vill, men det är inte säkert du får svar :)
\item Läs specifikationskommentarerna och metodsignaturerna i alla givna klass-specifikationer \Alert{mycket noga}. \\ \Emph{Varför?} Det är ett vanligt misstag att förbise de ledtrådar som ges där.
\item Återskapa din memorerade personliga checklista för vanliga fel som du brukar göra och avsätt tid till att gå igenom den på tentan. Varje fix plockar poäng!
\item Lämna in ett försök även om du vet att lösningen inte är fullständig. Det gäller att ''plocka poäng'' på så mycket som möjligt. En dålig lösning kan ändå ge poäng.

\item Om du har svårigheter kan det bli kamp mot klockan. Försök hålla huvudet kallt och prioritera utifrån var du kan plocka flest poäng. Ge inte upp! Ta en kort äta-dricka-paus för att få mer energi!

\end{enumerate}
\end{Slide}

\ifkompendium\else

\begin{Slide}{Planeringstips}\SlideFontTiny
Exempel på saker som du kan lägga in tid för i din julpluggkalender:
\begin{enumerate}
\item Välja ut övningar att repetera
\item Repetera övning X, Y, Z, ... Både läsa och skriva kod. Fundera på typ och värde.
\item Välja ut labbar att repetera
\item Repetera labb X, Y, Z, ... Lär dig ''trick'' och ''mönster''.
\item Träna på att skriva program med papper och penna
\item Göra checklista med vanliga fel och misstag som du brukar göra
\item Det finns inte så många Scala-extentor, men du kan använda Java-extentor som om de vore i skarpt läge; du kan med fördel lösa vissa delar i Scala och vissa delar i Java beroende på vad du behöver träna på

\item Läsa igenom de extentor i Scala och Java som du inte väljer att göra som om det vore skarpt läge och studera uppgifterna och lösningarna och notera generella mönster och typiska trick
\end{enumerate}
\end{Slide}

\begin{Slide}{Tentans struktur}
\begin{itemize}
\item Del A 20\%:\\\Emph{Läsa uttryck} där du ska \Alert{ange typ och värde}
\begin{itemize}\SlideFontTiny
\item Testar förståelse av variabler, uttryck, samlingar, algoritmer, arv, etc.
\item Det är bra/nödvändigt att skriva ner delsteg och variablers värden, då det kan vara svårt att tänka ut svaren direkt i huvudet.
\item Ev. ''rättningströskel'': \textit{Om du på del A erhåller färre poäng än vad som krävs för att nå upp till en bestämd ''rättningströskel'', kan din tentamen komma att underkännas utan att del B bedöms.}
\end{itemize}


\item Del B 80\%:\\\Emph{Skriva kod} som uppfyller \Alert{krav och designspecifikation}
\begin{itemize}\SlideFontTiny
\item Testar att du själv kan skapa kod med delar som samverkar
\item Testar förmåga att gå från indata-utdata till algoritm \\
 givet: ledtrådar, design, ev. skiss på lösning, ev. pseudokod etc.
\item En uppgift ska besvaras i Java, men den testar mer än bara Java-kompetens. Det är bättre att svara i Scala-liknande Java om du är osäker på Java än att inte lämna in alls.
\end{itemize}
\item Blanka inlämningar ger 0 poäng; det är alltid bättre att försöka än att lämna in blankt.
\end{itemize}
\end{Slide}


\begin{Slide}{Vad kommer på tentan? (1 av 3)}\SlideFontTiny
\hspace{-1em}\begin{minipage}{1.0\textwidth}
Allmänt:
\begin{itemize}\SlideFontTiny
\item Begrepp som är ''fördjupning'' krävs ej på tentan (men ökar förståelse)
\item Ok om du väljer en enklare lösning med basala begrepp som fungerar bra, \\i stället för en kortare/elegantare/mer avancerad lösning
\item Dessa moduler ingår ej på tentan: ''Trådar, webb'', ''Design, api''
\end{itemize}

\vspace{1em}\begin{tabular}{l | l | l}
\textbf{Modul} & \textit{Ingår t.ex.}& \textit{Avgränsning} (ej krav; ok anv. om lämpl.)\\\hline
Introduktion & uttryck, aritmetik, slumptal, & kan ha nytta av deMorgan men ej krav\\
             & strängar, typer, Unit     \\
             & skillnad mellan heltal \& flyttal & Float, Byte, Short\\
             & variabler, for, while, if & hex-literaler, backticks\\
\hline
Kodstrukturer & iterering, SWAP, SUM, MIN/MAX & import, paketnamn\\
              & loopar, Range, sats vs uttryck & ok att välja vilken loop du tycker passar\\
              & namn, synlighet, skuggning & scaladoc, javadoc, jar \\
\hline
Funktioner,   & definiera, anropa, parameter& skapa egen kontrollstruktur\\
objekt        & returtyp, namnarop, defaultarg & stegad funktion, rekursion\\
              & punktnotation, objekt vs static & lazy val\\
              & map/foreach med egen funktion & \\
              & anonyma funktioner (lambda)  & \\

\end{tabular}
\end{minipage}
\end{Slide}


\begin{Slide}{Vad kommer på tentan? (2 av 3)}\SlideFontTiny
\hspace{-2em}\begin{minipage}{1.0\textwidth}
\begin{tabular}{l | l | l}
\textbf{Modul} & \textit{Ingår t.ex.}& \textit{Avgränsning} (ej krav; ok anv. om lämpl.)\\\hline
Datastrukt. & attribut, medlem, metod, klass & isInstanceOf (anv. match istället) \\
            & tupler, Vector, Set, Map & List (oftast Vector istället)\\
            & Source.fromFile          & java.nio.file \\
\hline
Sekvensalg. &  skapa ny samling från befintlig &  \\
            &  registrering, Scanner, ArrayBuffer & StringBuilder\\
            &  uppdatera Array, ArrayBuffer, Vector & \\
            &  slumptalsfrö, scala.util.Random  &  \\
\hline

Klasser     &  new, this, synlighet  & null \\
            &  inkapsling, accessregler, private  & private[this] \\
            &  klassparameter, fabriksmetod  & \\
            &  class vs case class    & \\
            &  referenslikhet vs innehållslikhet    & \\
            &  föränderlig vs oföränderlig klass & \\
\hline
Arv         &  bastyp, subtyp, trait, extends  & \\
            &  överskuggning,                  & inmixning, \\
            &  Any, AnyVal, AnyRef, Object     & Null, Nothing\\
            &  accessregler vid arv, protected & final\\
            &  abstract class, case object     & \\

\end{tabular}
\end{minipage}
\end{Slide}


\begin{Slide}{Vad kommer på tentan? (3 av 3)}\SlideFontTiny
\hspace{-2em}\begin{minipage}{1.0\textwidth}
\begin{tabular}{l | l | l}
\textbf{Modul} & \textit{Ingår t.ex.}& \textit{Avgränsning} (ej krav; ok anv. om lämpl.)\\\hline

Mönster     & match, Option, Try & try catch, unapply\\
            & flatten, sealed            & flatMap, partiella funktioner\\
            & enkel equals utan arv     & hashcode, fullständig equals   \\
            & wildcard-mönster  & variabelbindn. i mönster, sekvensmönster\\
\hline

Matriser,     & indexering i nästlade strukturer & \\
typparametrar & nästlad for-sats  & \\
              & matriser i Java med array  & \\
              & använda generiska strukturer & skapa generiska strukturer\\
\hline

Sök, sortera & linjärsökning, binärsökning & algoritmisk komplexitet\\
            & compareTo, strängjämförelse & Ordering, Ordered\\
            & insättningssortering & räcker kunna en valfri sortering \\
\hline


Scala/Java & översätta enkel Java/Scala & try catch i Java \\
           & implemenetera Java-klass     &  arv i Java med super vid konstr.\\
           & grundläggande syntaxskillnader & \\
           & ArrayList vs ArrayBuffer & java.util.\{List, Set\}\\
           & Autoboxing vid ArrayList<Integer> & \\
\multicolumn{3}{c}{OBS! Java-övningar finns även här och där i andra moduler}\\
\hline

\end{tabular}
\end{minipage}
\end{Slide}



\begin{Slide}{Några tumregler/tips vid val av abstraktion}\SlideFontSmall
Ofta ger tentan en specifik design, men du kan ha stor nytta av egna abstraktioner, speciellt \Emph{lokala funktioner} för att göra enklare dellösningar!

\pause\vspace{1em}Om du skulle behöva samla både attribut och metoder utöver givna specifikationer:
Singelobjekt, case-klass, klass, trait eller abstrakt klass?
\begin{itemize}\SlideFontTiny
\item Använd \code{object} om du behöver samla metoder (och variabler) i en modul som bara finns i en upplaga. Du får lokal namnrymd och punktnotation på köpet.
\item Använd en \code{case class} om du har \Emph{oföränderlig data}. Du får då även innehållslikhet, möjlighet till mönstermatchning, etc. på köpet!
\item Behöver du \Alert{föränderligt tillstånd} använd en vanlig \code{class}.\\ Det normala är att tillståndet (alla attribut) är \code{private} eller \code{protected} och att all uppdatering och avläsning av tillståndet sker indirekt genom metoder (getters/setters/...).
\item Behöver du en abstrakt bastyp utan konstruktorparametrar använd en \code{trait}. \\(Du får inmixningsmöjlighet med \code{with} på köpet. Inmixning kommer ej på tenta.)
\item Behöver du en abstrakt bastyp med konstruktorparametrar använd en \code{abstract class}. (Går dock ej att använda vid inmixning med \code{with}.)
\end{itemize}
\end{Slide}


\begin{Slide}{Tips om hur man läser en specifikation}\SlideFontSmall
När du läser en specifikation av en klass, en trait, eller ett singelobjekt:
\begin{itemize}
\item Tänk igenom vilket ansvar olika delar av koden har
\item Vad håller klassen reda på? \\$\rightarrow$ Ledtrådar till attribut
\item Vad ska klassen göra/räkna ut? \\$\rightarrow$ Ledtrådar till metoder och deras algoritm
\item Vilka andra klasser har nytta av denna metod? \\$\rightarrow$ Ledtrådar till hur klasserna samverkar för att lösa uppgiften
\end{itemize}
Rita gärna en bild med ett specifikt exempel på vilken data som olika instanser håller reda på och fundera på hur data skapas/beräknas/förändras
\end{Slide}


\begin{Slide}{Tips om val av samling}\SlideFontSmall

Generellt: Det är ofta enklare med oföränderliga samlingar med oföränderliga element och skapa nya samlingar vid förändring. Men ibland blir det enklare om man har föränderliga samlingar.

\begin{itemize}
\item Behöver du hantera värden \code{x} av t.ex. typen String med \Emph{heltalsindex}?
\begin{itemize}\SlideFontTiny
\item Om du klarar dig utan förändring av innehållet:\\ \code{ val xs: Vector[String]}
\item Om du behöver ändra innehåll men \Alert{inte} antal element: \\ \code{ val xs: Array[String]}
\item Om du behöver ändra innehåll \Alert{och} antal element:
\\ \code{ var xs: Vector[String] } (se metoden \code{patch}) eller \\ \code{ val xs: ArrayBuffer[String]} (har metoden \code{insert})
\end{itemize}

\item Behöver du hantera värden \code{x} som ska vara unika?
\begin{itemize}\SlideFontTiny
\item Oföränderlig: \code{  val xs: Set[String] }
\item Förändringsbar: \code{val xs: scala.collection.mutable.Set[String]}
\end{itemize}

\item Behöver du leta upp värden \code{x:Int} utifrån en nyckel av t.ex. String?
\begin{itemize}\SlideFontTiny
\item Oföränderlig: \code{   val xs: Map[String, Int] }
\item Förändringsbar: \code{val xs: scala.collection.mutable.Map[String, Int]}
\end{itemize}


\end{itemize}
\end{Slide}

% \begin{Slide}{Tillåtna uppdateringar i din QuickRef}
% Du får med egen penna göra dessa fixar i din QuickRef:
% \begin{itemize}
% \item Grundtypernas implementation, sid 4:
% \begin{itemize}
%
% \item omfång för Int ska ha exponent 31 (inte 15),
% \item omfång för Long ska ha exponent 63 (inte 15).
% \end{itemize}
%
% \item Saknade samlingsmetoder:
% \begin{itemize}
% \item Under rubriken "Methods in trait Map[K, V]" saknas metoderna keySet och mapValues.
% \item Saknade metoderna för mutable.ArrayBuffer[T]: \\ \code{update} \code{insert} \code{remove} \code{append} \code{prepend}, etc. \\ lägg till beskrivning på lediga platsen på sista sidan \\
% (se vidare commit \href{https://github.com/lunduniversity/introprog/commit/a5e29d000062}{a5e29d000062a} i kursrepot)
% \end{itemize}
% \end{itemize}
% \end{Slide}


\begin{Slide}{ArrayBuffer}
Viktigast att känna till: update, insert, remove, append
{\SlideFontTiny

\vspace{2.5em}\begin{tabular}{@{}p{4.2cm}  p{6.5cm}}
\texttt{xs(i) = x \newline xs.update(i, x)} & Replace element at index i with x. \newline Return type Unit.\\   \cline{1-2}

\texttt{xs.insert(i, x)\newline xs.remove(i)} & Insert x at index \texttt{i}. Remove element at i. \newline Return type Unit.\\   \cline{1-2}

\texttt{xs.append(x)~~~xs~+=~x} & Insert x at end.  Return type Unit.\\   \cline{1-2}

\texttt{xs.prepend(x)~~x~+=:~xs} & Insert x in front.  Return type Unit.\\   \cline{1-2}

\texttt{xs -= x} & Remove first occurance of x (if exists). \newline Returns xs itself. \\\cline{1-2}

\texttt{xs ++= ys} & Appends all elements in ys to xs and returns xs itself. \\

\end{tabular}
}
\end{Slide}





\Subsection{Repetition}

\begin{Slide}{Översikt av innehållet i Grumligt-lådan}\SlideFontSmall
Ämnen (antal)
\begin{multicols}{2}
\begin{itemize}\SlideFontTiny
\item arv (4)
\item getter, setter (4)
\item kompanjonsobjekt (4)
\item case-objekt (4)
\item try (4)
\item java (3)
\item matriser (3)
\item sortering (3)
\item ArrayBuffer (2)
\item loopar (2)
\item Map och map (2)
\item option (2)
\item problemlösning (2)
\item (1) \\
funktionsvärden;
generiska funktioner;
groupBy;
in-mixning;
klasser och case-klasser;
konstanter;
konstruktor;
läsa från textfil;
läsa kod;
match case;
objektfabriksmetod;
pirateslabben;
private[this];
sortBy;
static;
type;
typparameter;

\end{itemize}
\end{multicols}
\end{Slide}

\begin{Slide}{Översikt av innehållet i Nyfiken-på-lådan}\SlideFontSmall
Ämnen (antal)
\begin{multicols}{2}
\begin{itemize}\SlideFontTiny
\item gränssnitt (3)
\item Java (3)
\item rekursion (3)
\item funktionsprogrammering (2)
\item generiska typer (2)
\item implicit (2)
\item trådar, Future (2)
\item webb, html (2)
\item (1) \\
bilder, ljud och spara filer;
enkel AI;
minneshantering i olika språk (GC eller manuell);
gå igenom och förklara QuickRef mer noggrant;
hacka andras kod i låsta applikationer;
hashcode;
kryptering;
prestanda och minnesåtgång Scala vs Java;
Stream[T];
teorin bakom neurala nätverk;
\end{itemize}
\end{multicols}
\end{Slide}


\begin{Slide}{Oföränderlig punkt  i Scala och Java}\SlideFontSmall
I Scala: (utan case-klass ingen najs \code{toString} och måste skriva \code{new}, etc.)
\begin{Code}
class Point(val x: Int, val y: Int)
\end{Code}

I Java:
\begin{Code}[language=Java,basicstyle=\ttfamily\SlideFontSize{5.8}{7}]
public class JPoint {
    private int x;
    private int y;

    public JPoint(int x, int y){
        this.x = x;
        this.y = y;
    }

    public int getX(){
        return x;
    }

    public int getY(){
        return y;
    }
}
\end{Code}
\end{Slide}

\begin{Slide}{Föränderlig punkt  i Scala och Java}\SlideFontSmall
I Scala:
\begin{Code}
class Point(var x: Int, var y: Int)
\end{Code}

I Java:
\begin{Code}[language=Java,basicstyle=\ttfamily\SlideFontSize{5.2}{6}]
public class JPoint {
    private int x;
    private int y;

    public JPoint(int x, int y){
        this.x = x;
        this.y = y;
    }

    public int getX(){
        return x;
    }

    public int getY(){
        return y;
    }

    public void setX(int x){
        this.x = x;
    }

    public void setY(int y){
        this.y = y;
    }
}
\end{Code}
\end{Slide}

\begin{Slide}{Punkt med räknare och setter i Scala}
Övning: lägg till getter och setter för y-koordinaten.
\begin{Code}
class Point(private var myX: Int, private var myY: Int){
  import Point._
  def x = myX
  def x_=(newX: Int): Unit = {
    myX = newX
  }
  myCount += 1   // kod i klasskroppen körs vid konstruktion
}

object Point {
  private var myCount = 0
  def count = myCount
}
\end{Code}
\SlideFontSmall
Man brukar kalla privata attribut som har getter (och ev. setter) för något i stil med \code{myX} eller vanligare \code{_x} för att namnet inte ska krocka med getter/setter.
\end{Slide}



\begin{Slide}{Punkt med räknare i Java}

\begin{Code}[language=Java,basicstyle=\ttfamily\SlideFontSize{5.2}{6}]
public class JPoint {
    private int x;
    private int y;

    static private int count = 0;  // static: finns bara en upplaga av detta attribut

    public JPoint(int x, int y){
        this.x = x;
        this.y = y;
        count++;
    }

    public int getX(){
        return x;
    }

    public int getY(){
        return y;
    }

    public void setX(int x){
        this.x = x;
    }

    public void setY(int y){
        this.y = y;
    }

    static public int getCount(){
       return count;
    }
}
\end{Code}


\end{Slide}

\begin{Slide}{Gamla Java-kursen}
Du hittar genomgång av olika Java-begrepp i gamla Java-kursen som finns här: \\\vspace{1em}
\url{http://cs.lth.se/eda016/}
\\\vspace{2em}

Övning: träna på att översätta Java-exempel till scala

\end{Slide}



\Subsection{Genomgång av extenta}

\begin{Slide}{Genomgång av extenta}
\url{http://cs.lth.se/pgk/examination/}

\vspace{1em}
\begin{itemize}
\item \Alert{Omtenta 2017-08-23}:
\begin{itemize}
  \item mängder (Keno)
  \item tabeller (Quiz)
  \item linjärsökning i Java (UberSquare)
\end{itemize}
\item \href{http://fileadmin.cs.lth.se/pgk/EDAA45-exam-2017aug23.pdf}{tentamen}
\item \href{http://fileadmin.cs.lth.se/pgk/EDAA45-exam-2017aug23-solution.pdf}{lösning}
\end{itemize}
\end{Slide}




\fi
