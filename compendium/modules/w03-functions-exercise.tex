%!TEX encoding = UTF-8 Unicode
%!TEX root = ../exercises.tex

\ifPreSolution

\Exercise{\ExeWeekTHREE}\label{exe:W03}
\begin{Goals}
\input{modules/w03-functions-exercise-goals.tex}
\end{Goals}

\begin{Preparations}
\item \StudyTheory{03}
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\else

\ExerciseSolution{\ExeWeekTHREE}

\fi





\WHAT{Para ihop begrepp med beskrivning.}

\QUESTBEGIN

\Task \what

\vspace{1em}\noindent Koppla varje begrepp med den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}
\input{generated/quiz-w03-concepts-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w03-concepts-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND





\WHAT{Definiera och anropa funktioner.}

\QUESTBEGIN

\Task \label{task:funcall} \what~
En funktion med en parameter definieras med följande syntax i Scala:
\vspace{0.5em} \\
\texttt{\code{def} \textit{namn}(\textit{parameter}: \textit{Typ} = \textit{defaultArgument}): \textit{Returtyp} = \textit{returvärde}}

% En funktion med två parametrar definieras med följande syntax i Scala: \vspace{0.5em} \\  \texttt{\code{def} \textit{namn}(\textit{parameter1}: \textit{Typ1}, \textit{parameter2}: \textit{Typ2}): \textit{Returtyp} = \textit{returvärde}}

\Subtask Definiera en funktionen \code{öka} som har en heltalsparameter \code{x} och vars returvärde är argumentet plus 1. Defaultargument ska vara 1. Ange returtypen explicit.

\Subtask Vad har uttrycket \code{öka(öka(öka(öka())))} för värde?

\Subtask Definiera funktionen \code{minska} som har en heltalsparameter \code{x} och vars returvärde är argumentet minus 1. Defaultargument ska vara 1. Ange returtypen explicit.

\Subtask Vad är värdet av uttrycket \code{öka(minska(öka(öka(minska(minska())))))}

\Subtask Vad är det för skillnad mellan parameter och argument?

\SOLUTION

\TaskSolved \what

\SubtaskSolved
\begin{Code}
def öka(x: Int = 1): Int = x + 1
\end{Code}

\SubtaskSolved  \code{4}

\SubtaskSolved
\begin{Code}
def minska(x: Int = 1): Int = x - 1
\end{Code}

\SubtaskSolved  \code{0}

\SubtaskSolved
\begin{itemize}
  \item \emph{Kort, förenklad förklaring:} Parametern i funktionshuvudet är ett lokalt namn på indata som kan användas i funktionskroppen, medan argumentet är själva värdet på parametern som skickas med vid anrop.
  \item \emph{Längre, mer exakt förklaring:} En \textbf{parameter} är en deklaration av en oföränderlig variabel i ett funktionshuvud vars namn finns tillgängligt lokalt i funktionskroppen. Vid anrop \emph{binds} parameternamnet till ett specifikt argument. Ett \textbf{argument} är ett uttryck som  appliceras på en funktion vid anrop. Normalt evalueras argumentet innan anropet sker, men om parametertypen föregås av \code{=>} fördröjs evalueringen av argumentet och sker i stället \emph{varje gång} parameternamnet förekommer i funktionskroppen.
\end{itemize}

\QUESTEND




\WHAT{Textspelet AliensOnEarth.}

\QUESTBEGIN

\Task  \what~Ladda ner spelet nedan \footnote{
\url{https://raw.githubusercontent.com/lunduniversity/introprog/master/compendium/examples/AliensOnEarth.scala}} och studera koden.

\scalainputlisting[basicstyle=\ttfamily\fontsize{10.5}{12.5}\selectfont]{examples/AliensOnEarth.scala}

% def randomDistribution(weights: Vector[Int]): Int = {
%   require(weights.size > 0)
%   require(weights.forall(_ >= 0))
%
%   val probabilities = for (w <- weights) yield w / weights.sum.toDouble
%   val rnd = math.random
%   var i = 0
%   var sum = probabilities(i)
%   while (i < probabilities.size - 1 && rnd > sum) {
%     i += 1
%     sum += probabilities(i)
%   }
%   i
% }

\Subtask Medan du läser koden, försök lista ut vilket som är bästa strategin för att få så mycket poäng som möjligt. Kompilera och kör spelet i terminalen med ditt favoritnamn som argument. Vilket av de tre objekten på planeten jorden har störst sannolikhet att vara bästa alternativet?

\Subtask Para ihop kodsnuttarna nedan med bästa beskrivningen.\footnote{Gör så gott du kan även om allt inte är solklart. Vissa saker kommer vi att gå igenom i detalj först under senare kursmoduler.}

\begin{ConceptConnections}
\input{generated/quiz-w03-code-fragments-taskrows-generated.tex}
\end{ConceptConnections}

\noindent\emph{Tips:} Med hjälp av REPL kan du ta reda på hur olika delar fungerar, i likhet med nedan undersökningar:

\begin{REPL}
scala> val os = Vector("p", "w", "a")
scala> os.indices
scala> os.indices.foreach(i => println(i))
scala> os.indexOf("w")
scala> os.indexOf("gurka")
scala> Vector("hej", "hejsan", "hej").indexOf("hej")
scala> try { 1 / 0 } catch { case e: Exception=> println(e) }
\end{REPL}
Kolla även dokumentationen för \code{nextInt}, \code{readLine}, m.fl genom att söka
här: \\ \url{http://www.scala-lang.org/api/current/index.html}


\begin{framed}
\noindent\emph{Tips inför fortsättningen:}

\begin{itemize}
  \item När jag hittade på \code{AliensOnEarth} började jag med ett mycket litet program med en enkel \code{main}-funktion som bara skrev ut något kul. Sedan byggde jag vidare på programmet steg för steg och kompilerade och testade efter varje liten ändring.

  \item När jag kodar har jag REPL igång i ett eget terminalfönster och api-dokumentationen för Scala i en webbläsare redo för sökningar. Jag återanvänder också användbara snuttar från kod jag gjort tidigare och inspireras ofta av lösningar från \url{https://stackoverflow.com} (om jag kan begripa dem och de verkar rimliga).

  \item Detta arbetssätt tar ett tag att komma in i, men är ett bra sätt att uppfinna allt större och bättre program. Ett stort program byggs lättast i små inkrement och felsökning blir mycket lättare om man bara gör små tillägg åt gången.

  \item  Du får också det mycket lättare att förstå ditt program om du delar upp koden i många korta funktioner med bra namn. Du kan sedan lättare hitta på mer avancerade funktioner genom att återanvända befintliga.

  \item Under veckans laboration ska du utveckla ditt eget textspel. Då har du nytta av att återanvända funktionerna för indata och slumpdragning från \code{AliensOnEarth}.
\end{itemize}

\end{framed}


\SOLUTION

\TaskSolved \what~

\SubtaskSolved \code{"penguin"} är bästa alternativ med sannolikheten $\frac{1}{2} + \frac{1}{2}\cdot\frac{1}{3} = \frac{2}{3}$

\SubtaskSolved

\begin{ConceptConnections}
  \input{generated/quiz-w03-code-fragments-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND





\WHAT{Föränderlighet av parametrar.}

\QUESTBEGIN

\Task \what~Är en parameter oföränderlig i funktionskroppen ...

\Subtask ... i Scala?  (Ja/Nej)

\Subtask ... i Java?  (Ja/Nej)


\SOLUTION

\TaskSolved \what~

\Subtask Nej, i Scala är parametern oföränderlig och det blir kompileringsfel om man försöker tilldela den ett nytt värde i funktionskroppen.

\Subtask Ja det går utmärkt i Java att ändra värdet på parametern i funktionskroppen med tilldelning, men koden riskerar att bli förvirrande.\\
\url{https://stackoverflow.com/questions/2970984}

\QUESTEND






%%%%%%%%%%%%%%%%%%%%% TODO FIXA NEDAN; KOLLA, FLYTTA, STRYK


\vspace{2em}\noindent\TODO Se över nedan uppgifter. Flytta? Stryka? Ändra?


\WHAT{Funktion med default-argument.}

\QUESTBEGIN

\Task  \what~  Förklara vad som händer här?

\begin{REPL}
scala> def inc(i: Int, j: Int = 1) = i + j
scala> inc(42, 2)
scala> inc(42, 1)
scala> inc(42)
\end{REPL}

\SOLUTION

\TaskSolved \what

Funktionen lägger helt enkelt ihop två värden och om det andra saknas så lägger den bara på 1 till första värdet, d.v.s. om andra värdet saknas antas det vara 1.

Så det första anropet returnerar 44, det andra 43 och det sista returnerar även det 43 då j antas vara 1.

\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 4




\WHAT{Funktionsanrop med namngivna argument.}

\QUESTBEGIN

\Task  \what~
\begin{REPL}
scala> def skrivNamn(förnamn: String, efternamn: String) =
         println("Namn: " + efternamn + ", " + förnamn)
scala> skrivNamn("Kim", "Finkodare")
scala> skrivNamn(förnamn = "Viktor", efternamn = "Oval")
scala> skrivNamn(efternamn = "Triangelsson", förnamn = "Stina")
\end{REPL}

\Subtask Förklara vad som händer ovan?

\Subtask Vad är fördelen med namngivna argument?



\SOLUTION


\TaskSolved \what


\SubtaskSolved
Utskriften blir följande:
\begin{REPLnonum}
Namn: Finkodare, Kim
Namn: Oval, Viktor
Namn: Triangelsson, Stina
\end{REPLnonum}
Eftersom vi har namngett argumenten så behöver vi inte nödvändigtvis skriva argumenten i rätt ordning. Att namnge argumenten i andra anropet gör ingen skillnad, men i tredje så skriver vi egentligen in argumenten i fel ordning.

\SubtaskSolved
Det blir lättare att hålla reda på vad som är vad både när man skriver och sedan när man ska läsa koden. Det låter oss även skriva argument i den ordningen som känns naturligast för oss istället för vad funktionen har dikterat.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 5




\WHAT{Applicera en funktion på elementen i en samling.}

\QUESTBEGIN

\Task  \what~  Använd dina funktioner \code{öka} och \code{minska} från uppgift \ref{task:funcall}. Vad har nedan uttryck för värde? Förklara vad som händer.

\Subtask \code{for (i <- 0 to 4) yield öka(i)}

\Subtask \code{for (i <- 1 to 5) yield minska(i)}

\Subtask \code{(0 to 4).map(i => öka(i))}

\Subtask \code{(1 to 5).map(i => minska(i))}

\Subtask \code{(0 to 4).map(öka)}

\Subtask \code{(1 to 5).map(minska)}

\Subtask \code{Vector(12, 3, 41, -8).map(öka)}

\Subtask \code{Vector(12, 3, 41, -8).map(öka).map(minska).map(minska)}



\SOLUTION


\TaskSolved \what

Detta är alla olika sätt att köra en funktion över alla element i en samling

\SubtaskSolved  \code{Vector(1, 2, 3, 4, 5)}

\SubtaskSolved  \code{Vector(0, 1, 2, 3, 4)}

\SubtaskSolved  \code{Vector(1, 2, 3, 4, 5)}

\SubtaskSolved  \code{Vector(0, 1, 2, 3, 4)}

\SubtaskSolved  \code{Vector(1, 2, 3, 4, 5)}

\SubtaskSolved  \code{Vector(0, 1, 2, 3, 4)}

\SubtaskSolved  \code{Vector(13, 4, 42, -7)}

\SubtaskSolved  \code{Vector(11, 2, 40, -9)}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 6







\WHAT{Värdeanrop och namnanrop (fördröjd evaluering, ''lata'' argument).}

\QUESTBEGIN

\Task  \what~  Deklarera nedan funktioner i REPL eller Kojo.

\begin{Code}
def snark: Int = {print("snark "); Thread.sleep(1000); 42}
def callByValue(x: Int) = x + x
def callByName(x: => Int) = x + x
\end{Code}

Evaluera nedan uttryck. Förklara vad som händer.

\Subtask \code{snark}

\Subtask \code{snark; snark; snark}

\Subtask \code{callByValue(1)}

\Subtask \code{callByName(1)}

\Subtask \code{callByValue(snark)}

\Subtask \code{callByName(snark)}


\Subtask Förklara vad som händer här:
\begin{REPL}
scala> def görDetta(block: => Unit) = block
scala> görDetta(println("hej"))
scala> görDetta{println("goddag")}
scala> görDetta{println("hej"); println("svejs")}
scala> def görDettaTvåGånger(block: => Unit) = {block; block}
scala> görDettaTvåGånger{println("goddag")}
\end{REPL}


\SOLUTION


\TaskSolved \what


\SubtaskSolved  \code{snark, Int = 42}

\SubtaskSolved  \code{snark snark snark, Int = 42}

Den evaluerar inte uttrycket förrän det behövs, så flera snark ger bara ett resultat för det är bara det som begärs.

\SubtaskSolved  \code{2}

\SubtaskSolved  \code{2}

Det är ingen större skillnad när vi bara skickar in en etta.

\SubtaskSolved  \code{snark, Int = 84}

\SubtaskSolved  När vi kallar på \code{callByValue} så skickar vi in snark som ett värde, och därmed behöver x bara beräknas en gång medans när vi kallar på \code{callByName} så skickar vi den som en funktion och därmed kallas snark på två gånger i funktionen för att beräkna x båda gångerna.

\code{snark snark, Int = 84}

\SubtaskSolved  \code{görDetta} är en kontrollstruktur som helt enkelt exekverar koden den matas med, \code{görDettaTvåGånger} gör just vad den säger. Detta är dock grunderna för vad som kan bli mycket mer advancerat om man kombinerar detta med loopar eller if-satser, som i sig är kontrolstrukturer.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 8




\WHAT{Uppdelad parameterlista.}

\QUESTBEGIN

\Task  \what~  Man kan dela upp parametrarna till en funktion i flera parameterlistor. Förklara vad som händer här:
\begin{REPL}
scala> def add(a: Int)(b: Int) = a + b
scala> add(22)(20)
scala> add(22)(add(1)(19))
\end{REPL}


\SOLUTION


\TaskSolved \what


Först så adderas 22 och 20 för att bli 42.
Sedan adderas först 1 och 19 och det adderas sen med 22 för att tillslut bli 42.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 9




\WHAT{Skapa din egen kontrollstruktur.}

\QUESTBEGIN

\Task  \what~

\Subtask Använd fördröjd evaluering i kombination med en uppdelad parameterlista och skapa din egen kontrollstruktur enligt nedan. (Det är så här som loopen \code{upprepa} i Kojo är definierad.)
\begin{REPL}
scala> def upprepa(n: Int)(block: => Unit): Unit = {
         var i = 0
         while (i < n) {block; i = i + 1}
       }
\end{REPL}

\Subtask Använd din nya loop-procedur och förklara vad som händer nedan.
\begin{REPL}
scala> upprepa(10)(println("hej"))
scala> upprepa(1000){
  val tärning = (math.random * 6 + 1).toInt
  print(tärning + " ")
}
\end{REPL}



\SOLUTION


\TaskSolved \what


\SubtaskSolved  -

\SubtaskSolved  I den första parameterlistan så anges hur många gånger koden i den andra parameterlistan ska exekveras. så \code{upprepa(10)(println("hej"))} printar hej 10 gånger



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 10




\WHAT{Funktion som värde.}

\QUESTBEGIN

\Task  \what~  Funktioner är äkta värden i Scala.

\Subtask \label{subtask:funcval} Förklara vad som händer nedan. Notera understrecket på rad 4:

\begin{REPL}[numbers=left, numberstyle=\color{black}\ttfamily\scriptsize\selectfont]
scala> def inc(x: Int): Int = x + 1
scala> inc(42)
scala> Vector(12, 3, 41, -8).map(inc)
scala> val f = inc _
scala> Vector(12, 3, 41, -8).map(f)
\end{REPL}

\Subtask Vad händer om du bara skriver \code{val f = inc} utan understreck?

\Subtask På liknande sätt som i uppgift \ref{subtask:funcval}: definiera en funktion \code{dec} som i stället \emph{minskar} med 1. Deklarera ett funktionsvärde \code{g} som tilldelas funktionen \code{dec} och kör sedan \code{g} på varje element i \code{Vector(12, 3, 41, -8)} med metoden \code{map}.

\Subtask Vad har variablerna \code{f} och \code{g} ovan för typ?

\Subtask Förklara vad som händer nedan. Vad får \code{d} och \code{h} för värde?

\begin{REPL}
scala> def applicera(x: Int, f: Int => Int) = f(x)
scala> def dubbla(x: Int) = 2 * x
scala> def halva(x: Int) = x / 2
scala> val d = applicera(42, dubbla)
scala> val h = applicera(42, halva)
\end{REPL}

\SOLUTION


\TaskSolved \what


\SubtaskSolved  Man kan spara en funktion som en variabel och funktioner kan likt andra värden sparade i variabler användas i andra funktioner så länge det är godkänd indata. Så femte raden blir identisk med tredje.

\SubtaskSolved  Kompilatorn saknar en parameterlista så den kastar ett fel, genom att ange \_ så säger vi åt den att vi tar emot en godtycklig parameter.

\SubtaskSolved
\begin{REPLnonum}
def dec(x: Int): Int = x - 1
val g = dec _
Vector(12, 3, 41, -8).map(g)
\end{REPLnonum}

\SubtaskSolved  Int => Int

g har samma typ som f alltså  Int => Int

\SubtaskSolved  d = 84, h = 21. Räkna tar en funktion och ger den det första argumentet som indata.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 11




\WHAT{Stegade funktioner (''Curry-funktioner'').}

\QUESTBEGIN

\Task  \what~ Förklara vad som händer nedan.
\begin{REPL}
scala> def sum(a: Int)(b: Int) = a + b
scala> sum(1)(2)
scala> val f = sum(42) _
scala> f(1)
scala> val inc = sum(1) _
scala> val dec = sum(-1) _
scala> inc(42)
scala> dec(42)
\end{REPL}

\SOLUTION


\TaskSolved \what
 När man gör curryfunktioner så skjuter man upp att ange det andra värdet till senare och på så sätt gör "nya" funktioner så att säga. När vi sparar undan variablen \code{f} så har vi angett första argumentet men den väntar fortfarande på det andra som vi anger sen vilket ger ett resultatvärde.

Samma sak senare, genom att skapa variablerna inc och dec som summan av +1 respektive -1 så har vi "skapat" våra \code{inc} och \code{dec} funktioner från tidigare funktioner.



\QUESTEND

\WHAT{Äkta funktioner.}

\QUESTBEGIN

\Task  \what~  En \textbf{äkta funktion} ger alltid samma resultat med samma argument  (så som vi är vana vid inom matematiken).\footnote{Äkta funktioner uppfyller per definition  \textit{referentiell transparens} \Eng{referential transparency} som du kan läsa mer om här:  \href{https://en.wikipedia.org/wiki/Referential_transparency}{en.wikipedia.org/wiki/Referential\_transparency}}

\begin{Code}
object inSearchOfPurity {
  var x = 0
  val y = x
  def inc(i: Int) = i + 1
  def oink(i: Int) = {x = x + i; "Pig says " + "oink " * x}
  def addX(i: Int): Int = x + i
  def addY(i: Int): Int = y + i
  def isPalindrome(s: String): Boolean = s == s.reverse
  def rnd(min: Int, max: Int) = math.random * max + min
}
\end{Code}

\Subtask Vilka funktioner i objektet \code{inSearchOfPurity} är äkta funktioner?

\Subtask \label{subtask:nonpure} Anropa de funktioner som inte är äkta i REPL och demonstrera med exempel att de kan ge olika resultat för samma argument.

\Subtask Vad är objektets tillstånd efter dina körningar i uppgift \ref{subtask:nonpure}?

\Subtask Vilken del av tillståndet i objektet är oföränderligt?



\SOLUTION


\TaskSolved \what


\SubtaskSolved  inc, addY och isPalindrome. Notera att y sätts till x's värde i början vilket är 0 och sedan kan det inte ändras eftersom det är en \code{val}.

\SubtaskSolved  Försök att med samma argument få olika resultat med samma funktion genom att ändra x

\SubtaskSolved  Vad är x och y?

\SubtaskSolved  y



\QUESTEND




\WHAT{NEEDS A TOPIC DESCRIPTION}

\QUESTBEGIN

\Task  \what~ Funktioner är objekt med en \code{apply}-metod.

\Subtask Förklara vad som händer här:
\begin{REPL}
scala> object plus { def apply(x: Int, y: Int) = x + y }
scala> plus.apply(42,43)
scala> plus(42, 43)
scala> val add: (Int, Int) => Int = (x, y) => x + y
scala> add(42, 42)
scala> add.   // tryck på TAB
scala> add.apply(42, 42)
scala> val inc = add.curried(1)
scala> inc(42)
\end{REPL}

\Subtask Definiera i REPL ett objekt som heter \code{slumptal} som har en \code{apply}-metod som tar två heltalsparametrar \code{a} och \code{b} och som med hjälp av \code{math.random} returnerar ett slumpmässigt heltal i intervallet $[a, b]$. Anropa objektets \code{apply}-metod med \code{(1 to 100).foreach(i => print(??? + " "))} för att skriva ut $100$ slumptal mellan 1 och 6. Prova både att explicit anropa \code{apply} med punktnotation och att använda funktionsappliceringssyntax.



\SOLUTION


\TaskSolved \what


\SubtaskSolved
Först notera att \code{plus} med bara paranteser och med \code{apply} är indentiska anrop, för det är det som är tricket med ett object med \code{apply} metod man kan kalla på den som en funktion.

Sedan sparar vi en funktion som add, men eftersom alla fukntioner också är object så så har de några andra metoder man också kan anropa vilket vi ser med TAB.

Till sist så sparar vi en ny funktion inc som en curry funktion av add med 1 som argument.

\SubtaskSolved
\begin{REPL}
scala> object slumptal{ def apply(a: Int, b: Int) = (math.random * b + a).toInt }
defined object slumptal

scala> (1 to 100).foreach{i => print(slumptal.apply(1,6) + " ")}
3 5 6 6 5 3 4 3 2 3 1 3 1 2 2 5 1 2 6 2 1 1 4 5 5 3 4 6 5 1 1 2 3 1 1 1 4 4 6 1 1 6 3 3 1 4 3 4 2 3 4 4 1 2 5 6 1 6 4 2 5 3 6 1 6 5 1 1 1 3 4 3 5 5 3 6 6 4 4 1 2 5 6 5 5 1 1 2 6 1 6 4 6 3 5 5 2 2 3 3
scala> (1 to 100).foreach{i => print(slumptal(1,6) + " ")}
4 2 1 6 5 2 5 2 2 3 1 3 3 3 5 1 6 1 1 2 2 2 2 2 3 6 1 5 6 4 2 3 3 2 2 4 1 5 4 6 4 5 6 2 4 4 3 4 3 3 3 1 3 2 6 4 3 6 4 2 6 6 3 1 1 3 4 3 6 1 4 4 4 5 5 2 5 2 4 2 5 2 1 4 1 5 4 3 1 2 3 6 3 3 5 5 6 6 6 5

\end{REPL}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 15




\WHAT{Fördröjd initialisering (''lata'' variabler).}

\QUESTBEGIN

\Task  \what~

\Subtask \label{subtask:delayalloc} Förklara vad som händer här:
\begin{REPL}
scala> val olat = 42
scala> lazy val lat = 42
scala> println(lat)
scala> val nu = {Thread.sleep(1000); println("nu"); 42}
scala> lazy val sen = {Thread.sleep(1000); println("sen"); 42}
scala> def igen = {Thread.sleep(1000); println("hver gang"); 42}
scala> println(nu)
scala> println(sen)
scala> println(igen)
scala> println(nu)
scala> println(sen)
scala> println(igen)
scala> object m {lazy val stor = Array.fill(1e9.toInt)(liten); val liten = 42}
scala> m.liten
scala> m.stor
\end{REPL}

\Subtask Vad är skillnaden mellan \code{val}, \code{lazy val} och \code{def}, vad gäller \emph{när} evalueringen sker?


\Subtask \label{subtask:forwardref} Förklara vad som händer här:
\begin{REPL}
scala> object objektÄrLata { val sen = { println("nu!"); 42 } }
scala> objektÄrLata
scala> objektÄrLata.sen
scala> {val x = y; val y = 42}
scala> object buggig {val a = b; val b = 42}
scala> buggig.a
scala> object funkar {lazy val a = b; val b = 42}
scala> funkar.a
scala> object nowarning {val many = Array.fill(10)(one); val one = 1}
scala> nowarning.many
\end{REPL}

\Subtask Med ledning av uppgift \ref{subtask:delayalloc} och uppgift \ref{subtask:forwardref}, beskriv två olika situationer när kan man ha nytta av \code{lazy val}?


\SOLUTION


\TaskSolved \what


\SubtaskSolved  Notera vid deklarationen av \code{nu}, \code{sen} och \code{igen} så är det bara \code{nu} som tar tid och skriver ut sin text. För \code{nu} evalueras men de andra väntar.

Men när vi ska kalla på dem så tar \code{nu} ingen tid och skriver inte ut nu medans \code{sen} och \code{igen} nu tar tid och skriver ut sin text. För \code{nu} har redan evaluerats men de andra behöver evalueras för de kallas på.

Och när vi kallar på dem för andra gången så är det bara \code{igen} som tar tid. För \code{nu} och \code{sen} är evaluerade och vid det här laget identiska medans \code{igen} behöver evalueras varje gång man kallar på den.

Vid deklaration av objektet så går allt bra, när vi kallar på \code{liten} så får vi 42 men när vi kallar på \code{stor} så får vi exception. Eftersom objekt är lata så evalueras inte objektet förrän vi anropar något ur det men \code{stor} är också lazy så den blir inte ett problem förrän just den anropas.

\SubtaskSolved
\code{val} evalueras direkt, \code{lazy val} evalueras när det behövs medans \code{def} evalueras varje gång det behövs.

\SubtaskSolved
När vi skapar objektÄrLata så skrivs inget ut för det evalueras inte förrän vi kallar på det, som vi gör nästa rad då skrivs nu ut. När vi sedan anropar sen evalueras inget och nu skrivs inte ut.

\{\code{val x=y; val y = 42}\} kastar error eftersom y inte är evaluerad när vi försöker evaluera x.

När vi skapar \code{buggig} så varnar den och vi ser varför på nästa rad då att \code{a} verkar vara lika med 0. Eftersom \code{b} inte är evaluerad än så blir det 0 men till skillnad från tidigare vet \code{val a} iallafall att den är en Int eftersom objectet med \code{b} är åtminstone definerat.

\code{funkar} fungerar just för att \code{a} är en \code{lazy val} och evalueras då inte förrän efter \code{b} evaluerats och ger därför 42 som den ska.

\code{nowarning} har samma problem som \code{buggig} men ger ingen varning och därför försöker skriva ut innan \code{one} är evaluerad och ger därför nollor.

\SubtaskSolved
När man vill skapa ett objekt som funkar eller fixa problemet i no warning, man kan vilja ha sina variabler i just den ordningen p.g.a. läslighet.

Men även om man inte vill slöa ner ett system med en massa arbete när allt deklareras på en gång utan tar det hellre gradvis allteftersom det används.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 16




\WHAT{Aktiveringspost.}

\QUESTBEGIN

\Task  \what~  Antag att vi bara kan addera eller subtrahera med ett. Då kan man ändå skapa en additionsfunktion på nedan (ganska omständliga) sätt. Skriv nedan program i en editor, kompilera och exekvera.
\begin{Code}
object Count {
  def inc(x: Int) = {println("inc[x = " + x + "]"); x + 1}
  def dec(x: Int) = {println("dec[x = " + x + "]"); x - 1}

  def add(x: Int, y: Int) = {
    println("add[x = " + x + ", y = " + y + "]")
    var result = x
    var i = 0
    while (i < math.abs(y)){
      result = if (y >= 0) inc(result) else dec(result)
      i = i + 1
    }
    result
  }

  def main(args: Array[String]): Unit = {
    val x =  inc(dec(inc(0)))
    println(x)
    val y = add(1, add(1, add(1, -2)))
    println(y)
  }
}
\end{Code}

\Subtask Vad skrivs ut? Förklara vad som händer.

\Subtask Rita hur anropsstacken förändras under exekveringen av main-metoden.


\SOLUTION


\TaskSolved \what


\SubtaskSolved
Utskrift: \\
inc[x = 0]\\
dec[x = 1]\\
inc[x = 0]\\
1\\

\code{inc} kallar på \code{dec} som i sin tur kallar på \code{inc} med argumentet 0. den sista funktionen returnerar sedan 1 varpå nästa minskar till 0 och den sista ökar till 1.

add[x = 1, y = -2]\\
dec[x = 1]\\
dec[x = 0]\\
add[x = 1, y = -1]\\
dec[x = 1]\\
add[x = 1, y = 0]\\
1\\

\code{add} kallas på tre gånger, \code{add} längst ner kallar på \code{dec} två gånger på varandra för att returnera -1 till andra \code{inc} som tar det som argument.

Den andra \code{add} kallar på \code{dec} en gång och returnerar 0 till första \code{add}

Den ursprungliga \code{add} returnerar till sist 1 utan att kalla på några andra funktioner

\SubtaskSolved
Stacken för \code{x} när den är som djupast

\begin{tabular}{|c|}
\hline
inc \\
\hline
dec\\
\hline
inc \\
\hline
\end{tabular}
\\
\\
När vi har nått tredje add och den kallat på dec så ser den ut så här för två iterationer.
\\
\\
\begin{tabular}{|c|}

\hline
dec \\
\hline
add \\
\hline
add\\
\hline
add \\
\hline
\end{tabular}
\\
\\
Sedan vid det andra add så ser den ut så här i en iteration varpå den sedan rensas
\\
\\
\begin{tabular}{|c|}

\hline
dec \\
\hline
add \\
\hline
add\\
\hline
\end{tabular}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 17




\WHAT{Lokala funktioner.}

\QUESTBEGIN

\Task  \what~  Skapa nedan program i en editor, kompilera och exekvera. I programmet nedan har metoden \code{add} två lokala funktioner som skiljer sig från metoderna med samma namn.
\begin{Code}
object Count {
  def inc(x: Int) = x + 1
  def dec(x: Int) = x - 1

  def add(x: Int, y: Int) = {
    def inc(x: Int) = {println("inc[x = " + x + "]"); x + 1}
    def dec(x: Int) = {println("dec[x = " + x + "]"); x - 1}
    println("add[x = " + x + ", y = " + y + "]")
    var result = x
    var i = 0
    while (i < math.abs(y)){
      result = if (y >= 0) inc(result) else dec(result)
      i = i + 1
    }
    result
  }

  def main(args: Array[String]): Unit = {
    val x =  inc(dec(inc(0)))
    println(x)
    val y = add(1, add(1, add(1, -2)))
    println(y)
  }
}
\end{Code}

\Subtask Vad skrivs ut? Förklara vad som händer.

\Subtask Vilka fördelar finns med lokala funktioner?


\SOLUTION


\TaskSolved \what


\SubtaskSolved
1\\
add[x = 1, y = -2]\\
dec[x = 1]\\
dec[x = 0]\\
add[x = 1, y = -1]\\
dec[x = 1]\\
add[x = 1, y = 0]\\
1\\
Vi saknar utskrift när den arbetar med \code{x} för den använder de funktioner som den känner till vilket är de versioner utan utskrift, när vi kallar på \code{add} så får vi dock utskrift när vi kallar på \code{inc} samt \code{dec} för add använder sin lokala variant.

\SubtaskSolved
Den stora fördelen är att man kan separera kod i funktioner lokalt utan att påverka något utanför och därmed göra sin kod mer lättläst. Det kommer även dock till stor nytta ifall man vill ha annan funktionalitet lokalt än allmänt, då kan man definera en ny lokal funktion med samma namn som gör något lite anorlunda.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 18




\WHAT{Anonyma funktioner.}

\QUESTBEGIN

\Task  \what~  Vi har flera gånger sett syntaxen \code{i => i + 1}, till exempel i en loop \code{(1 to 10).map(i => i + 1)} där funktionen \code{i => i + 1} appliceras på alla heltal från 1 till och med 10. Funktionen \code{i => i + 1} kallas en \textbf{anonym} funktion, eftersom den inte har något namn, till skillnad från \code{def öka(i: Int): Int = i + 1}, som har namnet \code{öka}.

Anonyma funktioner kallas även för \emph{funktionsliteraler} eller \emph{lambda}.

Det finns ett ännu kortare sätt att skriva en anonym funktion om den bara använder sin parameter en enda gång, med understreck \code{ _ + 1} som expanderas av kompilatorn till \code{ngtnamn => ngtnamn + 1} (namnet på parametern spelar ingen roll; kompilatorn väljer något eget, internt namn).

\Subtask Förklara vad som händer nedan. Vad blir resultatet av varje uttryck?

\begin{REPL}
scala> (1 to 4).map(i => i + 1)
scala> (1 to 4).map(_ + 1)
scala> (1 to 4).map(math.pow(2, _))
scala> (1 to 4).map(math.pow(_, 2))
scala> (1 to 4).map(i => i.toString)
scala> (1 to 4).map(_.toString)
\end{REPL}

\Subtask Vilken typ kommer kompilatorn att härleda för de anonyma funktionerna i argumenten till metoden \code{map} på rad 1--6 i uppgiften ovan? Vad använder kompilatorn för information i dessa exempel för att härleda funktionstyperna?

\Subtask Vilka felmeddelande ger kompilatorn när den inte kan lista ut att funktionsliteralerna nedan har typen \code{Int => Int}?

\begin{REPL}
scala> val inc = i => i + 1
scala> val inc = (i: Int) => i + 1
scala> (1 to 10).map(inc)
scala> val dec = _ - 1
scala> val dec: Int => Int = _ - 1
scala> (1 to 10).map(dec)
\end{REPL}



\SOLUTION


\TaskSolved \what


\SubtaskSolved
\code{Vector(2, 3, 4, 5} Lägger till 1 på varje\\
\code{Vector(2, 3, 4, 5} Identisk med ovan\\
\code{Vector(2.0, 4.0, 8.0, 16.0} Ger 2 upphöjt med talen från vektorn\\
\code{Vector(1.0, 4.0, 9.0, 16.0} Talen upphöjt med 2\\
\code{Vector(1, 2, 3, 4} Skriver ut talen som sträng\\
\code{Vector(1, 2, 3, 4} Identisk med ovan\\

\SubtaskSolved
Int => Int
Int => Int
Int => Double
Int => Double
Int => String
Int => String \\
Den vet vad den behöver utgå ifrån och på samma sätt som man i vanliga fall inte explicit behöver ange returtyp för funktioner i scala så ser den vad för typ som returneras t.ex. \code{i.toString} returnerar en String

\SubtaskSolved
Missing Parameter type och Missing Parameter type for expanded function



\QUESTEND




\ExtraTasks %%%%%%%%%%%%%%%%%%%



\WHAT{Funktion med flera parametrar.}

\QUESTBEGIN

\Task  \what~  Definiera i REPL två funktioner \code{sum} och \code{diff} med två heltalsparametrar som returnerar summan respektive differensen av argumenten: \\
\code{def sum(x: Int, y: Int): Int = x + y} \\
\code{def diff(x: Int, y: Int): Int = x - y} \\
Vad har nedan uttryck för värden? Förklara vad som händer.

\Subtask \code{diff(0, 100)}

\Subtask \code{diff(100, sum(42, 43))}

\Subtask \code{sum(sum(42, 43), diff(100, sum(0, 0)))}

\Subtask \code{sum(diff(Byte.MaxValue, Byte.MinValue),1)}

\SOLUTION

\TaskSolved \what

\SubtaskSolved  \code{-100}

\SubtaskSolved  \code{15}

\SubtaskSolved  \code{185}

\SubtaskSolved  \code{256}

\QUESTEND





\WHAT{Medelvärde.}

\QUESTBEGIN

\Task  \what~ Skriv och testa en funktion \code{avg} som räknar ut medelvärdet mellan två heltal och returnerar en \code{Double}.

\SOLUTION

\TaskSolved \what

\begin{Code}
def avg(x: Int, y: Int): Double = (x + y) / 2.0
\end{Code}


\QUESTEND






\AdvancedTasks %%%%%%%%%%%%%%%%%


\WHAT{Bortkastade resultatvärden och returtypen \code{Unit}.}

\QUESTBEGIN

\Task  \what~ Undersök nedan kod i REPL och förklara vad som händer.

\Subtask
\begin{REPL}
scala> def tom = println("")
scala> println(tom)
\end{REPL}

\Subtask
\begin{REPL}
scala> def bortkastad: Unit = 1 + 1
scala> println(bortkastad)
\end{REPL}

\Subtask
\begin{REPL}
scala> def bortkastad2 = { val x = 1 + 1 }
scala> println(bortkastad2)
\end{REPL}

\Subtask Varför är det bra att explicit ange \code{Unit} som returtyp för procedurer?

\SOLUTION


\TaskSolved \what


\SubtaskSolved Procedurer returnerar tomma värdet och \code{println} är en procedur.

\SubtaskSolved Proceudrer returnerar tomma värdet. Om du anger returtyp \code{Unit} explicit, har du bättre chans att kompilatorn kan ge varning då uträkningar kommer att kastas bort.

\SubtaskSolved I Scala är variabeldeklaratin, precis som en tilldelningssats, och inte ett uttryck och saknar värde.

\SubtaskSolved  Koden blir lättare att läsa och kompilatorn får bättre möjlighet att hjälpa till med varningar om resultatvärden riskerar att bli bortkastade.

\QUESTEND







\WHAT{Tupler som parametrar.}

\QUESTBEGIN

\Task  \what~ Implementera nedan varianter av beräkning av avståndet mellan två punkter:
\begin{Code}
def distxy(x1: Int, y1: Int, x2: Int, y2: Int): Double = ???

def distpt(p1: (Int, Int), p2: (Int, Int)): Double = ???

def distp(p1: (Int, Int))(p2: (Int, Int)): Double = ???

\end{Code}

\SOLUTION

\TaskSolved \what

\begin{Code}
def distxy(x1: Int, y1: Int, x2: Int, y2: Int): Double =
  hypot(x1 - x2, y1 - y2)

def distpt(p1: (Int, Int), p2: (Int, Int)): Double =
  hypot(p1._1 - p2._1, p2._2 - p2._2)

def distp(p1: (Int, Int))(p2: (Int, Int)): Double =
  hypot(p1._1 - p2._1, p2._2 - p2._2)
\end{Code}

\QUESTEND





\WHAT{Rekursion.}

\QUESTBEGIN

\Task  \what~  En rekursiv funktion anropar sig själv.

\Subtask Förklara vad som händer nedan.

\begin{REPL}
scala> def countdown(x: Int): Unit = if (x > 0) {println(x); countdown(x -1)}
scala> countdown(10)
scala> countdown(-1)
scala> def finalCountdown(x: Byte): Unit =
         {println(x); Thread.sleep(100); finalCountdown((x-1).toByte); 1 / x}
scala> finalCountdown(Byte.MaxValue)
\end{REPL}

\Subtask Vad händer om du gör satsen som riskerar division med noll \emph{före} det rekursiva anropet i funktionen \code{finalCountdown} ovan?

\Subtask Förklara vad som händer nedan. Varför tar sista raden längre tid än näst sista raden?
\begin{REPL}
scala> def signum(a: Int): Int = if (a >= 0) 1 else -1
scala> def add(x: Int, y: Int): Int =
         if (y == 0) x else add(x + 1, y - signum(y))
scala> add(100,100)
scala> add(Int.MaxValue, 0)
scala> add(0, Int.MaxValue)
\end{REPL}


\SOLUTION

\TaskSolved \what

\SubtaskSolved
\code{countdown} skriver ut x och kallar på \code{countdown} igen med x-1 som argument om det är större än noll vilket innebär att samma sak görs igen tills x når 0.

\code{finalCountdown} gör samma sak fast med en Byte och den fortsätter även om x passerar 0 med de rekursiva funktionsanropen.

\SubtaskSolved
Eftersom vi hade \code{1/x} efter rekursionsanropet innan så kom vi aldrig dit för vi returnerade aldrig något utan gick bara djupare i stacken. Om vi placerar \code{1/x} tidigare så når vi den raden kod och den kastar ett exception då det är division med noll.

\SubtaskSolved
Den sista raden leder till mycket fler rekursiva anrop, för rekursionen avslutas när y är noll, inte om x är det.

\QUESTEND




\WHAT{Undersök svansrekursion genom att kasta undantag.}

\QUESTBEGIN

\Task  \what~  Förklara vad som händer. Kan du hitta bevis för att kompilatorn kan optimera rekursionen till en vanlig loop?

\begin{REPL}
scala> def explode = throw new Exception("BANG!!!")
scala> explode
scala> lastException.printStackTrace
scala> def countdown(n: Int): Unit =
         if (n == 0) explode else countdown(n-1)
scala> countdown(10)
scala> lastException.printStackTrace
scala> def countdown2(n: Int): Unit =
         if (n == 0) explode else {countdown2(n-1); print("no tailrec")}
scala> countdown2(10)
scala> countdown2(1000)
scala> lastException
scala> lastException.getStackTrace.size
scala> :javap countdown
scala> :javap countdown2
\end{REPL}

\SOLUTION


\QUESTEND



\WHAT{\code{@tailrec}-annotering.}

\QUESTBEGIN

\Task  \what~  Du kan be kompilatorn att ge felmeddelande om den inte kan optimera koden till motsvarande en while-loop. Om den inte kan det hämmas prestanda och det finns risk för en överfull anropssstack \Eng{stack overflow}. Prova nedan rader i REPL och förklara vad som händer.
\begin{REPL}
scala> def countNoTailrec(n: Long): Unit =
         if (n <= 0L) println("Klar! " + n) else {countNoTailrec(n-1L); ()}
scala> countNoTailrec(1000L)
scala> countNoTailrec(100000L)
scala> import scala.annotation.tailrec
scala> @tailrec def countNoTailrec(n: Long): Unit =
         if (n <= 0L) println("Klar! " + n) else {countNoTailrec(n-1L); ()}
scala> @tailrec def countTailrec(n: Long): Unit =
         if (n <= 0L) println("Klar! " + n) else countTailrec(n-1L)
scala> countTailrec(1000L)
scala> countTailrec(100000L)
scala> countTailrec(Int.MaxValue.toLong * 2L)
\end{REPL}\SOLUTION


\QUESTEND
