%!TEX encoding = UTF-8 Unicode
%!TEX root = ../exercises.tex

\ifPreSolution


\Exercise{\ExeWeekFOUR}\label{exe:W04}
\begin{Goals}
\input{modules/w04-objects-exercise-goals.tex}
\end{Goals}

\begin{Preparations}
\item \StudyTheory{04}
\item Läs om hur man fixar buggar i appendix \ref{appendix:debug}.
\end{Preparations}

\else

\ExerciseSolution{\ExeWeekFOUR}

\fi



\BasicTasks %%%%%%%%%%%%%%%%


\WHAT{Para ihop begrepp med beskrivning.}

\QUESTBEGIN

\Task \what

\vspace{1em}\noindent Koppla varje begrepp med den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}
\input{generated/quiz-w04-concepts-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w04-concepts-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND


%%%% Översikt av strukturen i grundövningarna:
%%%% tupler
%%%% objekt
%%%% ladda ner cs-lib och använd classpath till REPL
%%%% cslib.window.SimpleWindow
%%%% java.awt.Color
%%%% paket


\WHAT{Nästlade singelobjekt, import, synlighet och punktnotation.}

\QUESTBEGIN

\Task \what~I den tvådimensionella Underjorden bor Mullvaden och Masken. Masken har gömt sig för Mullvaden och befinner sig på en plats långt bort. Masken har även gjort delar av sin position osynlig för omvärlden:

\begin{Code}
object Underjorden {
  var x = 0
  var y = 1

  object Mullvaden {
    var x = Underjorden.x + 10
    var y = Underjorden.y + 9
  }

  object Masken {
    private var x = Mullvaden.x
    var y = Mullvaden.y + 190
    def ärMullvadsmat: Boolean = ???
  }
}
\end{Code}

\Subtask Skapa ovan kod i filen \code{Underjorden.scala} med en editor och implementera predikatet  \code{ärMullvadsmat} så att det blir sant om mullvadens koordinater är samma som maskens.

\Subtask Testa livet i Underjorden genom att klistra in din modul i REPL. Importera Underjordens medlemmar med understreck så att du ser Mullvaden och Masken. Flytta med hjälp av tilldelning Maskens y-koordinat så att Masken hamnar på samma plats som Mullvaden. Kontrollera att predikatet \code{ärMullvadsmat} fungerar som tänkt.

 \Subtask Importera därefter allt i Mullvaden och sedan allt i Masken och tilldela \code{x} ett nytt värde enligt raderna 1--3 nedan. Vad ger uttrycken på raderna 4--6 nedan för värde? Förklara vad som händer i termer av namnöverskuggning och synlighet?

\begin{REPL}
scala> import Mullvaden._
scala> import Masken._
scala> x = -1
scala> Mullvaden.x
scala> Masken.x
scala> Underjorden.x
\end{REPL}



\SOLUTION

\TaskSolved \what

\SubtaskSolved

\begin{Code}
object Underjorden {
  var x = 0
  var y = 1

  object Mullvaden {
    var x = Underjorden.x + 10
    var y = Underjorden.y + 9
  }

  object Masken {
    private var x = Mullvaden.x
    var y = Mullvaden.y + 190
    def ärMullvadsmat: Boolean = x == Mullvaden.x && y == Mullvaden.y
  }
}
\end{Code}

\SubtaskSolved

\begin{REPL}
scala> :paste underjorden.scala
scala> import Underjorden._
scala> Masken.ärMullvadsmat
res0: Boolean = false
scala> Masken.y = Mullvaden.y
scala> Masken.ärMullvadsmat
res1: Boolean = true
\end{REPL}


\SubtaskSolved

\begin{REPL}
scala> import Mullvaden._
scala> import Masken._
scala> x = -1
scala> Mullvaden.x
res2: Int = -1

scala> Masken.x
<console>:46: error:
  variable x in object Masken cannot be accessed
  in object Underjorden.Masken

scala> Underjorden.x
res3: Int = 0
\end{REPL}

\noindent \emph{Förklaring:} När importen av Maskens alla synliga medlemmar sker kommer de som ej är privata att överskugga andra medlemmar med samma namn. Det är Mullvadens \code{x}-variabel som tilldelas \code{-1} eftersom Maskens \code{x} är privat och ej syns utåt.

\QUESTEND




\WHAT{Tupler.}

\QUESTBEGIN

\Task \what~ Tupler sammanför flera olika värden i ett oföränderligt objekt. Nedan används tupler för att representera en 3D-punkt i underjorden med koordinater av typen \code{(x: Int, y: Int, z: Double)}, där $z$-koordinaten anger hur djupt ner i underjorden punkten ligger. På en hemlig plats finns uppgången till överjorden.

\begin{Code}
object Underjorden3D {
  private val hemlis = ("uppgången till överjorden", (0, 0, 0.0))

  object Mullvaden {
    var pos = (5, 3, math.random * 10)
    def djup  = ???
  }

  object Masken {
    private var pos = (0, 0, 10.0)
    def ärMullvadsmat: Boolean = ???
    def ärRaktUnderUppgången: Boolean = ???
  }
}
\end{Code}

\Subtask Funktionen \code{djup} ska ge $z$-koordinaten för Mullvaden. Vilken typ har \code{djup}?

\Subtask Vilken typ har \code{hemlis}?

\Subtask Skriv in koden för \code{Underjorden3D} i en editor och implementera de saknade delarna. Predikatet \code{ärMullvadsmat} ska vara sant om Masken finns på samma plats som Mullvaden. Predikatet  \code{ärRaktUnderUppgången} ska vara sant om $x$- och $y$-koordinaterna sammanfaller med den hemliga uppgången till överjorden. Testa så att dina implementationer fungerar i REPL.

\SOLUTION

\TaskSolved \what~

\SubtaskSolved \code{djup} har typen \code{Double}.

\SubtaskSolved \code{hemlis} har typen \code{(String, (Int, Int, Double))}.


\SubtaskSolved
\begin{Code}
object Underjorden3D {
  private val hemlis = ("uppgången till överjorden", (3, 4, 0.0))

  object Mullvaden {
    var pos = (5, 3, math.random * 10 + 1)

    def djup: Double  = pos._3
  }

  object Masken {
    private var pos = (0, 0, 10.0)

    def ärMullvadsmat: Boolean = pos == Mullvaden.pos

    def ärRaktUnderUppgången: Boolean =
      pos._1 == hemlis._2._1 && pos._2 == hemlis._2._2
  }
}
\end{Code}




\WHAT{Färdigkompilerad kod i jarfil. Classpath. Använda paket.}

\QUESTBEGIN

\Task \what~En jar-fil används för att samla färdigkompilerade program, kod, dokumentation, resursfiler, etc, i en enda fil. En jar-fil är komprimerad på samma sätt som en zip-fil.

\Subtask På veckans laboration ska vi använda klassen \code{SimpleWindow} som finns i paketet \code{windows} som ligger i paketet \code{cslib}. Vilka argument ska ges när man skapar ett fönster?

\emph{Tips:}  Läs dokumentationen av \code{SimpleWindow} här:  \url{http://cs.lth.se/pgk/api/}
 Leta efter beskrivningen av klassens konstruktor.

\Subtask Ladda ner \texttt{cslib.jar} via länken \url{http://cs.lth.se/pgk/cslib} och lägg jar-filen i samma katalog som ditt Scala-program. Detta kan du göra i Linux med \code{wget} så här:

\begin{REPLnonum}
> wget -O cslib.jar http://cs.lth.se/pgk/cslib
\end{REPLnonum}

\Subtask Testa \code{SimpleWindow} i REPL enligt nedan. Med argumentet \code{-cp cslib.jar}, där optionen \code{cp} är en förkortning av \emph{classpath}, gör du koden i \code{cslib.jar} synlig i REPL.  Skriv kod som ritar en kvadrat med sidan $100$:

\begin{REPL}
> scala -cp cslib.jar
Welcome to Scala 2.12.3 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_144).
Type in expressions for evaluation. Or try :help.

scala> val w = new cslib.window.SimpleWindow(400,300,"HEJ")
scala> w.moveTo(100, 100)
scala> w.lineTo(200, 100)
scala> // rita en kvadrat
\end{REPL}

\Subtask Skriv nedan program med en editor i filen \code{hello-simplewindow.scala} och fyll i de saknade delarna så att en kvadrat ritas ut.

\begin{Code}
package hello

object Main {
  val w = new cslib.window.SimpleWindow(400,300,"HEJ")

  def square(topLeft: (Int, Int))(side: Int): Unit = {
    w.moveTo( topLeft._1,        topLeft._2        )
    w.lineTo( topLeft._1 + side, topLeft._2        )
    w.lineTo( topLeft._1 + side, topLeft._2 + side )
    ???
  }

  def main(args: Array[String]): Unit = {
    println("Rita kvadrat:")
    square(300,100)(50)
  }
}
\end{Code}

\noindent
När du kompilerar ditt program, behöver du lägga \code{cslib.jar} till classpath.
När du sedan ska köra ditt program behöver du förutom  \code{cslib.jar} också lägga aktuell katalog till classpath. Om man vill ha flera saker på classpath behövs en lista med sökvägar inom citationstecken och ett kolon som separator\footnote{Kolon används i Linux och macOS, medan Windows använder semikolon.}, till exempel \code{"sökväg1:sökväg2:sökväg3"}.
Aktuell katalog (där katalogen \code{hello} med dina kompilerade byte-kodfiler finns) anges med en punkt.

Använd följande kommando (om Windows använd semikolon i stället för kolon):
\begin{REPL}
> atom hello-simplewindow.scala  // skriv koden ovan
> scalac -cp cslib.jar hello-simplewindow.scala
> ls hello
> scala -cp "cslib.jar:." hello.Main
\end{REPL}
\noindent Du ska nu få upp ett fönster med en liten kvadrat till höger i fönstret.


\SOLUTION

\TaskSolved \what~\TODO

\QUESTEND






\WHAT{Färg.}

\QUESTBEGIN

\Task \what~ Det finns många sätt att beskriva färger.
I naturligt språk har vi olika namn på färgerna, till exempel \emph{vitt}, \emph{rosa} och \emph{magenta}.
I bildminnen i datorer är det vanligt att beskriva färger som en blandning av \emph{rött}, \emph{grönt} och \emph{blått} i det så kallade RGB-systemet.

På veckans labb ska vi använda \code{SimpleWindow}, som beskriver RGB-färger med klassen \code{java.awt.Color}.
Det finns några fördefinierade färger i \code{java.awt.Color}, till exempel \code{java.awt.Color.black} för svart och \code{java.awt.Color.green} för grönt.
Andra färger kan skapas genom att ange mängden rött, grönt och blått.

På laborationen behöver vi dessa tre brunaktiga färger:
\begin{Code}
  val mole   = new java.awt.Color( 51,  51,   0)
  val soil   = new java.awt.Color(153, 102,  51)
  val tunnel = new java.awt.Color(204, 153, 102)
\end{Code}

Den tre parametrarna till \code{new java.awt.Color(r, g, b)} anger hur mycket \emph{rött}, \emph{grönt} respektive \emph{blått} som färgen ska innehålla, och mängderna ska vara i intervallet 0--255.
Färgen $(153, 102, 51)$ innebär ganska mycket rött, lite mindre grönt och ännu mindre blått och det upplevs som brunt.

\noindent\begin{minipage}{0.82\textwidth}
Använd koden nedan för att rita tre kvadrater i REPL. Proceduren \code{rak} ska rita en horisontell linje från punkten \code{p} med längden \code{d}. Proceduren \code{fyll} ska rita en fylld kvadrat med övre vänstra hörnet i punkten \code{p} och sidan \code{s}. Det som ritas ut ska se ut som bilden till höger.
\end{minipage}
\hfill\begin{minipage}{0.23\textwidth}
\includegraphics[width=\textwidth]{../img/fyll-rak.png}
\end{minipage}

\begin{REPL}
> scala -cp cslib.jar
scala> val w = new cslib.window.SimpleWindow(400,300,"Tre nyanser av brunt")
scala> type Pt = (Int, Int)
scala> def rak(p:Pt)(d:Int) = {w.moveTo(p._1, p._2);w.lineTo(???)}
scala> def fyll(p:Pt)(s:Int) = for (i <- 0 to s){rak(???)(s)}

scala> :paste
val mole   = new java.awt.Color( 51,  51,   0)
val soil   = new java.awt.Color(153, 102,  51)
val tunnel = new java.awt.Color(204, 153, 102)

scala> w.setLineColor(soil)
scala> fyll(100,100)(75)

scala> w.setLineColor(tunnel)
scala> fyll(100,100)(50)

scala> w.setLineColor(mole)
scala> fyll(150,150)(25)
\end{REPL}
\noindent Vid anropen av \code{rak} och \code{fyll} ovan utnyttjas att man kan skippa tupelparenteserna om ett tupelargument är ensamt i sin parameterlista.


\SOLUTION

\TaskSolved \what~
\begin{Code}
def rak(p: Pt)(d: Int)  = { w.moveTo(p._1, p._2); w.lineTo(p._1 + d, p._2) }
def fyll(p: Pt)(s: Int) = for (i <- 0 to s){ rak(p._1, p._2 + i)(s) }
\end{Code}

\QUESTEND
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\ExtraTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\WHAT{Använda färdiga paket. Skapa en färgväljare.}

\QUESTBEGIN

\Task \what~På laborationen har du nytta av att kunna blanda egna färger så att du kan rita himmel och gräs. Du kan använda färgväljaren i Kojo eller skapa en färgväljare själv med hjälp av swing-paketet enligt nedan. Vad händer om du efter nedan skriver \code{f.setVisible(false)}?

\begin{REPL}
scala> val f = new javax.swing.JFrame
scala> val c = new javax.swing.JColorChooser
scala> f.add(c)
scala> f.setVisible(true)    // välj färg i RGB-fliken
scala> c.getColor
scala> c.getColor.getAlpha   // alpha styr genomskinlighet
\end{REPL}


\SOLUTION

\TaskSolved \what~\\När du skriver \code{f.setVisible(false)} så stängs färgfäljarfönstret.

\QUESTEND




\AdvancedTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\WHAT{Undersök JDK.}

\QUESTBEGIN

\Task \what~ Ta med hjälp av \url{http://stackoverflow.com/} reda på hur många klasser och paket det finns i Java-plattformen JDK8.

\SOLUTION

\TaskSolved \what~Med JDK8-plattformen kommer 4240 färdiga klasser, som är organiserade i 217 olika paket. Se Stackoverflow: \\\url{http://stackoverflow.com/questions/3112882}

\QUESTEND



\WHAT{Tupler som funktionsresultat.}

\QUESTBEGIN

\Task \what~Tupler möjliggör att en funktion kan returnera flera olika värden på samma gång. Implementera funktionen statistics nedan. Den ska returnera en 3-tupel som innehåller antalet element i \code{xs}, medelvärdet av elementen, samt en 2-tupel med variationsvidden $(min, max)$. Ange returtypen explicit i din implementation. Testa så att den fungerar i REPL. \emph{Tips:} Du har nytta av metoderna \code{size}, \code{sum}, \code{min} och \code{max} som fungerar på nummersekvenser.

\begin{Code}
/** Returns the size, the mean, and the range of xs */
def statistics(xs: Vector[Double]) = ???
\end{Code}

\SOLUTION

\TaskSolved \what~

\begin{Code}
def statistics(xs: Vector[Double]): (Int, Double, (Double, Double)) =
  (xs.size, xs.sum / xs.size, (xs.min, xs.max))
\end{Code}

\begin{REPL}
scala> statistics(Vector(0, 2.5, 5))
res10: (Int, Double, (Double, Double)) = (3,2.5,(0.0,5.0))
\end{REPL}

\QUESTEND





\WHAT{Skapa din egen \code{jar}-fil. \TODO}

\QUESTBEGIN

\Task  \what~

\Subtask Skriv kommandot \code{jar} i terminalen och undersök vad som finns för optioner. Se speciellt ''Example 1.'' i hjälputskriften. Vilket kommando ska du använda för att packa ihop flera filer i en enda jar-fil?

\Subtask Packa ihop biblioteket \TODO \code{gurka} i en jar-fil med nedan kommando, samt kör igång REPL med jar-filen på classpath.

\begin{REPL}
> jar cvf mittpaket.jar gurka
> scala -cp mittpaket.jar
scala> gurka.tomat.banan.Main.main(Array())
\end{REPL}


\SOLUTION


\TaskSolved \what\TODO


\SubtaskSolved  jar cvf [namn på skapad fil] [namn på input-filer]

\SubtaskSolved  -


\QUESTEND






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\TODO Fixa detta som är hitflyttat från labben}




\WHAT{Objekt som moduler.}

\QUESTBEGIN

\Task  \what~ Deklarera modulerna \code{stringstat} och \code{Test} nedan i REPL eller i Kojo.

\begin{Code}
object stringstat {
  object stringfun {
    def sentences(s: String): Array[String] = s.split('.')
    def words(s: String): Array[String] = s.split(' ')
    def countWords(s: String): Int = words(s).size
    def countSentences(s: String): Int = sentences(s).size
  }

  object statistics {
    var history = ""
    def printFreq(s: String): Unit = {
      println("\n---- Frekvenser ----")
      println("Antal tecken:   " + s.size)
      println("Antal ord:      " + stringfun.countWords(s))
      println("Antal meningar: " + stringfun.countSentences(s))
      history = history + " " + s
    }
    def printTotal: Unit = printFreq(history)
  }
}

object Test {
  import stringstat._
  def apply(n: Int = 42): Unit = {
    val s1 = "Fem myror är fler än fyra elefanter. Ät gurka."
    val s2 = "Galaxer i mina braxer. Tomat är gott. Hejsan."
    statistics.printFreq(s1 * n)
    statistics.printFreq(s2 * n)
    statistics.printTotal
  }
}
\end{Code}

\Subtask Anropa \code{Test()} och förklara vad som händer. Vad skrivs ut?

\Subtask Vilket av objekten i modulen \code{stringstat} har tillstånd och vilket av objekten är tillståndslöst? Vad består tillståndet av?


\SOLUTION


\TaskSolved \what


\SubtaskSolved
\begin{REPLnonum}

---- Frekvenser ----
Antal tecken: 1932
Antal ord: 337
Antal meningar: 84

---- Frekvenser ----
Antal tecken: 1890
Antal ord: 295
Antal meningar: 126

---- Frekvenser ----
Antal tecken: 3824
Antal ord: 633
Antal meningar: 210

\end{REPLnonum}

Först och främst, vi har default argument 42 så det är det som används vid anropet. Detta används för att multiplicera \code{s1} och \code{s2} i \code{Test} när man anropar \code{printFreq}. \code{statistics} objektet använder i sin tur funktionerna i \code{stringfun} för att räkna ord och meningar. Resultatet presenteras av \code{statistics}, vilket är det vi ser.

\SubtaskSolved  Vi ser att \code{stringfun} enbart innehåller funktioner och därmed inte har något tillstånd. \code{statistics} har däremot ett tillstånd eftersom variabeln \code{history} sparar vad som skett, så när man anropar funktioner i objektet så kan objektet ändra beteende beroende på dess tillstånd, tillståndet består alltså av \code{history}.


\QUESTEND





\WHAT{Paket, \code{import} och klassfilstrukturer.}

\QUESTBEGIN

\Task \what~

\Subtask Kör raderna nedan i REPL. Beskriv vad som händer för varje rad.
\begin{REPL}[numbers=left, numberstyle=\color{black}\ttfamily\scriptsize\selectfont]
scala> import javax.swing.JOptionPane
scala> def msg(s: String) = JOptionPane.showMessageDialog(null, s)
scala> msg("Hej på dej!")
scala> def input(msg: String) = JOptionPane.showInputDialog(null, msg)
scala> input("Vad heter du?")
scala> import JOptionPane.{showOptionDialog => optDlg}
scala> def inputOption(msg: String, opt: Array[Object]) =
         optDlg(null, msg, "Option", 0, 0, null, opt, opt(0))
scala> inputOption("Vad väljer du?", Array("Sten", "Sax", "Påse"))
\end{REPL}

\Subtask\Pen Vad hade du behövt ändra på efterföljande rader om import-satsen på rad 1 ovan ej hade gjorts?

\Subtask Skapa med en editor filen paket.scala och kompilera. Rita en bild av hur katalogstrukturen ser ut.

\begin{Code}
package gurka.tomat.banan

package p1 {
  package p11 {
    object hello {
      def hello = println("Hej paket p1.p11!")
    }
  }
  package p12 {
    object hello {
      def hello = println("Hej paket p1.p12!")
    }
  }
}

package p2 {
  package p21 {
    object hello {
      def hello = println("Hej paket p2.p21!")
    }
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    import p1._
    p11.hello.hello
    p12.hello.hello
    import p2.{p21 => apelsin}
    apelsin.hello.hello
  }
}
\end{Code}

\begin{REPL}
> gedit paket.scala
> scalac paket.scala
> scala gurka.tomat.banan.Main
> ls -R
\end{REPL}

\SOLUTION


\TaskSolved \what


\SubtaskSolved  \code{script   security   smartcardio   sound   sql   swing}

\SubtaskSolved  Radernas funktion i ordning:

1. Importerar JOptionPane från javax.swing

2. Definierar en metod som tar en sträng och öppnar en dialogruta med strängen.

3. Testar funktionen med argumentet "Hej på dej!". En dialogruta öppnas med texten "Hej på dej!".

4. Definierar en metod som tar emot en sträng som argument och öppnar en input-dialogruta med strängen.

5. Testar funktionen med argumentet "Vad heter du?". En dialogruta öppnas med texten "Vad heter du?". I ett fält kan man fylla i sitt namn. Funktionen returnerar namnet.

6. Importerar showOptionDialog från JOptionPane under namnet optDlg.

7. Definierar en metod som tar emot en sträng och en Array som argument och öppnar en flervalsdialog. Strängen ska innehålla frågan som flervalsdialogen visar upp. Arrayn ska innehålla alternativen som användaren ska välja mellan.

8.Testar funktionen med argumenten \code{"Vad väljer du?"} och \\ \code{Array("Sten, "Sax", "Påse")}. En dialogruta kommer upp och man får möjlighet att välja sten sax eller påse. Funktionen returnerar valet som man gör.

\SubtaskSolved  På alla ställen där \code{JOptionPane} förekommer, hade man istället fått skriva \code{javax.swing.JOptionPane}.

\SubtaskSolved  -



\QUESTEND










\WHAT{Tupler som parametrar.}

\QUESTBEGIN

\Task  \what~ Implementera nedan varianter av beräkning av avståndet mellan två punkter:
\begin{Code}
def distxy(x1: Int, y1: Int, x2: Int, y2: Int): Double = ???

def distpt(p1: (Int, Int), p2: (Int, Int)): Double = ???

def distp(p1: (Int, Int))(p2: (Int, Int)): Double = ???

\end{Code}

\SOLUTION

\TaskSolved \what

\begin{Code}
def distxy(x1: Int, y1: Int, x2: Int, y2: Int): Double =
  hypot(x1 - x2, y1 - y2)

def distpt(p1: (Int, Int), p2: (Int, Int)): Double =
  hypot(p1._1 - p2._1, p2._2 - p2._2)

def distp(p1: (Int, Int))(p2: (Int, Int)): Double =
  hypot(p1._1 - p2._1, p2._2 - p2._2)
\end{Code}

\QUESTEND




\WHAT{Värdeanrop och namnanrop (fördröjd evaluering, ''lata'' argument).}

\QUESTBEGIN

\Task  \what~  Deklarera nedan funktioner i REPL.

\begin{Code}
def snark: Int = { print("snark "); Thread.sleep(1000); 42 }

def callByValue(x: Int) = x + x

def callByName(x: => Int) = x + x
\end{Code}

Evaluera nedan uttryck. Förklara vad som händer.

\Subtask \code{snark}

\Subtask \code{snark; snark; snark}

\Subtask \code{callByValue(1)}

\Subtask \code{callByName(1)}

\Subtask \code{callByValue(snark)}

\Subtask \code{callByName(snark)}


\Subtask Förklara vad som händer här:
\begin{REPL}
scala> def görDetta(block: => Unit) = block
scala> görDetta(println("hej"))
scala> görDetta{println("goddag")}
scala> görDetta{println("hej"); println("svejs")}
scala> def görDettaTvåGånger(block: => Unit) = {block; block}
scala> görDettaTvåGånger{println("goddag")}
\end{REPL}


\SOLUTION


\TaskSolved \what


\SubtaskSolved  \code{snark 42}

\SubtaskSolved  \code{snark snark snark 42}

Den evaluerar inte uttrycket förrän det behövs, så flera snark ger bara ett resultat för det är bara det som begärs.

\SubtaskSolved  \code{2}

\SubtaskSolved  \code{2}

Det är ingen större skillnad när vi bara skickar in en etta.

\SubtaskSolved  \code{snark, Int = 84}

\SubtaskSolved  När vi kallar på \code{callByValue} så skickar vi in snark som ett värde, och därmed behöver x bara beräknas en gång medans när vi kallar på \code{callByName} så skickar vi den som en funktion och därmed kallas snark på två gånger i funktionen för att beräkna x båda gångerna.

\code{snark snark, Int = 84}

\SubtaskSolved  \code{görDetta} är en kontrollstruktur som helt enkelt exekverar koden den matas med, \code{görDettaTvåGånger} gör just vad den säger. Detta är dock grunderna för vad som kan bli mycket mer avancerat om man kombinerar detta med loopar eller if-satser, som i sig är kontrollstrukturer.

\QUESTEND




\WHAT{Skapa din egen kontrollstruktur.}

\QUESTBEGIN

\Task  \what~

\Subtask Använd fördröjd evaluering i kombination med en uppdelad parameterlista och skapa din egen kontrollstruktur enligt nedan. (Det är så här som loopen \code{upprepa} i Kojo är definierad.)
\begin{REPL}
scala> def upprepa(n: Int)(block: => Unit): Unit = {
         var i = 0
         while (i < n) {block; i += 1}
       }
\end{REPL}

\Subtask Använd din nya loop-procedur och förklara vad som händer nedan.
\begin{REPL}
scala> upprepa(10)(println("hej"))
scala> upprepa(1000){
  val tärning = (math.random * 6 + 1).toInt
  print(tärning + " ")
}
\end{REPL}

\SOLUTION

\TaskSolved \what

\SubtaskSolved  -

\SubtaskSolved  I den första parameterlistan så anges hur många gånger koden i den andra parameterlistan ska exekveras. så \code{upprepa(10)(println("hej"))} printar hej 10 gånger

\QUESTEND






\WHAT{Fördröjd initialisering (''lata'' variabler).}

\QUESTBEGIN

\Task  \what~

\Subtask \label{subtask:delayalloc} Förklara vad som händer här:
\begin{REPL}
scala> val olat = 42
scala> lazy val lat = 42
scala> println(lat)
scala> val nu = {Thread.sleep(1000); println("nu"); 42}
scala> lazy val sen = {Thread.sleep(1000); println("sen"); 42}
scala> def igen = {Thread.sleep(1000); println("hver gang"); 42}
scala> println(nu)
scala> println(sen)
scala> println(igen)
scala> println(nu)
scala> println(sen)
scala> println(igen)
scala> object m {lazy val stor = Array.fill(1e9.toInt)(liten); val liten = 42}
scala> m.liten
scala> m.stor
\end{REPL}

\Subtask Vad är skillnaden mellan \code{val}, \code{lazy val} och \code{def}, vad gäller \emph{när} evalueringen sker?


\Subtask \label{subtask:forwardref} Förklara vad som händer här:
\begin{REPL}
scala> object objektÄrLata { val sen = { println("nu!"); 42 } }
scala> objektÄrLata
scala> objektÄrLata.sen
scala> {val x = y; val y = 42}
scala> object buggig {val a = b; val b = 42}
scala> buggig.a
scala> object funkar {lazy val a = b; val b = 42}
scala> funkar.a
scala> object nowarning {val many = Array.fill(10)(one); val one = 1}
scala> nowarning.many
\end{REPL}

\Subtask Med ledning av uppgift \ref{subtask:delayalloc} och uppgift \ref{subtask:forwardref}, beskriv två olika situationer när kan man ha nytta av \code{lazy val}?


\SOLUTION


\TaskSolved \what


\SubtaskSolved  Notera vid deklarationen av \code{nu}, \code{sen} och \code{igen} så är det bara \code{nu} som tar tid och skriver ut sin text. För \code{nu} evalueras men de andra väntar.

Men när vi ska kalla på dem så tar \code{nu} ingen tid och skriver inte ut nu medans \code{sen} och \code{igen} nu tar tid och skriver ut sin text. För \code{nu} har redan evaluerats men de andra behöver evalueras för de kallas på.

Och när vi kallar på dem för andra gången så är det bara \code{igen} som tar tid. För \code{nu} och \code{sen} är evaluerade och vid det här laget identiska medans \code{igen} behöver evalueras varje gång man kallar på den.

Vid deklaration av objektet så går allt bra, när vi kallar på \code{liten} så får vi 42 men när vi kallar på \code{stor} så får vi exception. Eftersom objekt är lata så evalueras inte objektet förrän vi anropar något ur det men \code{stor} är också lazy så den blir inte ett problem förrän just den anropas.

\SubtaskSolved
\code{val} evalueras direkt, \code{lazy val} evalueras när det behövs medans \code{def} evalueras varje gång det behövs.

\SubtaskSolved
När vi skapar objektÄrLata så skrivs inget ut för det evalueras inte förrän vi kallar på det, som vi gör nästa rad då skrivs nu ut. När vi sedan anropar sen evalueras inget och nu skrivs inte ut.

\{\code{val x=y; val y = 42}\} kastar error eftersom y inte är evaluerad när vi försöker evaluera x.

När vi skapar \code{buggig} så varnar den och vi ser varför på nästa rad då att \code{a} verkar vara lika med 0. Eftersom \code{b} inte är evaluerad än så blir det 0 men till skillnad från tidigare vet \code{val a} iallafall att den är en Int eftersom objectet med \code{b} är åtminstone definerat.

\code{funkar} fungerar just för att \code{a} är en \code{lazy val} och evalueras då inte förrän efter \code{b} evaluerats och ger därför 42 som den ska.

\code{nowarning} har samma problem som \code{buggig} men ger ingen varning och därför försöker skriva ut innan \code{one} är evaluerad och ger därför nollor.

\SubtaskSolved
När man vill skapa ett objekt som funkar eller fixa problemet i no warning, man kan vilja ha sina variabler i just den ordningen p.g.a. läslighet.

Men även om man inte vill slöa ner ett system med en massa arbete när allt deklareras på en gång utan tar det hellre gradvis allteftersom det används.

\QUESTEND
