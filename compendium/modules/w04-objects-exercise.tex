%!TEX encoding = UTF-8 Unicode
%!TEX root = ../exercises.tex

\ifPreSolution


\Exercise{\ExeWeekFOUR}\label{exe:W04}
\begin{Goals}
\input{modules/w04-objects-exercise-goals.tex}
\end{Goals}

\begin{Preparations}
\item \StudyTheory{04}
\item Läs om hur man fixar buggar i appendix \ref{appendix:debug}.
\end{Preparations}

\else

\ExerciseSolution{\ExeWeekFOUR}

\fi



\BasicTasks %%%%%%%%%%%%%%%%


\WHAT{Para ihop begrepp med beskrivning.}

\QUESTBEGIN

\Task \what

\vspace{1em}\noindent Koppla varje begrepp med den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}
\input{generated/quiz-w04-concepts-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w04-concepts-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND


%%%% TODO översikt:
%%%% tupler
%%%% objekt
%%%% paket
%%%% ladda ner cs-lib och använd classpath till REPL
%%%% cslib.window.SimpleWindow
%%%% java.awt.Color





\WHAT{.}

\QUESTBEGIN

\Task \what~\TODO

\SOLUTION

\TaskSolved \what~\TODO

\QUESTEND






\WHAT{\TODO Fixa detta som är hitflyttat från labben}

\QUESTBEGIN

\Task \what~\TODO


\Subtask
Ladda ner \texttt{cslib.jar} via länken \url{http://cs.lth.se/pgk/cslib} och lägg jar-filen i samma katalog som ditt Scala-program. Detta kan du göra i Linux med \code{wget} så här:
\begin{REPLnonum}
> wget -O cslib.jar http://cs.lth.se/pgk/cslib
\end{REPLnonum}
En jar-fil används för att paketera färdigkompilerade program, kod, dokumentation, resursfiler, etc, och är komprimerad på samma sätt som en zip-fil.

\Subtask
Byt ut \code{main}-funktionens kropp mot följande block:
\begin{Code}
{
	val w = new cslib.window.SimpleWindow(300, 500, "Digging")
	w.moveTo(10, 10)
	w.lineTo(10, 20)
	w.lineTo(20, 20)
	w.lineTo(20, 10)
	w.lineTo(10, 10)
}
\end{Code}
Den första raden skapar ett nytt \code{SimpleWindow} som ritar upp ett fönster som är 300 bildpunkter brett och 500 bildpunkter högt med titeln \emph{Digging}.
\code{SimpleWindow} har en \emph{penna} som kan flyttas runt och rita linjer.
Anropet \code{w.moveTo(10, 10)} flyttar pennan för fönstret \code{w} till position $(10,10)$ utan att rita något, och anropet \code{w.lineTo(10, 20)} ritar en linje därifrån till position $(10, 20)$.

\Subtask
Nu ska du kompilera ditt program, men eftersom \code{SimpleWindow} inte finns i Scalas standardbibliotek utan i \texttt{cslib.jar} behöver du visa kompilatorn var den ska leta.
Det gör du genom att ange en \emph{classpath}, dvs. en sökväg till \texttt{class}-filer, när du kompilerar.
Använd flaggan \texttt{-cp cslib.jar} för att ange \texttt{cslib.jar} som classpath och kompilera ditt Scala-program igen:
\begin{REPLnonum}
> scalac -cp cslib.jar Mole.scala
\end{REPLnonum}

\Subtask
Nu ska du köra ditt program, och då behöver du också ange var \texttt{class}-filerna ligger.
Du ska ange den katalog där \texttt{class}-filerna för \code{Mole} ligger, som du just kompilerat, men du ska också ange \texttt{cslib.jar}, och det gör du med en kolon-separerad lista\footnote{Kolon används i Linux och macOS, medan Windows använder semikolon.}, till exempel \code{"sökväg1:sökväg2:sökväg3"}.
Katalogen du står i, där dina \texttt{class}-filer ligger, kan anges med en punkt (\texttt{.}).
Kör programmet med följande kommando (om Windows använd semikolon):
\begin{REPLnonum}
> scala -cp ".:cslib.jar" Mole
\end{REPLnonum}
Du ska nu få upp ett fönster med en liten kvadrat utritad i övre vänstra hörnet.


\SOLUTION

\TaskSolved \what~\TODO

\QUESTEND





\WHAT{\TODO FIXA ÖVNING MED FÄRG. Nedan borttaget ur labben.}

\QUESTBEGIN


\Task \what~

Det finns många sätt att beskriva färger.
I naturligt språk har vi olika namn på färgerna, till exempel \emph{vitt}, \emph{rosa} och \emph{magenta}.
I datorn är det vanligt att beskriva färgerna som en blandning av \emph{rött}, \emph{grönt} och \emph{blått} i det så kallade RGB-systemet.
\code{SimpleWindow} använder typen \code{java.awt.Color} för att beskriva färger och \code{java.awt.Color} bygger på RGB.
Det finns några fördefinierade färger i \code{java.awt.Color}, till exempel \code{java.awt.Color.black} för svart och \code{java.awt.Color.green} för grönt.
Andra färger kan skapas genom att ange mängden rött, grönt och blått.

\Subtask
Skapa ett nytt objekt i \texttt{Mole.scala} med namnet \code{Colors} och lägg in följande definitioner:
\begin{Code}
val mole   = new java.awt.Color(51, 51, 0)
val soil   = new java.awt.Color(153, 102, 51)
val tunnel = new java.awt.Color(204, 153, 102)
\end{Code}
% val sky = new java.awt.Color(51, 51, 204)
% val grass = new java.awt.Color(51, 204, 51)
Den tre parametrarna till \code{new java.awt.Color(r, g, b)} anger hur mycket \emph{rött}, \emph{grönt} respektive \emph{blått} som färgen ska innehålla, och mängderna ska vara i intervallet 0--255.
Färgen $(153, 102, 51)$ innebär ganska mycket rött, lite mindre grönt och ännu mindre blått och det upplevs som brunt.
Objektet \code{Colors} är en färgpallett, men vi har inte ritat något med färg ännu.
Kompilera och kör ditt program ändå, för att se så programmet fungerar likadant som sist.

\Subtask
Lägg till en parameter till \code{Graphics.block} sist i parameterlistan med namnet \code{color} och typen \code{java.awt.Color}.
Låt \emph{default-argumentet} för den nya parametern vara \code{java.awt.Color.black}.
(Kommer du inte ihåg hur man gör default-argument kan du titta på övningarna i kapitel~\ref{exe:W03}.)
För att ändra färgen på blocket kan du byta linjefärg innan du ritar.
Lägg till följande rad i början på \code{Graphics.block}:
\begin{Code}
w.setLineColor(color)
\end{Code}
Kompilera och kör ditt program igen för att se om det fortfarande fungerar.

\Subtask\Pen
Funktionen \code{Graphics.block} har tre parametrar, men den anropas bara med två parametrar i \code{Mole.main}.
Varför är det tillåtet?
Vilket värde har den tredje parametern om ingen anges?
Skriv ner dina svar inför redovisningen.


\Subtask
Ändra i \code{Mole.main} och lägg till en av definitionerna från objektet \code{Colors} som tredje parameter till \code{Graphics.block}.
Kompilera och kör ditt program och upplev världen i färg.


\QUESTEND
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







\WHAT{Objekt som moduler.}

\QUESTBEGIN

\Task  \what~

\Subtask Lär dig följande terminologi utantill:

\begin{itemize}[noitemsep, nolistsep]
\item Ett singelobjekt som samlar funktioner och variabler kallas även en \textbf{modul}.
\item Funktioner i objekt kallas även \textbf{metoder}.
\item Variabler och metoder i objekt kallas \textbf{medlemmar}.
%\item Moduler kan i sin tur innehålla moduler, i godtyckligt \textbf{nästlingsdjup}.
\item Man kommer åt innehållet i en modul med \textbf{punktnotation}.
\item Med \textbf{import} slipper man punktnotation.
\item Ett objekt med variabler sägs ha ett \textbf{tillstånd}.
\end{itemize}

\Subtask Deklarera modulerna \code{stringstat} och \code{Test} nedan i REPL eller i Kojo.

\begin{Code}
object stringstat {
  object stringfun {
    def sentences(s: String): Array[String] = s.split('.')
    def words(s: String): Array[String] = s.split(' ')
    def countWords(s: String): Int = words(s).size
    def countSentences(s: String): Int = sentences(s).size
  }

  object statistics {
    var history = ""
    def printFreq(s: String): Unit = {
      println("\n---- Frekvenser ----")
      println("Antal tecken:   " + s.size)
      println("Antal ord:      " + stringfun.countWords(s))
      println("Antal meningar: " + stringfun.countSentences(s))
      history = history + " " + s
    }
    def printTotal: Unit = printFreq(history)
  }
}

object Test {
  import stringstat._
  def apply(n: Int = 42): Unit = {
    val s1 = "Fem myror är fler än fyra elefanter. Ät gurka."
    val s2 = "Galaxer i mina braxer. Tomat är gott. Hejsan."
    statistics.printFreq(s1 * n)
    statistics.printFreq(s2 * n)
    statistics.printTotal
  }
}
\end{Code}

\Subtask Anropa \code{Test()} och förklara vad som händer. Vad skrivs ut?

\Subtask Vilket av objekten i modulen \code{stringstat} har tillstånd och vilket av objekten är tillståndslöst? Vad består tillståndet av?


\SOLUTION


\TaskSolved \what


\SubtaskSolved  -

\SubtaskSolved  -

\SubtaskSolved
\begin{REPLnonum}

---- Frekvenser ----
Antal tecken: 1932
Antal ord: 337
Antal meningar: 84

---- Frekvenser ----
Antal tecken: 1890
Antal ord: 295
Antal meningar: 126

---- Frekvenser ----
Antal tecken: 3824
Antal ord: 633
Antal meningar: 210

\end{REPLnonum}

Först och främst, vi har default argument 42 så det är det som används vid anropet. Detta används för att multiplicera \code{s1} och \code{s2} i \code{Test} när man anropar \code{printFreq}. \code{statistics} objektet använder i sin tur funktionerna i \code{stringfun} för att räkna ord och meningar. Resultatet presenteras av \code{statistics}, vilket är det vi ser.

\SubtaskSolved  Vi ser att \code{stringfun} enbart innehåller funktioner och därmed inte har något tillstånd. \code{statistics} har däremot ett tillstånd eftersom variabeln \code{history} sparar vad som skett, så när man anropar funktioner i objektet så kan objektet ändra beteende beroende på dess tillstånd, tillståndet består alltså av \code{history}.



\QUESTEND





%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 13




\WHAT{Block, namnsynlighet, namnöverskuggning}

\QUESTBEGIN

\Task  \what~ . Kör nedan kod i Scala REPL eller i Kojo. Vad händer nedan? Varför?

\Subtask \code|val a = {1 + 1; 2 + 2; 3 + 3; 4 + 4}; println(a)|

\Subtask \code|val b = {1; 2; 3; {val b = 4; b + b; b + 1}}; println(b)|

\Subtask \code|{val a = 42; println(a)}|

\Subtask \code|{val a = 42}; println(a)|

\Subtask \code|{val a = 42; {val a = 43; println(a)}; println(a)}|

\Subtask \code|{var a = 42; {a = a + 1}; var a = 43}|

\Subtask \code|{var a = 42; {a = a + b; var b = 43}; println(a)}|

\Subtask \code|{var a = 42; {var b = 43; a = a + b}; println(a)}|

\Subtask \code|{var a = 42; {a = a + b; def b = 43}; println(a)}|

\Subtask \code|{object a{var b=42;object a{var a=43}};println(a.b+a.a.a)}|

\Subtask

\begin{Code}
{
  object a {
    var b = 42
    object a {
      var a = 43
    }
  }
  println(a.b + a.a.a)
}
\end{Code}

\Subtask Vad är fördelen med att namn deklarerade inne i ett block är lokala i stället för globala?


\SOLUTION


\TaskSolved \what


\SubtaskSolved  Skriver ut talet 8. \code{a} får värdet \code{4 + 4} eftersom detta är den sista satsen i blocket. Man får också tre stycken varningar. Detta beror på att det förekommer tre satser i blocket som inte gör någon skillnad.

\SubtaskSolved  Skriver ut talet 5. De tre första satserna i det yttre blocket ignoreras. \code{b} får värdet som returneras av det yttre blocket. Det yttre blocket returnerar värdet som returneras i den sista satsen i blocket, som i sin tur är ett block. I det inre blocket skapas en ny \code{val} som också får namnet \code{b}. Notera att detta alltså inte är samma värde, även om det har samma namn. Den andra satsen räknar summan av \code{b} med sig själv. Eftersom vi nu befinner oss i det block där det andra \code{b}et precis har definieras så är det detta \code{b} som används och summan blir alltså åtta. Detta är dock helt irrelevant eftersom resultatet inte sparas någonstans. I den sista satsen blir resultatet 5 (eftersom \code{b} är fyra och vi adderar ett). Detta resultatet returneras från det innre blocket och vidare ur det yttre blocket.

\SubtaskSolved  Skriver ut talet 42. Blockets satser exekveras i ordning.

\SubtaskSolved  Skriver inte ut 42. I blocket skapas ett \code{val} med namnet \code{a} och värdet \code{42}. Detta värde finns inte utanför blocket och kommer därför inte att skrivas ut. Om du däremot definierat \code{a} som något annat tidigare så kommer istället det värdet att skrivas ut.

\SubtaskSolved  Skriver först ut \code{43} och sedan \code{42}. Förklaring:

\code{a} initieras med värdet \code{42}. Ett nytt värde som också har namnet \code{a} initieras med värdet \code{43}. Eftersom detta sker innanför ett nytt block, befinner vi oss i ett annat "namespace" och det gör alltså inget att vi använder samma namn. \code{a} skrivs ut. Eftersom vi befinner oss i det inre blocket är det \code{43} som skrivs ut, inte \code{42}. Scala kollar först efter värden som heter \code{a} i det inre "namespacet". Det är först i andra hand som den skulle upptäcka att det finns ett \code{a} i det yttre blocket. Till sist körs den sista satsen i det yttre blocket. Då skrivs \code{a} ut. Eftersom vi nu befinner oss i det yttre blocket, vet inte ens scala om att det andra \code{a}:et existerar. Resultatet av den här utskriften blir alltså \code{42}.

\SubtaskSolved  Ett fel uppstår. Variabeln \code{a} initieras två gånger i samma namespace. Förklaring till felet:

I det yttre blockets första sats initieras variablen \code{a} med värdet \code{42}. I det yttre blockets tredje sats försöker vi definiera en ny variabel med samma namn. I och med att vi befinner oss i samma namespace, krockar namnen.

Förklaring till vad som händer i sats två:

I det inre blocket har vi inte definierat någon variabel \code{a}. Till en början hittar alltså inte scala något sådant. Då letar scala vidare i det namespace som finns utanför det inre blocket och hittar variabeln som vi definierade i det yttre blockets första sats. Denna variabel får sitt värde förändrat.

\SubtaskSolved  Fel. Framåtreferens. Förklaring:

Det är inte tillåtet att referera till variabler som initieras senare i koden.

\SubtaskSolved  Skriver ut \code{85}. Förklaring:

I och med att vi den här gången initierade variabeln \code{b} och gav den ett värde innan vi använder oss av den, slipper vi problemet ovan.

\SubtaskSolved  Skriver ut \code{85}. Förklaring:

Det är tillåtet att referera till funktioner som definieras senare i koden.

\SubtaskSolved  Skriver ut \code{85}. Förklaring:

\code{a.b} refererar till variabeln \code{b} som ingår i objektet \code{a}.
\code{a.a.a} refererar till variabeln \code{a}, som ingår i ett objekt som heter \code{a} som i sin tur befinner sig i ett annat objekt som också heter \code{a}.

\SubtaskSolved  Skriver ut \code{85}. Förklaring:

Koden är identisk med förra deluppgiften förutom att ny rad används istället för semikolon.

\SubtaskSolved  I stora projekt med mycket kod, kan det vara svårt att hitta unika namn till alla sina variabler. Då är det en fördel om man kan hålla sina variabler i begränsade namespaces, så att de bara är tillgängliga precis när de behöver användas.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 14??? NUMMER I KOMMENTAR STÄMMER EJ MED GENERERAT NUMMER




\WHAT{Paket, \code{import} och klassfilstrukturer.}

\QUESTBEGIN

\Task \label{task:package} \what~   Med Java-8-plattformen kommer 4240 färdiga klasser, som är organiserade i 217 olika paket.\footnote{Se Stackoverflow: \href{http://stackoverflow.com/questions/3112882/how-many-classes-are-there-in-java-standard-edition}{how-many-classes-are-there-in-java-standard-edition}}

\Subtask Vilka paket finns i paketet javax som börjar på s?

\begin{REPLnonum}
scala> javax.s   //tryck på TAB-tangenten
\end{REPLnonum}

\Subtask Kör raderna nedan i REPL. Beskriv vad som händer för varje rad.
\begin{REPL}[numbers=left, numberstyle=\color{black}\ttfamily\scriptsize\selectfont]
scala> import javax.swing.JOptionPane
scala> def msg(s: String) = JOptionPane.showMessageDialog(null, s)
scala> msg("Hej på dej!")
scala> def input(msg: String) = JOptionPane.showInputDialog(null, msg)
scala> input("Vad heter du?")
scala> import JOptionPane.{showOptionDialog => optDlg}
scala> def inputOption(msg: String, opt: Array[Object]) =
         optDlg(null, msg, "Option", 0, 0, null, opt, opt(0))
scala> inputOption("Vad väljer du?", Array("Sten", "Sax", "Påse"))
\end{REPL}

\Subtask\Pen Vad hade du behövt ändra på efterföljande rader om import-satsen på rad 1 ovan ej hade gjorts?

\Subtask Skapa med en editor filen paket.scala och kompilera. Rita en bild av hur katalogstrukturen ser ut.

\begin{Code}
package gurka.tomat.banan

package p1 {
  package p11 {
    object hello {
      def hello = println("Hej paket p1.p11!")
    }
  }
  package p12 {
    object hello {
      def hello = println("Hej paket p1.p12!")
    }
  }
}

package p2 {
  package p21 {
    object hello {
      def hello = println("Hej paket p2.p21!")
    }
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    import p1._
    p11.hello.hello
    p12.hello.hello
    import p2.{p21 => apelsin}
    apelsin.hello.hello
  }
}
\end{Code}

\begin{REPL}
> gedit paket.scala
> scalac paket.scala
> scala gurka.tomat.banan.Main
> ls -R
\end{REPL}

\SOLUTION


\TaskSolved \what


\SubtaskSolved  \code{script   security   smartcardio   sound   sql   swing}

\SubtaskSolved  Radernas funktion i ordning:

1. Importerar JOptionPane från javax.swing

2. Definierar en metod som tar en sträng och öppnar en dialogruta med strängen.

3. Testar funktionen med argumentet "Hej på dej!". En dialogruta öppnas med texten "Hej på dej!".

4. Definierar en metod som tar emot en sträng som argument och öppnar en input-dialogruta med strängen.

5. Testar funktionen med argumentet "Vad heter du?". En dialogruta öppnas med texten "Vad heter du?". I ett fält kan man fylla i sitt namn. Funktionen returnerar namnet.

6. Importerar showOptionDialog från JOptionPane under namnet optDlg.

7. Definierar en metod som tar emot en sträng och en Array som argument och öppnar en flervalsdialog. Strängen ska innehålla frågan som flervalsdialogen visar upp. Arrayn ska innehålla alternativen som användaren ska välja mellan.

8.Testar funktionen med argumenten \code{"Vad väljer du?"} och \\ \code{Array("Sten, "Sax", "Påse")}. En dialogruta kommer upp och man får möjlighet att välja sten sax eller påse. Funktionen returnerar valet som man gör.

\SubtaskSolved  På alla ställen där \code{JOptionPane} förekommer, hade man istället fått skriva \code{javax.swing.JOptionPane}.

\SubtaskSolved  -



\QUESTEND




\ExtraTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\WHAT{???}

\QUESTBEGIN

\Task \what~\TODO

\SOLUTION

\TaskSolved \what~\TODO

\QUESTEND




\AdvancedTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\WHAT{???}

\QUESTBEGIN

\Task \what~\TODO

\SOLUTION

\TaskSolved \what~\TODO

\QUESTEND



%%%%%%%%%%%%%%%%%%%%% TODO FIXA NEDAN; KOLLA, FLYTTA, STRYK %%%%%%%%%%%%%%%%%%
\subsubsection \TODO Se över nedan uppgifter. Flytta? Stryka? Ändra?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\WHAT{Skapa en färgväljare. \TODO fördjupningsuppgift?}

\QUESTBEGIN

\Task \what~\TODO

\begin{REPL}
scala> val f = new javax.swing.JFrame
scala> val c = new javax.swing.JColorChooser
scala> f.add(c)
scala> f.setVisible(true)
scala> c.getColor
scala> c.getColor.getAlpha   // alpha styr genomskinlighet
\end{REPL}

\SOLUTION

\TaskSolved \what~\TODO

\QUESTEND





\WHAT{Skapa din egen \code{jar}-fil.}

\QUESTBEGIN

\Task  \what~

\Subtask Skriv kommandot \code{jar} i terminalen och undersök vad som finns för optioner. Se speciellt ''Example 1.'' i hjälputskriften. Vilket kommando ska du använda för att packa ihop flera filer i en enda jar-fil?

\Subtask Packa ihop biblioteket \TODO \code{gurka} i en jar-fil med nedan kommando, samt kör igång REPL med jar-filen på classpath.

\begin{REPL}
> jar cvf mittpaket.jar gurka
> scala -cp mittpaket.jar
scala> gurka.tomat.banan.Main.main(Array())
\end{REPL}


\SOLUTION


\TaskSolved \what\TODO


\SubtaskSolved  jar cvf [namn på skapad fil] [namn på input-filer]

\SubtaskSolved  -


\QUESTEND





\WHAT{Tupler som parametrar.}

\QUESTBEGIN

\Task  \what~ Implementera nedan varianter av beräkning av avståndet mellan två punkter:
\begin{Code}
def distxy(x1: Int, y1: Int, x2: Int, y2: Int): Double = ???

def distpt(p1: (Int, Int), p2: (Int, Int)): Double = ???

def distp(p1: (Int, Int))(p2: (Int, Int)): Double = ???

\end{Code}

\SOLUTION

\TaskSolved \what

\begin{Code}
def distxy(x1: Int, y1: Int, x2: Int, y2: Int): Double =
  hypot(x1 - x2, y1 - y2)

def distpt(p1: (Int, Int), p2: (Int, Int)): Double =
  hypot(p1._1 - p2._1, p2._2 - p2._2)

def distp(p1: (Int, Int))(p2: (Int, Int)): Double =
  hypot(p1._1 - p2._1, p2._2 - p2._2)
\end{Code}

\QUESTEND




\WHAT{Värdeanrop och namnanrop (fördröjd evaluering, ''lata'' argument).}

\QUESTBEGIN

\Task  \what~  Deklarera nedan funktioner i REPL.

\begin{Code}
def snark: Int = { print("snark "); Thread.sleep(1000); 42 }

def callByValue(x: Int) = x + x

def callByName(x: => Int) = x + x
\end{Code}

Evaluera nedan uttryck. Förklara vad som händer.

\Subtask \code{snark}

\Subtask \code{snark; snark; snark}

\Subtask \code{callByValue(1)}

\Subtask \code{callByName(1)}

\Subtask \code{callByValue(snark)}

\Subtask \code{callByName(snark)}


\Subtask Förklara vad som händer här:
\begin{REPL}
scala> def görDetta(block: => Unit) = block
scala> görDetta(println("hej"))
scala> görDetta{println("goddag")}
scala> görDetta{println("hej"); println("svejs")}
scala> def görDettaTvåGånger(block: => Unit) = {block; block}
scala> görDettaTvåGånger{println("goddag")}
\end{REPL}


\SOLUTION


\TaskSolved \what


\SubtaskSolved  \code{snark 42}

\SubtaskSolved  \code{snark snark snark 42}

Den evaluerar inte uttrycket förrän det behövs, så flera snark ger bara ett resultat för det är bara det som begärs.

\SubtaskSolved  \code{2}

\SubtaskSolved  \code{2}

Det är ingen större skillnad när vi bara skickar in en etta.

\SubtaskSolved  \code{snark, Int = 84}

\SubtaskSolved  När vi kallar på \code{callByValue} så skickar vi in snark som ett värde, och därmed behöver x bara beräknas en gång medans när vi kallar på \code{callByName} så skickar vi den som en funktion och därmed kallas snark på två gånger i funktionen för att beräkna x båda gångerna.

\code{snark snark, Int = 84}

\SubtaskSolved  \code{görDetta} är en kontrollstruktur som helt enkelt exekverar koden den matas med, \code{görDettaTvåGånger} gör just vad den säger. Detta är dock grunderna för vad som kan bli mycket mer avancerat om man kombinerar detta med loopar eller if-satser, som i sig är kontrollstrukturer.

\QUESTEND




\WHAT{Skapa din egen kontrollstruktur.}

\QUESTBEGIN

\Task  \what~

\Subtask Använd fördröjd evaluering i kombination med en uppdelad parameterlista och skapa din egen kontrollstruktur enligt nedan. (Det är så här som loopen \code{upprepa} i Kojo är definierad.)
\begin{REPL}
scala> def upprepa(n: Int)(block: => Unit): Unit = {
         var i = 0
         while (i < n) {block; i += 1}
       }
\end{REPL}

\Subtask Använd din nya loop-procedur och förklara vad som händer nedan.
\begin{REPL}
scala> upprepa(10)(println("hej"))
scala> upprepa(1000){
  val tärning = (math.random * 6 + 1).toInt
  print(tärning + " ")
}
\end{REPL}

\SOLUTION

\TaskSolved \what

\SubtaskSolved  -

\SubtaskSolved  I den första parameterlistan så anges hur många gånger koden i den andra parameterlistan ska exekveras. så \code{upprepa(10)(println("hej"))} printar hej 10 gånger

\QUESTEND






\WHAT{Fördröjd initialisering (''lata'' variabler).}

\QUESTBEGIN

\Task  \what~

\Subtask \label{subtask:delayalloc} Förklara vad som händer här:
\begin{REPL}
scala> val olat = 42
scala> lazy val lat = 42
scala> println(lat)
scala> val nu = {Thread.sleep(1000); println("nu"); 42}
scala> lazy val sen = {Thread.sleep(1000); println("sen"); 42}
scala> def igen = {Thread.sleep(1000); println("hver gang"); 42}
scala> println(nu)
scala> println(sen)
scala> println(igen)
scala> println(nu)
scala> println(sen)
scala> println(igen)
scala> object m {lazy val stor = Array.fill(1e9.toInt)(liten); val liten = 42}
scala> m.liten
scala> m.stor
\end{REPL}

\Subtask Vad är skillnaden mellan \code{val}, \code{lazy val} och \code{def}, vad gäller \emph{när} evalueringen sker?


\Subtask \label{subtask:forwardref} Förklara vad som händer här:
\begin{REPL}
scala> object objektÄrLata { val sen = { println("nu!"); 42 } }
scala> objektÄrLata
scala> objektÄrLata.sen
scala> {val x = y; val y = 42}
scala> object buggig {val a = b; val b = 42}
scala> buggig.a
scala> object funkar {lazy val a = b; val b = 42}
scala> funkar.a
scala> object nowarning {val many = Array.fill(10)(one); val one = 1}
scala> nowarning.many
\end{REPL}

\Subtask Med ledning av uppgift \ref{subtask:delayalloc} och uppgift \ref{subtask:forwardref}, beskriv två olika situationer när kan man ha nytta av \code{lazy val}?


\SOLUTION


\TaskSolved \what


\SubtaskSolved  Notera vid deklarationen av \code{nu}, \code{sen} och \code{igen} så är det bara \code{nu} som tar tid och skriver ut sin text. För \code{nu} evalueras men de andra väntar.

Men när vi ska kalla på dem så tar \code{nu} ingen tid och skriver inte ut nu medans \code{sen} och \code{igen} nu tar tid och skriver ut sin text. För \code{nu} har redan evaluerats men de andra behöver evalueras för de kallas på.

Och när vi kallar på dem för andra gången så är det bara \code{igen} som tar tid. För \code{nu} och \code{sen} är evaluerade och vid det här laget identiska medans \code{igen} behöver evalueras varje gång man kallar på den.

Vid deklaration av objektet så går allt bra, när vi kallar på \code{liten} så får vi 42 men när vi kallar på \code{stor} så får vi exception. Eftersom objekt är lata så evalueras inte objektet förrän vi anropar något ur det men \code{stor} är också lazy så den blir inte ett problem förrän just den anropas.

\SubtaskSolved
\code{val} evalueras direkt, \code{lazy val} evalueras när det behövs medans \code{def} evalueras varje gång det behövs.

\SubtaskSolved
När vi skapar objektÄrLata så skrivs inget ut för det evalueras inte förrän vi kallar på det, som vi gör nästa rad då skrivs nu ut. När vi sedan anropar sen evalueras inget och nu skrivs inte ut.

\{\code{val x=y; val y = 42}\} kastar error eftersom y inte är evaluerad när vi försöker evaluera x.

När vi skapar \code{buggig} så varnar den och vi ser varför på nästa rad då att \code{a} verkar vara lika med 0. Eftersom \code{b} inte är evaluerad än så blir det 0 men till skillnad från tidigare vet \code{val a} iallafall att den är en Int eftersom objectet med \code{b} är åtminstone definerat.

\code{funkar} fungerar just för att \code{a} är en \code{lazy val} och evalueras då inte förrän efter \code{b} evaluerats och ger därför 42 som den ska.

\code{nowarning} har samma problem som \code{buggig} men ger ingen varning och därför försöker skriva ut innan \code{one} är evaluerad och ger därför nollor.

\SubtaskSolved
När man vill skapa ett objekt som funkar eller fixa problemet i no warning, man kan vilja ha sina variabler i just den ordningen p.g.a. läslighet.

Men även om man inte vill slöa ner ett system med en massa arbete när allt deklareras på en gång utan tar det hellre gradvis allteftersom det används.

\QUESTEND
