
%!TEX encoding = UTF-8 Unicode
%!TEX root = ../exercises.tex

\ifPreSolution

\Exercise{\ExeWeekTWO}\label{exe:W02}
\begin{Goals}
\input{modules/w02-programs-exercise-goals.tex}
\end{Goals}

\begin{Preparations}
\item \StudyTheory{02}
\item Bekanta dig med grundläggande terminalkommandon, se appendix~\ref{appendix:terminal}.
\item Bekanta dig med den editor du vill använda, se appendix~\ref{appendix:compile}.
\end{Preparations}

\else

\ExerciseSolution{\ExeWeekTWO}

\fi


% TODO fundera på detta:
% terminalkommando
% scalac -> hello world; scala som script; javac
% paket, import, jar, main,



\BasicTasksNoLab %%%%%%%%%%%%%%%%




\WHAT{Para ihop begrepp med beskrivning.}

\QUESTBEGIN

\Task \what

\vspace{1em}\noindent Koppla varje begrepp med den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}
\input{generated/quiz-w02-concepts-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w02-concepts-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND





\WHAT{Använda terminalen.}

\QUESTBEGIN

\Task \what~Läs om terminalen i appendix \ref{appendix:terminal}.

\Subtask Vilka kommando ska du köra för att skapa en katalog med namnet \code{hello} och sedan navigera till katalogen och skriva ut aktuell katalog? Öppna ett teminalfönster och kör dessa tre kommando.

\Subtask Vilka kommando ska du köra för att navigera tillbaka ett steg i filträdet och lista alla filer och kataloger på denna plats? Skriv dessa kommando.

\SOLUTION

\TaskSolved \what

\SubtaskSolved

\begin{REPL}
> mkdir hello
> cd hello
> pwd
\end{REPL}

\SubtaskSolved

\begin{REPL}
> cd ..
> ls
\end{REPL}


\QUESTEND









\WHAT{Skapa och köra ett Scala-skript.}

\QUESTBEGIN

\Task  \what~

\Subtask Skapa en fil med namn \texttt{sum.scala} med hjälp av en editor, t.ex. \code{atom}.
\begin{REPLnonum}
> atom sum.scala
\end{REPLnonum}

\noindent Filen ska innehålla dessa tre rader:
\scalainputlisting{examples/sum.scala}

\noindent Spara filen och kör kommandot \code{scala sum.scala} i terminalen:
\begin{REPLnonum}
> scala sum.scala
\end{REPLnonum}

\noindent Vad blir summan av de $1000$ första talen?

\Subtask Ändra i filen \code{sum.scala} så att högerparentesen på sista raden saknas. Spara filen (Ctrl+S) och kör skriptfilen igen i terminalen (pil-upp). Hur lyder felmeddelandet? Är det ett körtidsfel eller ett kompileringsfel?

\Subtask Ändra i hello-script.scala så att det i stället för \code{1000} står \code{args(0).toInt} efter \code{val n =} och spara och kör om ditt program med argumentet 5001 så här:
\begin{REPL}
> scala hello-script.scala 5001
\end{REPL}
\noindent Vad blir summan av de $5001$ första talen?

\Subtask Vad blir det för felmeddelande om du glömmer ge programmet ett argument? Är det ett körtidsfel eller ett kompileringsfel?

\SOLUTION

\TaskSolved \what

\SubtaskSolved
\begin{REPL}
Summan av de 1000 första talen är: 500500
\end{REPL}

\SubtaskSolved  Kompileringsfelet blir: \code{error: ')' expected but eof found}

\SubtaskSolved  Filen ska se ut så här:
\begin{Code}
val n = args(0).toInt
val summa = (1 to n).sum
println(s"Summan av de $n första talen är: $summa")
\end{Code}

Utskriften blir så här:
\begin{REPL}
Summan av de 5001 första talen är: 12507501
\end{REPL}

\SubtaskSolved Körtidsfelet blir: \code{java.lang.ArrayIndexOutOfBoundsException: 0}\\(Anledningen är att arrayen \code{args} blir tom om programargument saknas och platsen med index $0$ därmed inte finns.)

\QUESTEND





\WHAT{Scala-applikation med \code+main+-metod.}

\QUESTBEGIN

\Task  \what~  Skapa med hjälp av en editor en fil med namn \texttt{hello.scala}.
\begin{REPLnonum}
> atom hello.scala
\end{REPLnonum}
Skriv nedan kod i filen:


\scalainputlisting{examples/hello.scala}

\Subtask Kompilera med \code{scalac hello.scala} och kör koden med \code{scala Hello}. Notera stor bokstav i klassnamnet. Vad heter filerna som kompilatorn skapar?
\begin{REPLnonum}
> scalac hello.scala
> ls
> scala Hello
\end{REPLnonum}

\Subtask Hur ska du ändra i din kod så att kompilatorn ger följande felmeddelande: \\
\texttt{Missing closing brace}

\Subtask Varför behövs \code{main}-metoden?

\Subtask Vilket alternativ går snabbast att köra igång, ett skript eller en kompilerad applikation? Varför? Vilket alternativ kör snabbast när väl exekveringen är igång?


\SOLUTION


\TaskSolved \what


\SubtaskSolved  Filerna som kompilatorn skapat heter \code{Hello.class} och \verb+Hello\$.class+

\SubtaskSolved  Felmeddelandet får du om du tar bort den sista krullparentesen.

\SubtaskSolved

\begin{itemize}
  \item  Det går snabbare att göra i gång en kompilerad app eftersom maskinkoden är sparad i en fil som kan köras igång direkt. En kompilerad app måste ha ett objekt med en main-metod. En kompilerad app kan bestå av många filer som samkompileras.
  \item När ett skript kör kompileras koden i skriptfilen före varje körning och maskinkoden sparas inte. Ett skript består bara av en enda text-fil som körs från början. Ingen main-metod behövs.
  \item  När väl exekveringen är igång sker exekveringen av maskinkoden exakt lika snabbt oberoende av om koden är genererad ur ett skript eller en förkompilerad app.
\end{itemize}

\QUESTEND







\WHAT{Java-applikation.}

\QUESTBEGIN

\Task \label{task:java} \what~   Skapa med hjälp av en editor en fil med namn \texttt{Hi.java}. Notera stor bokstav. I ett Java-program måste namnet före \code{.java} stämma överens exakt med klassnamnet.
\begin{REPLnonum}
> atom Hi.java
\end{REPLnonum}
Skriv dessa rader i filen:

\javainputlisting{examples/Hi.java}

\noindent Kompilera med \code{javac Hi.java} och kör koden med \code{java Hi}.
\begin{REPLnonum}
> javac Hi.java
> ls
> java Hi
\end{REPLnonum}

\Subtask Vad heter filen som kompilatorn skapat?

\Subtask Jämför Java-programmet ovan med Scala-programmet i föregående uppgift. Programmen gör samma sak men syntaxen (hur koden ska skrivas) skiljer sig åt och det finns vissa skillnader i semantiken (vad koden betyder). Vi ska senare i kursen gå igenom \emph{exakt} vad varje del nedan betyder, men försök redan nu para ihop delarna till vänster ur Scala-programmet som (ungefär) motsvarar de delar ur Java-programmet som finns till höger.

\begin{ConceptConnections}
\input{generated/quiz-w02-hello-scala-java-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION


\TaskSolved \what


\SubtaskSolved  Hi.class

\SubtaskSolved

\begin{ConceptConnections}
\input{generated/quiz-w02-hello-scala-java-solurows-generated.tex}
\end{ConceptConnections}


\QUESTEND


























%%%%%%%%%%%%%%%%%%% SKA FIXAS:




\WHAT{Datastrukturen \code+Range+.}

\QUESTBEGIN

\Task  \what~Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{Range(1, 10)}

\Subtask \code{Range(1, 10).inclusive}

\Subtask \code{Range(0, 50, 5)}

\Subtask \code{Range(0, 50, 5).size}

\Subtask \code{Range(0, 50, 5).inclusive}

\Subtask \code{Range(0, 50, 5).inclusive.size}

\Subtask \code{0.until(10)}

\Subtask \code{0 until (10)}

\Subtask \code{0 until 10}

\Subtask \code{0.to(10)}

\Subtask \code{0 to 10}

\Subtask \code{0.until(50).by(5)}

\Subtask \code{0 to 50 by 5}

\Subtask \code{(0 to 50 by 5).size}

\Subtask \code{(1 to 1000).sum}


\SOLUTION


\TaskSolved \what


\SubtaskSolved  värde: \code{Range(1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(1,2,3,4,5,6,7,8,9,10)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,5,10,15,20,25,30,35,40,45)}

 typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{10}, typ: \code{Int}

\SubtaskSolved  värde: \code{Range(0,5,10,15,20,25,30,35,40,45,50)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{11}, typ: \code{Int}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9,10)}

typ: \code{scala.collection.immutable.Range.Inclusive}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9,10)}

typ: \code{scala.collection.immutable.Range.Inclusive}

\SubtaskSolved  värde: \code{Range(0,5,10,15,20,25,30,35,40,45)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,5,10,15,20,25,30,35,40,45,50)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{11}, typ: \code{Int}

\SubtaskSolved  värde: \code{500500}, typ: \code{Int}




\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 2




\WHAT{Datastrukturen \code+Array+.}

\QUESTBEGIN

\Task \label{task:array} \what~   Kör nedan kodrader i Scala REPL. Beskriv vad som händer.

\Subtask \code{val xs = Array("hej","på","dej", "!")}

\Subtask \code{xs(0)}

\Subtask \code{xs(3)}

\Subtask \code{xs(4)}

\Subtask \code{xs(1) + " " + xs(2)}

\Subtask \code{xs.mkString}

\Subtask \code{xs.mkString(" ")}

\Subtask \code{xs.mkString("(", ",", ")")}

\Subtask \code{xs.mkString("Array(", ", ", ")")}

\Subtask \code{xs(0) = 42}

\Subtask \code{xs(0) = "42"; println(xs(0))}

\Subtask \code{val ys = Array(42, 7, 3, 8)}

\Subtask \code{ys.sum}

\Subtask \code{ys.min}

\Subtask \code{ys.max}

\Subtask \code{val zs = Array.fill(10)(42)}

\Subtask \code{zs.sum}

\Subtask\Pen Datastrukturen \code{Range} håller reda på start- och slutvärde, samt stegstorleken för en uppräkning, men alla talen i uppräkningen genereras inte förrän så behövs. En \code{Int} tar 4 bytes i minnet. Ungefär hur mycket plats i minnet tar de objekt som variablerna \code{r} respektive \code{a} refererar till nedan?
\begin{REPL}
scala> val r = (1 to Int.MaxValue by 2)
scala> val a = r.toArray
\end{REPL}
\emph{Tips:} Använd uttrycket \code{ BigInt(Int.MaxValue) * 2 } i dina beräkningar.

\SOLUTION


\TaskSolved \what


\SubtaskSolved  Ett objekt av typen \code{Array[String]} skapas med värdet

\code{Array(hej, på, dej, !)} och med namnet \code{xs}.

\SubtaskSolved  Returnerar en sträng med värdet \code{hej}.

\SubtaskSolved  Returnerar en sträng med värdet \code{!}.

\SubtaskSolved  Ett exception genereras. Skriver ut:

\code{java.lang.ArrayIndexOutOfBoundsException: 4}

\SubtaskSolved  Returnerar en sträng med värdet \code{på dej}.

\SubtaskSolved  Returnerar en sträng med värdet \code{hejpådej!}.

\SubtaskSolved  Returnerar en sträng med värdet \code{hej på dej !}.

\SubtaskSolved  Returnerar en sträng med värdet \code{(hej,på,dej,!)}.

\SubtaskSolved  Returnerar en sträng med värdet \code{Array(hej,på,dej,!)}.

\SubtaskSolved  Ett fel uppstår av typen \code{type mismatch}. Konsollen talar om för oss vad den fick, dvs värdet \code{42} av typen \code{Int}. Den talar även om för oss vad den ville ha, dvs något värde av typen \code{String}. Till sist skriver den ut vår kodrad och pekar ut felet.

\SubtaskSolved  Det första elementet i \code{xs} ändras till värdet \code{42}. Därefter skrivs det första värdet i \code{xs} ut.

\SubtaskSolved  Ett objekt av typen \code{Array[Int]} skapas med värdet \code{Array(42, 7, 3, 8)} och med namnet \code{ys}.

\SubtaskSolved  Returnerar summan av elementen i \code{ys}. Resultatet är \code{60}.

\SubtaskSolved  Returnerar det minsta värdet i \code{ys}. Resultatet är \code{3}.

\SubtaskSolved  Returnerar det största värdet i \code{ys}. Resultatet är \code{42}.

\SubtaskSolved  Ett nytt värde av typen \code{Array[Int]} skapas med \code{10} stycken element, alla med värdet \code{42}.

\SubtaskSolved  Returnerar summan av elementen i \code{zs}. Resultatet blir 420 (42 multiplicerat med 10).

\SubtaskSolved  \code{r} tar upp 12 bytes. \code{a} tar upp ca 4 miljarder bytes.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 3




\WHAT{Datastrukturen \code+Vector+.}

\QUESTBEGIN

\Task  \what~  Kör nedan kodrader i Scala REPL. Beskriv vad som händer.

\Subtask \code{val words = Vector("hej","på","dej", "!")}

\Subtask \code{words(0)}

\Subtask \code{words(3)}

\Subtask \code{words.mkString}

\Subtask \code{words.mkString(" ")}

\Subtask \code{words.mkString("(", ",", ")")}

\Subtask \code{words.mkString("Ord(", ", ", ")")}

\Subtask \code{words(0) = "42"}

\Subtask \code{val numbers = Vector(42, 7, 3, 8)}

\Subtask \code{numbers.sum}

\Subtask \code{numbers.min}

\Subtask \code{numbers.max}

\Subtask \code{val moreNumbers = Vector.fill(10000)(42)}

\Subtask \code{moreNumbers.sum}

\Subtask\Pen Jämför med uppgift \ref{task:array}. Vad kan man göra med en \code{Array} som man inte kan göra med en \code{Vector}?

\SOLUTION


\TaskSolved \what


\SubtaskSolved  Ett objekt av typen \code{scala.collection.immutable.Vector[String]} initieras med värdet \code{Vector(hej, på dej, !)}.

\SubtaskSolved  Returnerar det nollte elementet i \code{words}, dvs strängen \code{hej}.

\SubtaskSolved  Returnerar det tredje elementet i \code{words}, dvs strängen \code{!}.

\SubtaskSolved  Omvandlar vektorn till en Sträng.

\SubtaskSolved  Samma som ovan, fast den här gången används mellanrum för att seperera elementen.

\SubtaskSolved  Samma som ovan, fast den här gången sepereras elementen av kommatecken istället för mellanrum och dessutom börjar och slutar den resulterande strängen med parenteser.

\SubtaskSolved  Samma som ovan, fast med ordet \code{Ord} tillagt i början av den resulterande strängen.

\SubtaskSolved  Ett fel uppstår. Typen \code{Vector} är immutable. Dess element kan alltså inte bytas ut.

\SubtaskSolved  En ny \code{Vector[Int]} skapas med värdet \code{Vector(42, 7, 3, 8)}.

\SubtaskSolved  Returnerar summan av vektorn \code{numbers}.

\SubtaskSolved  Returnerar vektorns minsta element.

\SubtaskSolved  Returnerar vektorns största element.

\SubtaskSolved  En ny vektor skapas innehållandes tiotusen 42or.

\SubtaskSolved  Returnerar summan av vektorns element.

\SubtaskSolved  Byta ut element.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 4




\WHAT{\code+for+-uttryck}

\QUESTBEGIN

\Task  \what~ . Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{for (i <- Range(1,10)) yield i}

\Subtask \code{for (i <- 1 until 10) yield i}

\Subtask \code{for (i <- 1 until 10) yield i + 1}

\Subtask \code{for (i <- Range(1,10).inclusive) yield i}

\Subtask \code{for (i <- 1 to 10) yield i}

\Subtask \code{for (i <- 1 to 10) yield i + 1}

\Subtask \code{(for (i <- 1 to 10) yield i + 1).sum}

\Subtask \code{for (x <- 0.0 to 2 * math.Pi by math.Pi/4) yield math.sin(x)}


\SOLUTION


\TaskSolved \what


\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 3, 4, 5, 6, 7, 8, 9, 10, 11)}

\SubtaskSolved  typ: \code{Int}, värde: \code{Vector(65)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(0.0, 0.707, 1.0, 0.707, 0.0, -0.707, -1.0, -0.707)}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 5




\WHAT{Metoden \code+map+ på en samling.}

\QUESTBEGIN

\Task  \what~  Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{Range(0,10).map(i => i + 1)}

\Subtask \code{(0 until 10).map(i => i + 1)}

\Subtask \code{(1 to 10).map(i => i * 2)}

\Subtask \code{(1 to 10).map(_ * 2)}

\Subtask \code{Vector.fill(10000)(42).map(_ + 43)}

\SOLUTION


\TaskSolved \what


\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)}

\SubtaskSolved  typ: \code{scala.collection.immutable.Vector[Int]}

värde: En vector av tiotusen 85or (85 = 42 + 43).



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 6




\WHAT{Metoden \code+foreach+ på en samling.}

\QUESTBEGIN

\Task  \what~  Kör nedan satser i Scala REPL. Vad händer?

\Subtask \code{Range(0,10).foreach(i => println(i))}

\Subtask \code{(0 until 10).foreach(i => println(i))}

\Subtask \code|(1 to 10).foreach{i => print("hej"); println(i * 2)}|

\Subtask \code{(1 to 10).foreach(println)}

\Subtask \code{Vector.fill(10000)(math.random).foreach(r => }\\
           \code{      if (r > 0.99) print("pling!"))}


\SOLUTION


\TaskSolved \what


\SubtaskSolved  En \code{Range} skapas och dess element skrivs ut ett och ett.

\SubtaskSolved  Samma sak händer.

\SubtaskSolved  De tio första jämna talen (noll ej inräknat) skrivs ut med ett "hej" framför.

\SubtaskSolved  Talen 1 till 10 skrivs ut.

\SubtaskSolved  Tiotusen slumptal mellan 0 och 1 genereras. Varje gång ett tal är större än 0.99 kommer det ett pling.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 7




\WHAT{Algoritm: SWAP.}

\QUESTBEGIN

\Task  \what~\\\emph{Problem:} Byta plats på två variablers värden. \\\emph{Lösningsidé:} Använd temporär variabel för mellanlagring.

\Subtask Skriv med \emph{pseudo-kod} algoritmen SWAP, d.v.s. beskriv på vanlig svenska, steg för steg, hur en variabel $temp$ används för mellanlagring vid värdebytet:

\emph{Indata:} två heltalsvariabler $x$ och $y$

\textbf{???}

\emph{Utdata:} variablerna $x$ och $y$ vars värden har bytt plats.

\Subtask Implementerar algoritmen SWAP. Ersätt \code{???} nedan med satser separerade av semikolon:

\begin{REPL}
scala> var (x, y) = (42, 43)
scala> ???
scala> println("x är " + x + ", y är " + y)
x är 43, y är 42
\end{REPL}



\SOLUTION


\TaskSolved \what


\SubtaskSolved  Pseudokoden kan se ut såhär:

Skapa heltalsvariabel temp.
Flytta värdet från x till temp.
Flytta värdet från y till x.
Flytta värdet från temp till y.

\SubtaskSolved
\begin{REPLnonum}
scala> var (x, y) = (42, 43)
x: Int = 42
y: Int = 43
scala> var temp = x; x = y; y = temp;
temp: Int = 42
x: Int = 43
y: Int = 42
scala> println("x är " + x + ", y är " + y)
x är 43, y är 42
\end{REPLnonum}



\QUESTEND





\WHAT{Algoritm: SUMBUG}

\QUESTBEGIN

\Task  \what~ . Nedan återfinns pseudo-koden för SUMBUG.

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{heltalet $n$}
 \Output{utskrift av summan av de första $n$ heltalen }
 $sum \leftarrow 0$ \\
 $i \leftarrow 1$  \\
 \While{$i \leq n$}{
  $sum \leftarrow sum + 1$
 }
 skriv ut $sum$
\end{algorithm}

\Subtask\Pen Kör algoritmen steg för steg med penna och papper, där du skriver upp hur värdena för respektive variabel ändras. Det finns två buggar i algoritmen. Vilka? Rätta buggarna och test igen genom att ''köra'' algoritmen med penna på papper och kontrollera så att algoritmen fungerar för $n=0$, $n=1$, och $n=5$. Vad händer om $n=-1$?

\Subtask Skapa med hjälp av en editor filen \code{sumn.scala}. Implementera algoritmen SUM enligt den rättade pseudokoden och placera implementationen i en main-metod i ett objekt med namnet \code{sumn}. Du kan skapa indata \code{n} till algoritmen med denna deklaration i början av din main-metod: \\ \code{val n = args(0).toInt} \\ Vad ger applikationen för utskrift om du kör den med argumentet 8888?

\begin{REPLnonum}
> scalac sumn.scala
> scala sumn 8888
\end{REPLnonum}

\Subtask Kontrollera att din implementation räknar rätt genom att jämföra svaret med detta uttrycks värde, evaluerat i Scala REPL:
\begin{REPLnonum}
scala> (1 to 8888).sum
\end{REPLnonum}

\Subtask Implementera algoritmen SUM enligt pseudokoden ovan, men nu i Java. Skapa filen \code{SumN.java} och använd koden från uppgift \ref{task:java} som mall för att deklarera den publika klassen \code{SumN} med en main-metod. Några tips om Java-syntax och standarfunktioner i Java:

\begin{itemize}[noitemsep, nolistsep]
\item Alla satser i Java måste avslutas med semikolon.
\item Heltalsvariabler deklareras med nyckelordet \lstinline[language=Java]{int} (litet i).
\item Typnamnet ska stå \emph{före} namnet på variabeln. Exempel: \\ \lstinline[language=Java]{int sum = 0;}
\item Indexering i en array görs i Java med hakparenteser: \code{args[0]}
\item I stället för Scala-uttrycket \code{args(0).toInt}, använd Java-uttrycket: \\ \code{Integer.parseInt(args[0])}
\item \code{while}-satser i Scala och Java har samma syntax.
\item Utskrift i Java görs med \code{System.out.println}
\end{itemize}


\SOLUTION


\TaskSolved \what


\SubtaskSolved  Bugg: Eftersom \code{i} inte ökar, fastnar programmet i en oändlig loop. Fix: Lägg till en sats i slutet av while-blocket som ökar värdet på i med 1.
Bugg: Eftersom man bara ökar summan med 1 varje gång, kommer resultatet att bli summan av n stycken 1or, inte de n första heltalen. Fix: Ändra så att summan ökar med \code{i} varje gång, istället för 1.
För -1, blir resultatet 0. Förklaring: i börjar på 1 och är alltså aldrig mindre än n som ju är -1. while-blocket genomförs alltså noll gånger, och efter att \code{sum} får sitt ursprungsvärde förändras den aldrig.
\SubtaskSolved  39502716
\SubtaskSolved  -
\SubtaskSolved  Såhär kan implementationen se ut:
\begin{Code}
public class SumN {
  public static void main(String[] args) {
    int n = Integer.parseInt(args[0]);
    int sum = 0;
    int i = 1;
    while(i <= n){
      sum = sum + i;
      i = i + 1;
      }
    }
    System.out.println(sum);
}
\end{Code}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 12




\WHAT{Algoritm: MAXBUG}

\QUESTBEGIN

\Task  \what~ . Nedan återfinns pseudo-koden för MAXBUG.

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{Array $args$ med strängar som alla innehåller heltal}
 \Output{utskrift av största heltalet }
 $max \leftarrow$ det minsta heltalet som kan uppkomma  \\
 $n \leftarrow $ antalet heltal \\
 $i \leftarrow 0$ \\
 \While{$i < n$}{
   $x \leftarrow args(i).toInt$ \\
   \If{( x > $max$)}{$max \leftarrow x$}
  % $i \leftarrow i + 1$
 }
 skriv ut $max$
\end{algorithm}

\Subtask\Pen Kör med penna och papper. Det finns en bugg i algoritmen ovan. Vilken? Rätta buggen.

\Subtask Implementera algoritmen MAX (utan bugg) som en Scala-applikation. Tips:
\begin{itemize}[noitemsep, nolistsep]
\item Det minsta \code{Int}-värdet som någonsin kan uppkomma: \code{Int.MinValue}
\item Antalet element i $args$ ges av: \code{args.size}
\end{itemize}

\begin{REPL}
> gedit maxn.scala
> scalac maxn.scala
> scala maxn 7 42 1 -5 9
42
\end{REPL}

\Subtask\Pen \label{subtask:arg0} Skriv om algoritmen så att variabeln $max$ initialiseras med det första talet i sekvensen.

\Subtask Implementera den nya algoritmvarianten från uppgift \ref{subtask:arg0} och prova programmet. Vad händer om $args$ är tom?

\SOLUTION


\TaskSolved \what


\SubtaskSolved  Bugg: i ökar aldrig. Programmet fastnar i en oändlig loop. Fix: Lägg till en sats som ökar i med 1, i slutet av while-blocket.

\SubtaskSolved  Så här kan implementationen se ut:
\begin{Code}
object Max {
  def main(args: Array[String]): Unit = {
    var max = Int.MinValue
    val n = args.size
    var i = 0
    while(i < n) {
      val x = args(i).toInt
      if(x > max) {
        max = x
      }
      i = i + 1
    }
    println(max)
  }
}
\end{Code}
\SubtaskSolved  Raden där max initieras ändras till \code{var max = args(0).toInt}

\SubtaskSolved  \code{java.lang.ArrayIndexOutOfBoundsException: 0}



\QUESTEND







\ExtraTasks %%%%%%%%%%%%%%%%%%%



\WHAT{Algoritmen MINDEX.}

\QUESTBEGIN

\Task \label{task:minindex} \what~  Implementera algoritmen MININDEX som söker index för minsta heltalet i en sekvens. Pseudokod för algoritmen MININDEX:

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Utdata}

 \Input{Sekvens $xs$ med $n$ st heltal.}
 \Output{Index för det minsta talet eller $-1$ om $xs$ är tom.  }
 $minPos \leftarrow 0 $\\
 $i \leftarrow 1$ \\
 \While{$i < n$}{
   \If{xs(i) < $xs(minPos)$}{$minPos \leftarrow i$}
   $i \leftarrow i + 1$
 }
 \eIf{$n > 0$}{\Return{$minPos$}}{\Return{$-1$}}
\end{algorithm}

\Subtask Prova algoritmen med penna och papper på sekvensen $(1, 2, -1, 4)$ och rita minnessituationen efter varje runda i loopen. Vad blir skillnaden i exekveringsförloppet om loopvariablen $i$  initialiserats till $0$ i stället för $1$?

\Subtask Implementera algoritmen MININDEX i Scala i en funktion med denna signatur:
\begin{Code}
def indexOfMin(xs: Array[Int]): Int = ???
\end{Code}
Testa för olika fall: tom sekvens; sekvens med endast ett tal; lång sekvens med det minsta talet först, någonstans mitt i, samt sist.

\begin{Code}
// kod till facit
def indexOfMin(xs: Array[Int]): Int = {
  var minPos = 0
  var i = 1
  while (i < xs.size) {
    if (xs(i) < xs(minPos)) minPos = i
    i += 1
  }
  if (xs.size > 0) minPos else -1
}


\end{Code}

\SOLUTION


\QUESTEND




\newpage

\AdvancedTasks %%%%%%%%%%%%%%%%%




\WHAT{Undersök den genererade byte-koden.}

\QUESTBEGIN

\Task  \what~  Kompilatorn genererar \textbf{byte-kod}, uttalas ''bajtkod'' \Eng{byte code}, som den virtuella maskinen tolkar och översätter till maskinkod medan programmet kör. Med kommandot \code{:javap} i REPL kan du undersöka byte-koden.
\begin{REPL}
scala> def plusxy(x: Int, y: Int) = x + y
scala> :javap plusxy
\end{REPL}

\Subtask Leta upp raden \code{public int plusxy(int, int);} och studera koden efter \code{Code:} och försök gissa vilken instruktion som utför själva additionen.

\Subtask Lägg till en parameter till: \\ \code{def plusxyz(x: Int, y: Int, z: Int) = x + y + z}
\\ och studera byte-koden med \code{:javap plusxyz}. Vad skiljer byte-koden mellan \code{plusxy} och \code{plusxyz}?

\Subtask\Pen Läs om byte-kod här: \href{https://en.wikipedia.org/wiki/Java\_bytecode}{en.wikipedia.org/wiki/Java\_bytecode}. Vad betyder den inledande bokstaven i additionsinstruktionen?


\SOLUTION


\QUESTEND










\WHAT{NEEDS A TOPIC DESCRIPTION}

\QUESTBEGIN

\Task  \what~ Läs om krullparenteser och vanliga parenteser på stack overflow: \\ \href{http://stackoverflow.com/questions/4386127/what-is-the-formal-difference-in-scala-between-braces-and-parentheses-and-when}{stackoverflow.com/questions/4386127/what-is-the-formal-difference-in-scala-between-braces-and-parentheses-and-when} och prova själv i REPL hur du kan blanda dessa olika slags parenteser på olika vis.

\SOLUTION


\QUESTEND






\WHAT{Tips:}

\QUESTBEGIN

\Task  \what~ Gör jämförande studier av Scalas api-dokumentation för \code{ArrayBuffer}, \code{Array} och \code{Vector}. Ge exempel på metoder som finns på objekt av typen \code{Array} och \code{ArrayBuffer} men inte på objekt av typen \code{Vector}.  Kolla efter metoder som returnerar \code{Unit}. Prova några muterande metoder på \code{Array} och \code{ArrayBuffer} i REPL.

\SOLUTION


\QUESTEND






\WHAT{Tips:}

\QUESTBEGIN

\Task  \what~ Bygg vidare på koden nedan och gör ett Sten-Sax-Påse-spel\footnote{\href{https://sv.wikipedia.org/wiki/Sten,\_sax,\_p\%C3\%A5se}{sv.wikipedia.org/wiki/Sten,\_sax,\_p\%C3\%A5se}} som även meddelar vem som vinner. Koden fungerar att köra som den är, men funktionen \code{winnerMsg} är ej klar.  Du kan använda modulo-räkning med \code{%}-operatorn för att avgöra vem som vinner.

\begin{Code}[basicstyle=\ttfamily\footnotesize\selectfont]]
object Rock {
  import javax.swing.JOptionPane
  import JOptionPane.{showOptionDialog => optDlg}

  def inputOption(msg: String, opt: Vector[String]) =
    optDlg(null, msg, "Option", 0, 0, null, opt.toArray[Object], opt(0))

  def msg(s: String) = JOptionPane.showMessageDialog(null, s)

  val opt =  Vector("Sten", "Sax", "Påse")

  def userChoice = inputOption("Vad väljer du?", opt)

  def computerChoice = (math.random * 3).toInt

  def winnerMsg(user: Int, computer: Int) = "??? vann!"

  def main(args: Array[String]): Unit = {
    var keepPlaying = true
    while (keepPlaying) {
      val u = userChoice
      val c = computerChoice
      msg("Du valde " + opt(u) + "\n" +
          "Datorn valde " + opt(c) + "\n" +
          winnerMsg(u, c))
      if (u != c) keepPlaying = false
    }
  }
}
\end{Code}\SOLUTION


\QUESTEND
