
%!TEX encoding = UTF-8 Unicode
%!TEX root = ../exercises.tex

\ifPreSolution

\Exercise{\ExeWeekTWO}\label{exe:W02}
\begin{Goals}
\input{modules/w02-programs-exercise-goals.tex}
\end{Goals}

\begin{Preparations}
\item \StudyTheory{02}
\item Bekanta dig med grundläggande terminalkommandon, se appendix~\ref{appendix:terminal}.
\item Bekanta dig med den editor du vill använda, se appendix~\ref{appendix:compile}.
\end{Preparations}

\else

\ExerciseSolution{\ExeWeekTWO}

\fi


% terminalkommando
% scalac -> hello world; scala som script; javac
% paket, import, jar, main,


\BasicTasksNoLab %%%%%%%%%%%%%%%%




\WHAT{Para ihop begrepp med beskrivning.}

\QUESTBEGIN

\Task \what

\vspace{1em}\noindent Koppla varje begrepp med den (förenklade) beskrivning som passar bäst: 

\begin{ConceptConnections}
\input{generated/quiz-w02-concepts-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w02-concepts-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND






%%%%%%%%%%%%%%%%%%% SKA FIXAS:




\WHAT{Datastrukturen \code+Range+.}

\QUESTBEGIN

\Task  \what~Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{Range(1, 10)}

\Subtask \code{Range(1, 10).inclusive}

\Subtask \code{Range(0, 50, 5)}

\Subtask \code{Range(0, 50, 5).size}

\Subtask \code{Range(0, 50, 5).inclusive}

\Subtask \code{Range(0, 50, 5).inclusive.size}

\Subtask \code{0.until(10)}

\Subtask \code{0 until (10)}

\Subtask \code{0 until 10}

\Subtask \code{0.to(10)}

\Subtask \code{0 to 10}

\Subtask \code{0.until(50).by(5)}

\Subtask \code{0 to 50 by 5}

\Subtask \code{(0 to 50 by 5).size}

\Subtask \code{(1 to 1000).sum}


\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  värde: \code{Range(1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(1,2,3,4,5,6,7,8,9,10)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,5,10,15,20,25,30,35,40,45)}

 typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{10}, typ: \code{Int}

\SubtaskSolved  värde: \code{Range(0,5,10,15,20,25,30,35,40,45,50)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{11}, typ: \code{Int}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9,10)}

typ: \code{scala.collection.immutable.Range.Inclusive}

\SubtaskSolved  värde: \code{Range(0,1,2,3,4,5,6,7,8,9,10)}

typ: \code{scala.collection.immutable.Range.Inclusive}

\SubtaskSolved  värde: \code{Range(0,5,10,15,20,25,30,35,40,45)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{Range(0,5,10,15,20,25,30,35,40,45,50)}

typ: \code{scala.collection.immutable.Range}

\SubtaskSolved  värde: \code{11}, typ: \code{Int}

\SubtaskSolved  värde: \code{500500}, typ: \code{Int}




\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 2




\WHAT{Datastrukturen \code+Array+.}

\QUESTBEGIN

\Task \label{task:array} \what~   Kör nedan kodrader i Scala REPL. Beskriv vad som händer.

\Subtask \code{val xs = Array("hej","på","dej", "!")}

\Subtask \code{xs(0)}

\Subtask \code{xs(3)}

\Subtask \code{xs(4)}

\Subtask \code{xs(1) + " " + xs(2)}

\Subtask \code{xs.mkString}

\Subtask \code{xs.mkString(" ")}

\Subtask \code{xs.mkString("(", ",", ")")}

\Subtask \code{xs.mkString("Array(", ", ", ")")}

\Subtask \code{xs(0) = 42}

\Subtask \code{xs(0) = "42"; println(xs(0))}

\Subtask \code{val ys = Array(42, 7, 3, 8)}

\Subtask \code{ys.sum}

\Subtask \code{ys.min}

\Subtask \code{ys.max}

\Subtask \code{val zs = Array.fill(10)(42)}

\Subtask \code{zs.sum}

\Subtask\Pen Datastrukturen \code{Range} håller reda på start- och slutvärde, samt stegstorleken för en uppräkning, men alla talen i uppräkningen genereras inte förrän så behövs. En \code{Int} tar 4 bytes i minnet. Ungefär hur mycket plats i minnet tar de objekt som variablerna \code{r} respektive \code{a} refererar till nedan?
\begin{REPL}
scala> val r = (1 to Int.MaxValue by 2)
scala> val a = r.toArray
\end{REPL}
\emph{Tips:} Använd uttrycket \code{ BigInt(Int.MaxValue) * 2 } i dina beräkningar.

\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  Ett objekt av typen \code{Array[String]} skapas med värdet 

\code{Array(hej, på, dej, !)} och med namnet \code{xs}.

\SubtaskSolved  Returnerar en sträng med värdet \code{hej}.

\SubtaskSolved  Returnerar en sträng med värdet \code{!}.

\SubtaskSolved  Ett exception genereras. Skriver ut:

\code{java.lang.ArrayIndexOutOfBoundsException: 4}

\SubtaskSolved  Returnerar en sträng med värdet \code{på dej}.

\SubtaskSolved  Returnerar en sträng med värdet \code{hejpådej!}.

\SubtaskSolved  Returnerar en sträng med värdet \code{hej på dej !}.

\SubtaskSolved  Returnerar en sträng med värdet \code{(hej,på,dej,!)}.

\SubtaskSolved  Returnerar en sträng med värdet \code{Array(hej,på,dej,!)}.

\SubtaskSolved  Ett fel uppstår av typen \code{type mismatch}. Konsollen talar om för oss vad den fick, dvs värdet \code{42} av typen \code{Int}. Den talar även om för oss vad den ville ha, dvs något värde av typen \code{String}. Till sist skriver den ut vår kodrad och pekar ut felet.

\SubtaskSolved  Det första elementet i \code{xs} ändras till värdet \code{42}. Därefter skrivs det första värdet i \code{xs} ut.

\SubtaskSolved  Ett objekt av typen \code{Array[Int]} skapas med värdet \code{Array(42, 7, 3, 8)} och med namnet \code{ys}.

\SubtaskSolved  Returnerar summan av elementen i \code{ys}. Resultatet är \code{60}.

\SubtaskSolved  Returnerar det minsta värdet i \code{ys}. Resultatet är \code{3}.

\SubtaskSolved  Returnerar det största värdet i \code{ys}. Resultatet är \code{42}.

\SubtaskSolved  Ett nytt värde av typen \code{Array[Int]} skapas med \code{10} stycken element, alla med värdet \code{42}.

\SubtaskSolved  Returnerar summan av elementen i \code{zs}. Resultatet blir 420 (42 multiplicerat med 10).

\SubtaskSolved  \code{r} tar upp 12 bytes. \code{a} tar upp ca 4 miljarder bytes.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 3




\WHAT{Datastrukturen \code+Vector+.}

\QUESTBEGIN

\Task  \what~  Kör nedan kodrader i Scala REPL. Beskriv vad som händer.

\Subtask \code{val words = Vector("hej","på","dej", "!")}

\Subtask \code{words(0)}

\Subtask \code{words(3)}

\Subtask \code{words.mkString}

\Subtask \code{words.mkString(" ")}

\Subtask \code{words.mkString("(", ",", ")")}

\Subtask \code{words.mkString("Ord(", ", ", ")")}

\Subtask \code{words(0) = "42"}

\Subtask \code{val numbers = Vector(42, 7, 3, 8)}

\Subtask \code{numbers.sum}

\Subtask \code{numbers.min}

\Subtask \code{numbers.max}

\Subtask \code{val moreNumbers = Vector.fill(10000)(42)}

\Subtask \code{moreNumbers.sum}

\Subtask\Pen Jämför med uppgift \ref{task:array}. Vad kan man göra med en \code{Array} som man inte kan göra med en \code{Vector}?

\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  Ett objekt av typen \code{scala.collection.immutable.Vector[String]} initieras med värdet \code{Vector(hej, på dej, !)}.

\SubtaskSolved  Returnerar det nollte elementet i \code{words}, dvs strängen \code{hej}.

\SubtaskSolved  Returnerar det tredje elementet i \code{words}, dvs strängen \code{!}.

\SubtaskSolved  Omvandlar vektorn till en Sträng.

\SubtaskSolved  Samma som ovan, fast den här gången används mellanrum för att seperera elementen.

\SubtaskSolved  Samma som ovan, fast den här gången sepereras elementen av kommatecken istället för mellanrum och dessutom börjar och slutar den resulterande strängen med parenteser.

\SubtaskSolved  Samma som ovan, fast med ordet \code{Ord} tillagt i början av den resulterande strängen.

\SubtaskSolved  Ett fel uppstår. Typen \code{Vector} är immutable. Dess element kan alltså inte bytas ut.

\SubtaskSolved  En ny \code{Vector[Int]} skapas med värdet \code{Vector(42, 7, 3, 8)}. 

\SubtaskSolved  Returnerar summan av vektorn \code{numbers}.

\SubtaskSolved  Returnerar vektorns minsta element.

\SubtaskSolved  Returnerar vektorns största element. 

\SubtaskSolved  En ny vektor skapas innehållandes tiotusen 42or.

\SubtaskSolved  Returnerar summan av vektorns element.

\SubtaskSolved  Byta ut element.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 4




\WHAT{\code+for+-uttryck}

\QUESTBEGIN

\Task  \what~ . Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{for (i <- Range(1,10)) yield i}

\Subtask \code{for (i <- 1 until 10) yield i}

\Subtask \code{for (i <- 1 until 10) yield i + 1}

\Subtask \code{for (i <- Range(1,10).inclusive) yield i}

\Subtask \code{for (i <- 1 to 10) yield i}

\Subtask \code{for (i <- 1 to 10) yield i + 1}

\Subtask \code{(for (i <- 1 to 10) yield i + 1).sum}

\Subtask \code{for (x <- 0.0 to 2 * math.Pi by math.Pi/4) yield math.sin(x)}


\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 3, 4, 5, 6, 7, 8, 9, 10, 11)}

\SubtaskSolved  typ: \code{Int}, värde: \code{Vector(65)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(0.0, 0.707, 1.0, 0.707, 0.0, -0.707, -1.0, -0.707)}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 5




\WHAT{Metoden \code+map+ på en samling.}

\QUESTBEGIN

\Task  \what~  Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{Range(0,10).map(i => i + 1)}

\Subtask \code{(0 until 10).map(i => i + 1)}

\Subtask \code{(1 to 10).map(i => i * 2)}

\Subtask \code{(1 to 10).map(_ * 2)}

\Subtask \code{Vector.fill(10000)(42).map(_ + 43)}

\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)}

\SubtaskSolved  typ: \code{scala.collection.immutable.IndexedSeq[Int]}

värde: \code{Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)}

\SubtaskSolved  typ: \code{scala.collection.immutable.Vector[Int]}

värde: En vector av tiotusen 85or (85 = 42 + 43).



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 6




\WHAT{Metoden \code+foreach+ på en samling.}

\QUESTBEGIN

\Task  \what~  Kör nedan satser i Scala REPL. Vad händer?

\Subtask \code{Range(0,10).foreach(i => println(i))}

\Subtask \code{(0 until 10).foreach(i => println(i))}

\Subtask \code|(1 to 10).foreach{i => print("hej"); println(i * 2)}|

\Subtask \code{(1 to 10).foreach(println)}

\Subtask \code{Vector.fill(10000)(math.random).foreach(r => }\\
           \code{      if (r > 0.99) print("pling!"))}


\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  En \code{Range} skapas och dess element skrivs ut ett och ett.

\SubtaskSolved  Samma sak händer.

\SubtaskSolved  De tio första jämna talen (noll ej inräknat) skrivs ut med ett "hej" framför.

\SubtaskSolved  Talen 1 till 10 skrivs ut.

\SubtaskSolved  Tiotusen slumptal mellan 0 och 1 genereras. Varje gång ett tal är större än 0.99 kommer det ett pling.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 7




\WHAT{Algoritm: SWAP.}

\QUESTBEGIN

\Task  \what~ 

\Subtask Skriv med \emph{pseudo-kod} algoritmen SWAP. Beskriv på vanlig svenska, steg för steg, hur en variabel $temp$ används för mellanlagring vid värdebytet:

\emph{Indata:} två heltalsvariabler $x$ och $y$

\emph{???}

\emph{Utdata:} variablerna $x$ och $y$ vars värden har bytt plats.

\Subtask Implementerar algoritmen SWAP. Ersätt \code{???} nedan med satser separerade av semikolon:

\begin{REPL}
scala> var (x, y) = (42, 43)
scala> ???
scala> println("x är " + x + ", y är " + y)
x är 43, y är 42
\end{REPL}



\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  Pseudokoden kan se ut såhär:

Skapa heltalsvariabel temp. 
Flytta värdet från x till temp. 
Flytta värdet från y till x. 
Flytta värdet från temp till y.

\SubtaskSolved 
\begin{REPLnonum}
scala> var (x, y) = (42, 43)
x: Int = 42
y: Int = 43
scala> var temp = x; x = y; y = temp;
temp: Int = 42
x: Int = 43
y: Int = 42
scala> println("x är " + x + ", y är " + y)
x är 43, y är 42
\end{REPLnonum}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 8




\WHAT{Skript.}

\QUESTBEGIN

\Task  \what~  Skapa en fil med namn \texttt{hello-script.scala} med hjälp av en editor som innehåller denna enda rad:
\begin{Code}
println("hej skript")
\end{Code}
Spara filen och kör kommandot \code{scala hello-script.scala} i terminalen:
\begin{REPLnonum}
> scala hello-script.scala
\end{REPLnonum}

\Subtask Vad händer?

\Subtask Ändra i filen så att högerparentesen saknas. Spara och kör skriptfilen igen. Vad händer?

\Subtask Lägg till en sats sist i skriptet som skriver ut summan av de ett tusen stycken heltalen från och med 2 till och med 1001, så som visas nedan.
\begin{REPL}
> scala hello-script.scala
hej skript
501500
\end{REPL}

\Subtask Ändra i hello-script.scala genom att införa \code{val n = args(0).toInt} och använd \code{n} som övre gräns för summeringen av de n första heltalen.
\begin{REPL}
> scala hello-script.scala 5001
hej skript
12507501
\end{REPL}

\Subtask Vad blir det för felmeddelande om du glömmer ge programmet ett argument?


\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  Skriver ut "hej skript".

\SubtaskSolved  Ett felmeddelande skrivs ut.

\SubtaskSolved  Lägg till raden:
\code{println((2 to 1001).sum)} 
eller motsvarande.

\SubtaskSolved  Filen ska se ut ungefär såhär: \\
\begin{Code} 
val n = args(0).toInt 
println("hej skript") 
println((1 to n).sum)
\end{Code}

\SubtaskSolved  \code{java.lang.ArrayIndexOutOfBoundsException: 0}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 9




\WHAT{Applikation med \code+main+-metod.}

\QUESTBEGIN

\Task  \what~  Skapa med hjälp av en editor en fil med namn \texttt{hello-app.scala}.
\begin{REPLnonum}
> gedit hello-app.scala
\end{REPLnonum}
Skriv dessa rader i filen:


\scalainputlisting{examples/hello-app.scala}

\Subtask Kompilera med \code{scalac hello-app.scala} och kör koden med \code{scala Hello}.
\begin{REPLnonum}
> scalac hello-app.scala
> ls
> scala Hello
\end{REPLnonum}
Vad heter filerna som kompilatorn skapar?

\Subtask Ändra i din kod så att kompilatorn ger följande felmeddelande: \\
\texttt{Missing closing brace}

\Subtask\Pen Varför behövs \code{main}-metoden?

\Subtask\Pen Vilket alternativ går snabbast att köra igång, ett skript eller en kompilerad applikation? Varför? Vilket alternativ kör snabbast när väl exekveringen är igång?


\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  Hello.class och Hello\$.class

\SubtaskSolved  Ta bort en av krullparenteserna i slutet.

\SubtaskSolved  I ett skript behöver man inte skriva någon main-metod. Kompilatorn lägger till en automatiskt precis när koden ska köras. I en applikation behöver man däremot det. För att göra en applikation definierar vi ett objekt som vi i det här fallet kallar för \code{Hello}. Från början gör inte objekt någonting. De bara finns. För att objekt ska kunna göra något behövs det metoder. I vanliga fall utförs inte metoder förrän en annan metod "ropar" på metoden. main-metoden ropas dock automatiskt när en applikation startas. Annars hade ju ingenting hänt, eftersom alla metoderna väntar på att någon annan metod ska börja. \\
\SubtaskSolved  Första gången man ska köra en applikation måste den först kompileras innan den exekveras. Skript kompileras automatiskt samtidigt som de exekveras, vilket totalt sett görs på kortare tid. Därför tar det längre tid att starta en applikation första gången än att starta ett skript första gånge. När en applikation väl har kompileras och kan exekveras, går det dock mycket fortare. Fördelen med applikationer är att de kan exekveras flera gånger utan att kompileras om.



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 10




\WHAT{Java-applikation.}

\QUESTBEGIN

\Task \label{task:java} \what~   Skapa med hjälp av en editor en fil med namn \texttt{Hi.java}.
\begin{REPLnonum}
> gedit Hi.java
\end{REPLnonum}
Skriv dessa rader i filen:

\javainputlisting{examples/Hi.java}

\noindent Kompilera med \code{javac Hi.java} och kör koden med \code{java Hi}.
\begin{REPLnonum}
> javac Hi.java
> ls
> java Hi
\end{REPLnonum}

\Subtask\Pen Vad heter filen som kompilatorn skapat?

\Subtask\Pen Jämför signaturen för Java-programmets main-metod med signaturen för Scala-programmets main-metod. De betyder samma sak men syntaxen är olika. Beskriv skillnader och likheter i syntaxen.

\Subtask\Pen Vad blir det för felmeddelande om källkodsfilen och klassnamnet inte överensstämmer i ett Java-program?


\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  Hi.class

\SubtaskSolved  I javas syntax börjar man med orden \code{public static}. I scala uteblir dessa. I scala är alla metoder automatiskt publika om inget annat används. Därför behövs aldrig ordet \code{public} i scala. I scala finns det tekniskt sett inga statiska metoder. Men i praktiken fungerar vanliga metoder i ett scala-objekt på ungefär samma sätt som statiska metoder i en java-klass. I scala används ordet \code{def} varje gång en funktion ska definieras. I java slipper man det. I java skriver man returtypen (\code{void}) innan parametrarna. I scala kommer istället metodens returtyp (\code{Unit}) i slutet. Javas \code{void} motsvarar scalas \code{Unit}. I scalas syntax kommer parameterns namn (\code{args}) före parameterns typ (\code{Array[String]}), separerat med ett kolon. I java kommer typen (\code{String[]}) först och sen kommer namnet (\code{args}). \code{String[]} i java betyder ungefär samma sak som \code{Array[String]} i scala.

\SubtaskSolved  -



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 11




\WHAT{Algoritm: SUMBUG}

\QUESTBEGIN

\Task  \what~ . Nedan återfinns pseudo-koden för SUMBUG.

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{heltalet $n$}
 \Output{utskrift av summan av de första $n$ heltalen }
 $sum \leftarrow 0$ \\
 $i \leftarrow 1$  \\
 \While{$i \leq n$}{
  $sum \leftarrow sum + 1$
 }
 skriv ut $sum$
\end{algorithm}

\Subtask\Pen Kör algoritmen steg för steg med penna och papper, där du skriver upp hur värdena för respektive variabel ändras. Det finns två buggar i algoritmen. Vilka? Rätta buggarna och test igen genom att ''köra'' algoritmen med penna på papper och kontrollera så att algoritmen fungerar för $n=0$, $n=1$, och $n=5$. Vad händer om $n=-1$?

\Subtask Skapa med hjälp av en editor filen \code{sumn.scala}. Implementera algoritmen SUM enligt den rättade pseudokoden och placera implementationen i en main-metod i ett objekt med namnet \code{sumn}. Du kan skapa indata \code{n} till algoritmen med denna deklaration i början av din main-metod: \\ \code{val n = args(0).toInt} \\ Vad ger applikationen för utskrift om du kör den med argumentet 8888?

\begin{REPLnonum}
> scalac sumn.scala
> scala sumn 8888
\end{REPLnonum}

\Subtask Kontrollera att din implementation räknar rätt genom att jämföra svaret med detta uttrycks värde, evaluerat i Scala REPL:
\begin{REPLnonum}
scala> (1 to 8888).sum
\end{REPLnonum}

\Subtask Implementera algoritmen SUM enligt pseudokoden ovan, men nu i Java. Skapa filen \code{SumN.java} och använd koden från uppgift \ref{task:java} som mall för att deklarera den publika klassen \code{SumN} med en main-metod. Några tips om Java-syntax och standarfunktioner i Java:

\begin{itemize}[noitemsep, nolistsep]
\item Alla satser i Java måste avslutas med semikolon.
\item Heltalsvariabler deklareras med nyckelordet \lstinline[language=Java]{int} (litet i).
\item Typnamnet ska stå \emph{före} namnet på variabeln. Exempel: \\ \lstinline[language=Java]{int sum = 0;}
\item Indexering i en array görs i Java med hakparenteser: \code{args[0]}
\item I stället för Scala-uttrycket \code{args(0).toInt}, använd Java-uttrycket: \\ \code{Integer.parseInt(args[0])}
\item \code{while}-satser i Scala och Java har samma syntax.
\item Utskrift i Java görs med \code{System.out.println}
\end{itemize}


\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  Bugg: Eftersom \code{i} inte ökar, fastnar programmet i en oändlig loop. Fix: Lägg till en sats i slutet av while-blocket som ökar värdet på i med 1.
Bugg: Eftersom man bara ökar summan med 1 varje gång, kommer resultatet att bli summan av n stycken 1or, inte de n första heltalen. Fix: Ändra så att summan ökar med \code{i} varje gång, istället för 1.
För -1, blir resultatet 0. Förklaring: i börjar på 1 och är alltså aldrig mindre än n som ju är -1. while-blocket genomförs alltså noll gånger, och efter att \code{sum} får sitt ursprungsvärde förändras den aldrig.
\SubtaskSolved  39502716
\SubtaskSolved  -
\SubtaskSolved  Såhär kan implementationen se ut:
\begin{Code}
public class SumN {
  public static void main(String[] args) {
    int n = Integer.parseInt(args[0]);
    int sum = 0;
    int i = 1;
    while(i <= n){
      sum = sum + i;
      i = i + 1;
      }
    }
    System.out.println(sum);
}
\end{Code}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 12




\WHAT{Algoritm: MAXBUG}

\QUESTBEGIN

\Task  \what~ . Nedan återfinns pseudo-koden för MAXBUG.

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{Array $args$ med strängar som alla innehåller heltal}
 \Output{utskrift av största heltalet }
 $max \leftarrow$ det minsta heltalet som kan uppkomma  \\
 $n \leftarrow $ antalet heltal \\
 $i \leftarrow 0$ \\
 \While{$i < n$}{
   $x \leftarrow args(i).toInt$ \\
   \If{( x > $max$)}{$max \leftarrow x$}
  % $i \leftarrow i + 1$
 }
 skriv ut $max$
\end{algorithm}

\Subtask\Pen Kör med penna och papper. Det finns en bugg i algoritmen ovan. Vilken? Rätta buggen.

\Subtask Implementera algoritmen MAX (utan bugg) som en Scala-applikation. Tips:
\begin{itemize}[noitemsep, nolistsep]
\item Det minsta \code{Int}-värdet som någonsin kan uppkomma: \code{Int.MinValue}
\item Antalet element i $args$ ges av: \code{args.size}
\end{itemize}

\begin{REPL}
> gedit maxn.scala
> scalac maxn.scala
> scala maxn 7 42 1 -5 9
42
\end{REPL}

\Subtask\Pen \label{subtask:arg0} Skriv om algoritmen så att variabeln $max$ initialiseras med det första talet i sekvensen.

\Subtask Implementera den nya algoritmvarianten från uppgift \ref{subtask:arg0} och prova programmet. Vad händer om $args$ är tom?

\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  Bugg: i ökar aldrig. Programmet fastnar i en oändlig loop. Fix: Lägg till en sats som ökar i med 1, i slutet av while-blocket.

\SubtaskSolved  Så här kan implementationen se ut:
\begin{Code}
object Max {
  def main(args: Array[String]): Unit = {
    var max = Int.MinValue
    val n = args.size
    var i = 0
    while(i < n) {
      val x = args(i).toInt
      if(x > max) {
        max = x
      }
      i = i + 1
    }
    println(max)
  }
}
\end{Code}
\SubtaskSolved  Raden där max initieras ändras till \code{var max = args(0).toInt} 

\SubtaskSolved  \code{java.lang.ArrayIndexOutOfBoundsException: 0}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 13




\WHAT{Block, namnsynlighet, namnöverskuggning}

\QUESTBEGIN

\Task  \what~ . Kör nedan kod i Scala REPL eller i Kojo. Vad händer nedan? Varför?

\Subtask \code|val a = {1 + 1; 2 + 2; 3 + 3; 4 + 4}; println(a)|

\Subtask \code|val b = {1; 2; 3; {val b = 4; b + b; b + 1}}; println(b)|

\Subtask \code|{val a = 42; println(a)}|

\Subtask \code|{val a = 42}; println(a)|

\Subtask \code|{val a = 42; {val a = 43; println(a)}; println(a)}|

\Subtask \code|{var a = 42; {a = a + 1}; var a = 43}|

\Subtask \code|{var a = 42; {a = a + b; var b = 43}; println(a)}|

\Subtask \code|{var a = 42; {var b = 43; a = a + b}; println(a)}|

\Subtask \code|{var a = 42; {a = a + b; def b = 43}; println(a)}|

\Subtask \code|{object a{var b=42;object a{var a=43}};println(a.b+a.a.a)}|

\Subtask

\begin{Code}
{
  object a {
    var b = 42
    object a {
      var a = 43
    }
  }
  println(a.b + a.a.a)
}
\end{Code}

\Subtask Vad är fördelen med att namn deklarerade inne i ett block är lokala i stället för globala?


\SOLUTION


\TaskSolved \what


\SubtaskSolved  Skriver ut talet 8. \code{a} får värdet \code{4 + 4} eftersom detta är den sista satsen i blocket. Man får också tre stycken varningar. Detta beror på att det förekommer tre satser i blocket som inte gör någon skillnad.

\SubtaskSolved  Skriver ut talet 5. De tre första satserna i det yttre blocket ignoreras. \code{b} får värdet som returneras av det yttre blocket. Det yttre blocket returnerar värdet som returneras i den sista satsen i blocket, som i sin tur är ett block. I det inre blocket skapas en ny \code{val} som också får namnet \code{b}. Notera att detta alltså inte är samma värde, även om det har samma namn. Den andra satsen räknar summan av \code{b} med sig själv. Eftersom vi nu befinner oss i det block där det andra \code{b}et precis har definieras så är det detta \code{b} som används och summan blir alltså åtta. Detta är dock helt irrelevant eftersom resultatet inte sparas någonstans. I den sista satsen blir resultatet 5 (eftersom \code{b} är fyra och vi adderar ett). Detta resultatet returneras från det innre blocket och vidare ur det yttre blocket.

\SubtaskSolved  Skriver ut talet 42. Blockets satser exekveras i ordning. 

\SubtaskSolved  Skriver inte ut 42. I blocket skapas ett \code{val} med namnet \code{a} och värdet \code{42}. Detta värde finns inte utanför blocket och kommer därför inte att skrivas ut. Om du däremot definierat \code{a} som något annat tidigare så kommer istället det värdet att skrivas ut.

\SubtaskSolved  Skriver först ut \code{43} och sedan \code{42}. Förklaring:

\code{a} initieras med värdet \code{42}. Ett nytt värde som också har namnet \code{a} initieras med värdet \code{43}. Eftersom detta sker innanför ett nytt block, befinner vi oss i ett annat "namespace" och det gör alltså inget att vi använder samma namn. \code{a} skrivs ut. Eftersom vi befinner oss i det inre blocket är det \code{43} som skrivs ut, inte \code{42}. Scala kollar först efter värden som heter \code{a} i det inre "namespacet". Det är först i andra hand som den skulle upptäcka att det finns ett \code{a} i det yttre blocket. Till sist körs den sista satsen i det yttre blocket. Då skrivs \code{a} ut. Eftersom vi nu befinner oss i det yttre blocket, vet inte ens scala om att det andra \code{a}:et existerar. Resultatet av den här utskriften blir alltså \code{42}.

\SubtaskSolved  Ett fel uppstår. Variabeln \code{a} initieras två gånger i samma namespace. Förklaring till felet:

I det yttre blockets första sats initieras variablen \code{a} med värdet \code{42}. I det yttre blockets tredje sats försöker vi definiera en ny variabel med samma namn. I och med att vi befinner oss i samma namespace, krockar namnen.

Förklaring till vad som händer i sats två:

I det inre blocket har vi inte definierat någon variabel \code{a}. Till en början hittar alltså inte scala något sådant. Då letar scala vidare i det namespace som finns utanför det inre blocket och hittar variabeln som vi definierade i det yttre blockets första sats. Denna variabel får sitt värde förändrat.

\SubtaskSolved  Fel. Framåtreferens. Förklaring:

Det är inte tillåtet att referera till variabler som initieras senare i koden.

\SubtaskSolved  Skriver ut \code{85}. Förklaring:

I och med att vi den här gången initierade variabeln \code{b} och gav den ett värde innan vi använder oss av den, slipper vi problemet ovan.

\SubtaskSolved  Skriver ut \code{85}. Förklaring:

Det är tillåtet att referera till funktioner som definieras senare i koden.

\SubtaskSolved  Skriver ut \code{85}. Förklaring:

\code{a.b} refererar till variabeln \code{b} som ingår i objektet \code{a}.
\code{a.a.a} refererar till variabeln \code{a}, som ingår i ett objekt som heter \code{a} som i sin tur befinner sig i ett annat objekt som också heter \code{a}.

\SubtaskSolved  Skriver ut \code{85}. Förklaring:

Koden är identisk med förra deluppgiften förutom att ny rad används istället för semikolon.

\SubtaskSolved  I stora projekt med mycket kod, kan det vara svårt att hitta unika namn till alla sina variabler. Då är det en fördel om man kan hålla sina variabler i begränsade namespaces, så att de bara är tillgängliga precis när de behöver användas. 



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 14??? NUMMER I KOMMENTAR STÄMMER EJ MED GENERERAT NUMMER




\WHAT{Paket, \code{import} och klassfilstrukturer.}

\QUESTBEGIN

\Task \label{task:package} \what~   Med Java-8-plattformen kommer 4240 färdiga klasser, som är organiserade i 217 olika paket.\footnote{Se Stackoverflow: \href{http://stackoverflow.com/questions/3112882/how-many-classes-are-there-in-java-standard-edition}{how-many-classes-are-there-in-java-standard-edition}}

\Subtask Vilka paket finns i paketet javax som börjar på s?

\begin{REPLnonum}
scala> javax.s   //tryck på TAB-tangenten
\end{REPLnonum}

\Subtask Kör raderna nedan i REPL. Beskriv vad som händer för varje rad.
\begin{REPL}[numbers=left, numberstyle=\color{black}\ttfamily\scriptsize\selectfont]
scala> import javax.swing.JOptionPane
scala> def msg(s: String) = JOptionPane.showMessageDialog(null, s)
scala> msg("Hej på dej!")
scala> def input(msg: String) = JOptionPane.showInputDialog(null, msg)
scala> input("Vad heter du?")
scala> import JOptionPane.{showOptionDialog => optDlg}
scala> def inputOption(msg: String, opt: Array[Object]) =
         optDlg(null, msg, "Option", 0, 0, null, opt, opt(0))
scala> inputOption("Vad väljer du?", Array("Sten", "Sax", "Påse"))
\end{REPL}

\Subtask\Pen Vad hade du behövt ändra på efterföljande rader om import-satsen på rad 1 ovan ej hade gjorts?

\Subtask Skapa med en editor filen paket.scala och kompilera. Rita en bild av hur katalogstrukturen ser ut.

\begin{Code}
package gurka.tomat.banan

package p1 {
  package p11 {
    object hello {
      def hello = println("Hej paket p1.p11!")
    }
  }
  package p12 {
    object hello {
      def hello = println("Hej paket p1.p12!")
    }
  }
}

package p2 {
  package p21 {
    object hello {
      def hello = println("Hej paket p2.p21!")
    }
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    import p1._
    p11.hello.hello
    p12.hello.hello
    import p2.{p21 => apelsin}
    apelsin.hello.hello
  }
}
\end{Code}

\begin{REPL}
> gedit paket.scala
> scalac paket.scala
> scala gurka.tomat.banan.Main
> ls -R
\end{REPL}

\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  \code{script   security   smartcardio   sound   sql   swing}

\SubtaskSolved  Radernas funktion i ordning:

1. Importerar JOptionPane från javax.swing

2. Definierar en metod som tar en sträng och öppnar en dialogruta med strängen.

3. Testar funktionen med argumentet "Hej på dej!". En dialogruta öppnas med texten "Hej på dej!".

4. Definierar en metod som tar emot en sträng som argument och öppnar en input-dialogruta med strängen.

5. Testar funktionen med argumentet "Vad heter du?". En dialogruta öppnas med texten "Vad heter du?". I ett fält kan man fylla i sitt namn. Funktionen returnerar namnet.

6. Importerar showOptionDialog från JOptionPane under namnet optDlg.

7. Definierar en metod som tar emot en sträng och en Array som argument och öppnar en flervalsdialog. Strängen ska innehålla frågan som flervalsdialogen visar upp. Arrayn ska innehålla alternativen som användaren ska välja mellan.

8.Testar funktionen med argumenten \code{"Vad väljer du?"} och \\ \code{Array("Sten, "Sax", "Påse")}. En dialogruta kommer upp och man får möjlighet att välja sten sax eller påse. Funktionen returnerar valet som man gör.

\SubtaskSolved  På alla ställen där \code{JOptionPane} förekommer, hade man istället fått skriva \code{javax.swing.JOptionPane}.

\SubtaskSolved  -



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 15




\WHAT{Skapa \code{jar}-filer och använda classpath}

\QUESTBEGIN

\Task  \what~ 

\Subtask Skriv kommandot \code{jar} i terminalen och undersök vad som finns för optioner. Se speciellt ''Example 1.'' i hjälputskriften. Vilket kommando ska du använda för att packa ihop flera filer i en enda jar-fil?

\Subtask Som en fortsättning på uppgift \ref{task:package}, packa ihop biblioteket \code{gurka} i en jar-fil med nedan kommando, samt kör igång REPL med jar-filen på classpath.

\begin{REPL}
> jar cvf mittpaket.jar gurka
> scala -cp mittpaket.jar
scala> gurka.tomat.banan.Main.main(Array())
\end{REPL}


\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  jar cvf [namn på skapad fil] [namn på input-filer]

\SubtaskSolved  -



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      %Uppgift 16




\WHAT{Skapa dokumentation med \code{scaladoc}-kommandot}

\QUESTBEGIN

\Task  \what~ 

\Subtask Som en fortsättning på uppgift \ref{task:package}, kör nedan kommando i terminalen:

\begin{REPL}
> scaladoc paket.scala
> ls
> firefox index.html   # eller öppna index.html i valfri webbläsare
\end{REPL}

Vad händer?

\Subtask Lägg till några fler metoder i något av objekten i filen \code{paket.scala} och lägg även till några dokumentationskommentarer. Kompilera om och kör. Generera om dokumentationen.

\begin{verbatim}
//... ändra i filen paket.scala

/** min paketdokumentationskommentar p2 */
package p2 {
  /** min paketdokumentationskommentar p21 */
  package p21 {
    /** ett hälsningsobjekt */
    object hello {
      /** en hälsningsmetod i p2.p21 */
      def hello = println("Hej paket p2.p21!")

      /** en metod som skriver ut tiden */
      def date = println(new java.util.Date)
    }
  }
}

\end{verbatim}

\begin{REPL}
> gedit paket.scala
> scalac paket.scala
> jar cvf mittpaket.jar gurka
> scala -cp mittpaket.jar
scala> gurka.tomat.banan.p2.p21.hello.date
scala> :q
> scaladoc paket.scala
> firefox index.html
\end{REPL}

\newpage

\ExtraTasks %%%%%%%%%%%%%%%%%%%

\SOLUTION


\TaskSolved \what
 

\SubtaskSolved  -

\SubtaskSolved  -
\QUESTEND






\WHAT{NEEDS A TOPIC DESCRIPTION}

\QUESTBEGIN

\Task \label{task:minindex} \what~  Implementera algoritmen MININDEX som söker index för minsta heltalet i en sekvens. Pseudokod för algoritmen MININDEX:

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Utdata}

 \Input{Sekvens $xs$ med $n$ st heltal.}
 \Output{Index för det minsta talet eller $-1$ om $xs$ är tom.  }
 $minPos \leftarrow 0 $\\
 $i \leftarrow 1$ \\
 \While{$i < n$}{
   \If{xs(i) < $xs(minPos)$}{$minPos \leftarrow i$}
   $i \leftarrow i + 1$
 }
 \eIf{$n > 0$}{\Return{$minPos$}}{\Return{$-1$}}
\end{algorithm}

\Subtask Prova algoritmen med penna och papper på sekvensen $(1, 2, -1, 4)$ och rita minnessituationen efter varje runda i loopen. Vad blir skillnaden i exekveringsförloppet om loopvariablen $i$  initialiserats till $0$ i stället för $1$?

\Subtask Implementera algoritmen MININDEX i Scala i en funktion med denna signatur:
\begin{Code}
def indexOfMin(xs: Array[Int]): Int = ???
\end{Code}
Testa för olika fall: tom sekvens; sekvens med endast ett tal; lång sekvens med det minsta talet först, någonstans mitt i, samt sist.

\begin{Code}
// kod till facit
def indexOfMin(xs: Array[Int]): Int = {
  var minPos = 0
  var i = 1
  while (i < xs.size) {
    if (xs(i) < xs(minPos)) minPos = i
    i += 1
  }
  if (xs.size > 0) minPos else -1
}


\end{Code}

\newpage

\AdvancedTasks %%%%%%%%%%%%%%%%%


\SOLUTION


\QUESTEND






\WHAT{NEEDS A TOPIC DESCRIPTION}

\QUESTBEGIN

\Task  \what~ Läs om krullparenteser och vanliga parenteser på stack overflow: \\ \href{http://stackoverflow.com/questions/4386127/what-is-the-formal-difference-in-scala-between-braces-and-parentheses-and-when}{stackoverflow.com/questions/4386127/what-is-the-formal-difference-in-scala-between-braces-and-parentheses-and-when} och prova själv i REPL hur du kan blanda dessa olika slags parenteser på olika vis.

\SOLUTION


\QUESTEND






\WHAT{Tips:}

\QUESTBEGIN

\Task  \what~ Gör jämförande studier av Scalas api-dokumentation för \code{ArrayBuffer}, \code{Array} och \code{Vector}. Ge exempel på metoder som finns på objekt av typen \code{Array} och \code{ArrayBuffer} men inte på objekt av typen \code{Vector}.  Kolla efter metoder som returnerar \code{Unit}. Prova några muterande metoder på \code{Array} och \code{ArrayBuffer} i REPL.

\SOLUTION


\QUESTEND






\WHAT{Tips:}

\QUESTBEGIN

\Task  \what~ Bygg vidare på koden nedan och gör ett Sten-Sax-Påse-spel\footnote{\href{https://sv.wikipedia.org/wiki/Sten,\_sax,\_p\%C3\%A5se}{sv.wikipedia.org/wiki/Sten,\_sax,\_p\%C3\%A5se}} som även meddelar vem som vinner. Koden fungerar att köra som den är, men funktionen \code{winnerMsg} är ej klar.  Du kan använda modulo-räkning med \code{%}-operatorn för att avgöra vem som vinner.

\begin{Code}[basicstyle=\ttfamily\footnotesize\selectfont]]
object Rock {
  import javax.swing.JOptionPane
  import JOptionPane.{showOptionDialog => optDlg}

  def inputOption(msg: String, opt: Vector[String]) =
    optDlg(null, msg, "Option", 0, 0, null, opt.toArray[Object], opt(0))

  def msg(s: String) = JOptionPane.showMessageDialog(null, s)

  val opt =  Vector("Sten", "Sax", "Påse")

  def userChoice = inputOption("Vad väljer du?", opt)

  def computerChoice = (math.random * 3).toInt

  def winnerMsg(user: Int, computer: Int) = "??? vann!"

  def main(args: Array[String]): Unit = {
    var keepPlaying = true
    while (keepPlaying) {
      val u = userChoice
      val c = computerChoice
      msg("Du valde " + opt(u) + "\n" +
          "Datorn valde " + opt(c) + "\n" +
          winnerMsg(u, c))
      if (u != c) keepPlaying = false
    }
  }
}
\end{Code}\SOLUTION


\QUESTEND

