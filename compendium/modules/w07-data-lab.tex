%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium2.tex


\Lab{\LabWeekSEVEN}
\begin{Goals}
\input{modules/w07-data-lab-goals.tex}
\end{Goals}

\begin{Preparations}
\item \DoExercise{\ExeWeekSEVEN}{07} 
%\item Läs om integrerade utvecklingsmiljöer i appendix \ref{appendix:ide}.
%\item Välj vilken IDE du vill använda på denna lab. %Om du inte vet vilken, välj \textbf{Eclipse} med ScalaIDE, som flest handledare känner väl till.
%\item Bekanta dig med utvecklingsmiljön genom att skapa ett nytt projekt och gör ett ''Hello World''-program.
%\item Ladda hem kursens \emph{workspace} enligt instruktioner i appendix \ref{subsubsection:download--import-workspace} och kontrollera så att du med \emph{Run} kan köra igång de båda ofärdiga \code{main}-metoderna i projektet \code{w04_pirates} inifrån din IDE. Om du inte får rätt på \emph{Run Configuration...} etc. så fråga någon om hjälp.
\item Läs igenom hela laborationen.
%\item {\"O}ppna Scala IDE i Eclipse enligt intruktionerna XX.
%\item Skapa ett projekt och skapa ett \code{object Hello} med en \code{main}-metod enligt XY.
%\item Skriv ut en h{\"a}lsning till terminalen med \code{println("...")} och testk{\"o}r programmet genom att markera filnamnet i projektmenyn och trycka p{\aa} den gr{\"o}na pilen. Kontrollera att h{\"a}lsningen skrivs ut!
\end{Preparations}


\subsection{Bakgrund}

Denna uppgift handlar om analys av naurligt språk \Eng{Natural Language Processing, NLP}. Språkanalys bygger ofta på statistik över förekomsten av olika ord i långa texter. Du ska skriva kod, som utifrån en lång text, till exempel en bok, kan hjälpa dig att svara på denna typ av frågor: 
\begin{itemize} 
\item Hur vanligt är ett visst ord i en given text?
\item Vilket är det vanligaste ordet som följer efter ett visst ord?
\item Hur kan man generera slumpmässiga ordsekvenser som liknar ordföljden i en given text?
\end{itemize}

\noindent\TODO{beskriv n-gram, bigram, frekvenstabell \code{Map[String, Int]}

\subsection{Obligatoriska uppgifter}


\Task \emph{Skapa frekvenstabeller}. Du ska implemenera en hjälpklass vid namn \code{FreqMapBuilder} som kan skapa frekvenstabeller av typen \code{Map[String, Int]}, där nyckel-värde-paren i tabellen anger antalet förekomster av en viss sträng. Utgå från koden nedan. %i figur \ref{data:fig-freqmap}. 
Klassen \code{FreqMapBuilder} ska ligga i ett paket som heter \code{nlp}.

\begin{figure}[H]
\scalainputlisting[numbers=left,basicstyle=\ttfamily\fontsize{10.5}{12.5}\selectfont]{../workspace/w07_words/src/main/scala/nlp/FreqMapBuilder.scala}
%\caption{Den ofärdiga klassen \code{FreqMapBuilder}.}
%\label{data:fig-freqmap}
\end{figure}

Det ska gå att använda \code{FreqMapBuilder} så här:
\begin{REPL}
scala> val fmb = FreqMapBuilder("hej", "på", "dej")
fmb: nlp.FreqMapBuilder = nlp.FreqMapBuilder@458f85ef

scala> fmb.add("hej")

scala> fmb.toMap
res0: Map[String,Int] = Map(på -> 1, hej -> 2, dej -> 1)
\end{REPL}

\noindent I kommande uppgifter ska du steg för steg implementera den ofärdiga klassen \code{Text}:%figur \ref{data:fig-text}.

\begin{figure}[H]
\scalainputlisting[numbers=left,basicstyle=\ttfamily\fontsize{10.5}{12.5}\selectfont]{../workspace/w07_words/src/main/scala/nlp/Text.scala}
%\caption{Den ofärdiga klassen \code{Text}.}
%\label{data:fig-text}
\end{figure}

\Task \emph{Dela upp en sträng i ord}. Medlemmen \code{words} ska innehålla en vektor med alla ord i \code{source}, utan andra tecken än bokstäver. 
Dela upp strängen \code{source} genom att i tur och ordnig göra följande:
\begin{enumerate}[nolistsep, noitemsep]
\item byta ut alla tecken för vilka \code{isWhitespace} är sant mot \code{' '}
\item byta ut alla tecken för vilka \code{isLetter} är falskt mot \code{' '} 
\item dela upp strängen i en array av strängar med \code{split(' ')}
\item filtrera bort alla tomma strängar
\item gör om alla bokstäver i alla strängar till små bokstäver 
\item gör om arrayen till en sekvens av typen \code{Vector[String]}.
\end{enumerate}

Testa så att \code{words}, och de värden som anänder \code{words}, fungerar i REPL:
\begin{REPL}
scala> val t = Text("Gurka är ingen tomat, men gurka är en grönsak.")

scala> t.words
res1: Vector[String] = 
  Vector(gurka, är, ingen, tomat, men, gurka, är, en, grönsak)

scala> t.distinct
res2: Vector[String] = 
  Vector(gurka, är, ingen, tomat, men, en, grönsak)

scala> t.wordSet
res3: Set[String] = Set(grönsak, är, gurka, men, ingen, tomat, en)

scala> t.wordsOfLength(5)
res4: Set[String] = Set(gurka, ingen, tomat)

\end{REPL}

\Task Implementera \code{wordFreq} med hjälp av \code{FreqMapBuilder}.


\Task \emph{n-gram.} 

\Subtask Implementera metoden \code{ngrams}. Tips: Undersök i REPL hur metoden \code{sliding} fungerar. Gör \code{toVector} på resultatet från \code{sliding}. 

\Subtask Implementera metoden \code{followFreq}. Utgå från nedan pseudokod: 
\begin{Code}
val result = scala.collection.mutable.Map.empty[String, FreqMapBuilder]
for ((key, next) <- bigrams) { 
  if (/* key finns redan definierad i result */)
    /* på "platsen" result(key): lägg till next i frekvenstabellen */
  else 
    /* lägg till (key -> ny frekvenstabell med next) i result*/ 
}
result.mapValues(_.toMap).toMap
\end{Code}
\Subtask \TODO{Obligatorisk eller frivillig???}\\ Lägg till metoden \code{mostCommonSeq} i klassen \code{Text} enligt: 
\begin{Code}
def mostCommonSeq(firstWord: String, n: Int): Vector[String] = ???
\end{Code}
Resultet ska var en sekvens med \code{n} ord. Sekvensen ska börja med \code{firstWord} och därefter följas av det ord som är vanligaste efterföljande ordet efter \code{firstWord}, och därpå det vanligaste efterföljande ordet efter det, etc.


\subsection{Kontrollfrågor}

\begin{enumerate}
\item I vilken ordning hamnar elementen om man anropoar \code{distinct} på en sekvens?

\item Om man itererar över en mängd, i vilken ordning kommer elementen? 

\item Ge exempel på när är det lämpligt att använda en mängd i stället för en sekvens av distinkta värden?

\item Är nycklarna i en nyckel-värde-tabell unika?

\item Är värdena i en nyckel-värde-tabell unika?

\item Oddput vill summera alla längderna på strängarna i en mängd och skriver:
\begin{REPL}
scala> Set("hej", "på", "dej").map(_.length).sum
res0: Int = 5
\end{REPL}
Varför blir det fel? Hur kan problemet åtgärdas?
\end{enumerate}

\subsection{Frivilliga uppgifter}

\Task
\begin{Code}
def randomWord: String = ???
\end{Code}

\Task
\begin{Code}
def randomSeq(firstWord: String, n: Int): Vector[String] = ???
\end{Code}

\Task Byt ut \code{FreqMapBuilder} mot befintliga samlingsmetoder enligt nedan.

\Subtask I metoden \code{wordFreq}, i stället för \code{FreqMapBuilder}, använd \code{groupBy} och \code{mapValues}. Undersök i REPL hur metoden \code{groupBy(x => x)} på en sekvens fungerar.

\Subtask I metoden \code{followsFreq}, använd \code{groupBy} och \code{mapValues}. Denna uppgift är ganksa knepig. Experimentera dig fram i REPL, och bygg upp en lösning stegvis. \emph{Tips:}
\begin{Code}
bigrams
  .groupBy(???)
  .mapValues(_.map(???).groupBy(???).mapValues(???))
\end{Code}





\Task Gör FreqMapBuilder generisk.












