
%!TEX encoding = UTF-8 Unicode
%!TEX root = ../exercises.tex

\ifPreSolution


\Exercise{\ExeWeekSIX}\label{exe:W06}

\begin{Goals}
\input{modules/w06-sequences-exercise-goals.tex}
\end{Goals}

\begin{Preparations}
\item \StudyTheory{06}
\end{Preparations}

\else

\ExerciseSolution{\ExeWeekSIX}

\fi


\BasicTasks %%%%%%%%%%%



\WHAT{Para ihop begrepp med beskrivning.}

\QUESTBEGIN

\Task \what

\vspace{1em}\noindent Koppla varje begrepp med den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}
\input{generated/quiz-w06-concepts-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w06-concepts-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND



\WHAT{Olika sekvenssamlingar.}

\QUESTBEGIN

\Task \what~Koppla varje sekvenssamling med den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-collections-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-collections-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND




\WHAT{Typer i hierarkin av sekvenssamlingar.}

\QUESTBEGIN

\Task \what~Koppla varje typ i hierarkin av sekvenssamling med den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}
\input{generated/quiz-w06-abstract-collections-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w06-abstract-collections-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND


\WHAT{Använda sekvenssamlingar.}

\QUESTBEGIN

\Task \what~Antag att nedan variabler finns synliga i aktuell namnrymd:
\begin{Code}
val xs: Vector[Int] = Vector(1, 2, 3)
val x: Int = 0
\end{Code}

\Subtask Koppla varje uttryck till vänster med motsvarande resultat till höger. Om du är osäker på resultatet, läs i snabbreferensen och testa i REPL. \\\emph{Tips: ''colon on the collection side''}.

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-methods-taskrows-generated.tex}
\end{ConceptConnections}

\Subtask Vid tre tillfällen blir det fel. Varför? Är det kompileringsfel eller exekveringsfel?



\begin{framed}
\noindent\emph{Tips inför fortsättningen:}
Scalas standardbibliotek har många användbara samlingar med enhetlig metoduppsättning. Om du lär dig de viktigaste samlingsmetoderna får du en kraftfull verktygslåda. Läs mer här:

    \begin{itemize}%[nolistsep]
      \item snabbreferensen (enda tentahjälpmedel): \\{\small\url{http://cs.lth.se/pgk/quickref}}
      \item översikt (av Prof. Martin Odersky, uppfinnare av Scala, m.fl.): \\
       {\small\url{http://docs.scala-lang.org/overviews/collections/introduction.html}}
      \item api-dokumentation:\\  {\small\url{https://www.scala-lang.org/api/current/scala/collection/}}
    \end{itemize}
\end{framed}



\SOLUTION

\TaskSolved \what

\SubtaskSolved

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-methods-solurows-generated.tex}
\end{ConceptConnections}

\SubtaskSolved

\noindent\renewcommand*{\arraystretch}{1.2}\begin{tabular}{p{5cm} l p{6cm}}

~\\ \emph{fel} & \emph{typ} & \emph{förklaring} \\\hline

\code|error: value +: is| \code|not a member of Int|
& kompileringsfel
& Operatorer som slutar med kolon är högerassociativa. Metodanropet \code|xs +: x| motsvarar med punktnotation \code|x.+:(xs)| och det finns ingen metod med namnet \code|+:| på heltal.\\\hline

\code|IndexOutOfBoundsException|
& körtidsfel & Det finns bara 3 element och index räknas från 0 i sekvenssamlingar.\\\hline

\code|error: value tail is | \code|not a member of Int|
& kompileringsfel
& Metoden \code|head| ger första elementet och heltal saknar sekvenssamlingsmetoden \code|tail|.\\\hline

\end{tabular}


\QUESTEND


\WHAT{Kopiering av sekvenser.}

\QUESTBEGIN

\Task \what~ %\code{map} \code{toArray} \code{copyToArray}
Klassen \code{Mutant} nedan kan användas för att skapa instanser med förändringsbara heltal.\footnote{Om den inbyggda klassen Int, i likhet med \code{Mutant}, knasigt nog  kunnat användas för att skapa förändringsbara instanser hade heltalsmatematiken i Scala omvandlats till ett skrämmande kaos...}

\noindent\begin{minipage}{0.6\textwidth}
\begin{Code}[basicstyle=\ttfamily\large\selectfont]
class Mutant(var int: Int = 0)
\end{Code}
\end{minipage}
\hfill\begin{minipage}{0.36\textwidth}
%https://www.1001freedownloads.com/free-clipart/mutant
\centering\includegraphics[width=3.6cm]{../img/mutant.png}
\captionof{figure}{En instans av klassen Mutant där \code{int} kanske är 5.}
%https://tex.stackexchange.com/questions/55337/how-to-use-figure-inside-a-minipage
\end{minipage}

\vspace{0.5em}\noindent Kör detta i REPL:
\begin{REPL}
scala> val xs = Vector.fill(3)(new Mutant)
scala> val ys = xs.toArray    // kopierar referenserna till ny Array
scala> val zs = xs.map(x => new Mutant(x.int)) // djupkopiera till ny Vector
scala> xs(0).int = 5
\end{REPL}
\Subtask Fyll i tabellen nedan genom att till höger skriva värdet av varje uttryck till vänster. Förklara vad som händer. \emph{Tips:} Metoden \code{eq} jämför alltid referenser (ej innehåll).

\renewcommand{\arraystretch}{2.0}
\vspace{1em}\noindent\begin{tabular}{@{} l | p{5.5cm}}\hline
\code|xs(0)         | & \\\hline
\code|ys(0).int| & \\\hline
\code|zs(0).int| & \\\hline
\code|xs(0) eq ys(0)| & \\\hline
\code|xs(0) eq zs(0)| & \\\hline
\code|(ys.toBuffer :+ new Mutant).apply(0).int| & \\\hline
\end{tabular}

\Subtask Implementera med hjälp av en \code{while}-sats funktionen \code{deepCopy} nedan som gör \emph{djup} kopiering, d.v.s skapar en ny array med nya, innehållskopierade mutanter.
\begin{Code}
def deepCopy(xs: Array[Mutant]): Array[Mutant] = ???
\end{Code}
Använd denna algoritm:

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{ ~En mutantarray $xs$}
 \Output{ ~En djup kopia av $xs$}
 $result \leftarrow$ en ny mutantarray med plats för lika många element som i $xs$\\
 $i \leftarrow 0$  \\
 \While{$i$ mindre än antalet element}{
  skapa en kopia av elementet $xs(i)$ och lägg kopian i $result$ på platsen $i$ \\
  öka $i$ med 1
 }
 \Return $result$
\end{algorithm}

\Subtask Testa att din funktion och kolla så att inga läskiga muteringar genom delade referenser går att göra, så som med \code|xs| och \code|ys| i första deluppgiften.

\Subtask Är det vanligt att man, för säkerhets skull, gör djupkopiering av alla element i oföränderliga samlingar som enbart innehåller oföränderliga element?

\SOLUTION

\TaskSolved \what~

\SubtaskSolved

\renewcommand{\arraystretch}{1.5}
\vspace{1em}\noindent\begin{tabular}{@{} p{0.4\textwidth} p{0.6\textwidth}}\hline
\code|xs(0)| & \code|Mutant@5ab7ef8a | varje instans har egen hexkod \\ \hline
\code|ys(0).int               | & \code|5 | eftersom \code|ys| innehåller samma instanser som \code|xs|\\ \hline
\code|zs(0).int               | & \code|0 | eftersom \code|!(xs(0) eq zs(0))| \\ \hline
\code|xs(0) eq ys(0)          | & \code|true |  eftersom samma instanser \\ \hline
\code|xs(0) eq zs(0)          | & \code|false | eftersom olika instanser\\ \hline
\code|(ys.toBuffer :+ |
\code|  new Mutant).apply(0).int| & \code|5 | eftersom kopian av typen \code|ArrayBuffer| har samma instans på första platsen som både \code|ys| och \code|xs|\\ \hline
\end{tabular}

\noindent Observera alltså att kopiering med \code{toArray}, \code{toVector}, \code{toBuffer}, etc. samt kopiering med \code{clone} \emph{inte är djup}, d.v.s det är bara elementreferenserna som förs över till ombandlad eller klonad samling och inga nya element skapas.

\SubtaskSolved
\begin{CodeSmall}
def deepCopy(xs: Array[Mutant]): Array[Mutant] = {
  val result = Array.ofDim[Mutant](xs.length) //fylld med null-referenser
  var i = 0
  while (i < xs.length) {
    result(i) = new Mutant(xs(i).int) //kopia med samma innehåll på samma plats
    i += 1
  }
  result
}
\end{CodeSmall}
Det går också bra att skapa resultatarrayen med \code{new Array[Mutant](xs.length)}.
Du kan också använda \code{size} i stället för \code{length}.

\SubtaskSolved
\begin{REPL}
scala> class Mutant(var int: Int = 0)
defined class Mutant

scala> :pa
def deepCopy(xs: Array[Mutant]): Array[Mutant] = {
  val result = Array.ofDim[Mutant](xs.length)
  var i = 0
  while (i < xs.length) {
    result(i) = new Mutant(xs(i).int)
    i += 1
  }
  result
}
scala> val xs = Array.fill(3)(new Mutant)
xs: Array[Mutant] = Array(Mutant@46a123e4, Mutant@44bc2449, Mutant@3c28e5b6)

scala> val ys = deepCopy(xs)
ys: Array[Mutant] = Array(Mutant@14b8a751, Mutant@7345f97d, Mutant@554566a8)

scala> xs(0).int = 5
xs(0).int: Int = 5

scala> ys(0).int
res0: Int = 0
\end{REPL}

\SubtaskSolved Nej, eftersom elementen inte kan förändras kan man utan problem dela referenser mellan samlingar. Det finns inte någon möjlighet att det kan ske förändringar som påverkar flera samlingar samtidigt.
Dock gör man vanligen (ofta tidsödande) djupkopieringar av samlingar med förändringsbara element för att kunna vara säker på att den ursprungliga samlingen inte förändras.

\QUESTEND



\ifPreSolution
\begin{framed}
\noindent\emph{Tips inför fortsättningen:} Ofta kan du lösa grundläggande delproblem med inbyggda samlingsmetoder ur standardbiblioteket. Till exempel kan ju kopieringen i \code{deepCopy} i föregående uppgift enkelt göras med hjälp av samlingsmetoden \code{map}.

Men det är mycket bra för din förståelse om du kan implementera grundläggande sekvensalgoritmer själv även om det normalt är bättre att använda färdiga, vältestade  metoder. I kommande uppgifter ska du därför göra egna implementationer av några sekvensalgoritmer som redan finns i standardbiblioteket.
\end{framed}
\fi



\WHAT{Uppdatering av sekvenser.}

\QUESTBEGIN

\Task \what~Deklarera dessa variabler i REPL:

\begin{Code}
val xs = (1 to 4).toVector
val buf = xs.toBuffer
\end{Code}

\Subtask Uttrycken till vänster evalueras uppifrån och ned. Para ihop med rätt resultat.

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-update-taskrows-generated.tex}
\end{ConceptConnections}
\emph{Tips:} Läs om metoderna i snabbreferensen och undersök i REPL. Exempel:
\begin{REPL}
scala> Vector(1,2,3,4).patch(from = 1, patch = Vector(0,0), replaced = 3)
res0: scala.collection.immutable.Vector[Int] = Vector(1, 0, 0)
\end{REPL}

\Subtask Implementera funktionen \code{insert} nedan med hjälp av sekvenssamlingsmetoden \code{patch}. \emph{Tips:} Ge argumentet \code{0} till parametern \code{replaced}.
\begin{Code}
/** Skapar kopia av xs men med elem insatt på plats pos. */
def insert(xs: Array[Int], elem: Int, pos: Int): Array[Int] = ???
\end{Code}

\Subtask Skriv pseduokod för en algoritm som implementerar \code{insert} med hjälp av \code{while}.

\Subtask Implementera \code{insert} enligt din pseudokod. Testa i REPL och se vad som händer om \code{pos} är negativ? Vad händer om \code{pos} är precis ett steg bortom sista platsen i \code{xs}? Vad händer om \code{pos} är flera steg bortom sista platsen?

\SOLUTION

\TaskSolved \what~

\SubtaskSolved

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-update-solurows-generated.tex}
\end{ConceptConnections}

\SubtaskSolved

\begin{Code}
def insert(xs: Array[Int], elem: Int, pos: Int): Array[Int] =
  xs.patch(from = pos, patch = Array(elem), replaced = 0)
\end{Code}

\SubtaskSolved Pseudokoden nedan är skriven så att den kompilerar fast den är ofärdig.
\begin{Code}
def insert(xs: Array[Int], elem: Int, pos: Int): Array[Int] = {
  val result = ??? /* ny array med plats för ett element mer än i xs */
  var i = 0
  while(???){/* kopiera elementen före plats pos och öka i */}
  if (i < result.length) /* lägg elem i result på plats i */
  while(???){/* kopiera över resten */}
  result
}
\end{Code}

\SubtaskSolved
\begin{Code}
def insert(xs: Array[Int], elem: Int, pos: Int): Array[Int] = {
  val result = new Array[Int](xs.length + 1)
  var i = 0
  while (i < pos && i < xs.length) { result(i) = xs(i); i += 1}
  if (i < result.length) { result(i) = elem; i += 1 }
  while (i < result.length && i > 0) { result(i) = xs(i - 1); i += 1}
  result
}
\end{Code}
\begin{REPL}
scala> insert(Array(1,2),0,pos = -1)
res2: Array[Int] = Array(0, 1, 2)

scala> insert(Array(1,2),0,pos = 0)
res3: Array[Int] = Array(0, 1, 2)

scala> insert(Array(1,2),0,pos = 1)
res4: Array[Int] = Array(1, 0, 2)

scala> insert(Array(1,2),0,pos = 2)
res5: Array[Int] = Array(1, 2, 0)

scala> insert(Array(1,2),0,pos = 42)
res7: Array[Int] = Array(1, 2, 0)
\end{REPL}

\QUESTEND




\ifPreSolution
\begin{framed}
\noindent\emph{Tips inför fortsättningen:} Det är inte lätt att få rätt på alla specialfall även i små algoritmer så som \code{insert} ovan. Det är därför viktigt att noga tänka igenom sin sekvensalgoritm med avseende på typiska special. Använd denna checklista:
\begin{enumerate}[noitemsep]
  \item Vad händer om sekvensen är tom?
  \item Fungerar det för exakt ett element?
  \item Kan index bli negativt?
  \item Kan index bli mer än längden minus ett?
  \item Kan det bli en oändlig loop, t.ex. p.g.a. saknad loopvariabeluppräkning?
\end{enumerate}
Ibland vill man att vettiga undantag ska kastas vid ogiltig indata eller andra feltillstånd och då är \code{require} eller \code{assert} bra att använda. I andra fall vill man att resultatet t.ex. ska bli en tom sekvenssamling om indata är ogiltigt. Sådana beteenden behöver dokumenteras så att andra som använder dina algoritmer (eller du själv efter att du glömt hur det var) förstår vad som händer i olika fall.


\end{framed}
\fi




\WHAT{Linjärsökning enligt olika sökkriterier.}

\QUESTBEGIN

\Task \what~Linjärsökning innebär att man letar tills man hittar det man söker efter i en sekvens. Detta delproblem återkommer ofta! Vanligen börjar linjärsökning från början och håller på tills man hittar något element som uppfyller kriteriet. Beroende på vad som finns i sekvensen och hur kriteriet ser ut kan det hända att man måste gå igenom alla element utan hitta det som eftersöks.

\Subtask Linjärsökning med inbyggda sekvenssamlingsmetoder.
\begin{Code}
val xs = ((1 to 5).reverse ++ (0 to 5)).toVector
\end{Code}
Deklarera ovan variabel i REPL och para ihop uttrycken nedan med rätt värden. Förklara vad som händer.

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-find-taskrows-generated.tex}
\end{ConceptConnections}

\Subtask Implementera linjärsökning i strängvektor med strängpredikat.
\begin{Code}
/** Returns first index where p is true. Returns -1 if not found. */
def indexOf(xs: Vector[String], p: String => Boolean): Int = ???
\end{Code}
Ett strängpredikat \code{p: String => Boolean} är en funktion som tar en sträng som indata och ger ett booleskt värde som resultat. Implementera \code{indexOf} med hjälp av en \code{while}-sats. Du kan t.ex. använda en lokal boolesk variabel \code{found} för att hålla reda på om du har hittat det som eftersöks enligt predikatet.

När element som uppfyller predikatet saknas måste man bestämma vad som ska hända. Kravet på din implementation i detta fall ges av dokumentationskommentaren ovan.

Din funktion ska fungera enligt nedan:
\begin{REPL}
scala> val xs = Vector("hej","på","dej")

scala> indexOf(xs, _.contains('p'))
res0: Int = 1

scala> indexOf(xs, _.contains('q'))
res1: Int = -1

scala> indexOf(Vector(), _.contains('q'))
res2: Int = -1

scala> indexOf(Vector("q"), _.length == 1)
res3: Int = 0
\end{REPL}

\SOLUTION

\TaskSolved \what~

\SubtaskSolved

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-find-solurows-generated.tex}
\end{ConceptConnections}

\SubtaskSolved Med en boolesk variabel \code{found}:

\begin{Code}
def indexOf(xs: Vector[String], p: String => Boolean): Int = {
  var found = false
  var i = 0
  while (i < xs.length && !found) {
      found = p(xs(i))
      i += 1
  }
  if (found) i - 1 else -1
}
\end{Code}
Eller utan \code{found}:
\begin{Code}
def indexOf(xs: Vector[String], p: String => Boolean): Int = {
  var i = 0
  while (i < xs.length && !p(xs(i))) i += 1
  if (i == xs.length) -1 else i
}
\end{Code}
Eller så kan man börja bakifrån. Lösningen nedan är nog enklare att fatta (?) och definitivt mer koncis, men uppfyller inte kravet att returnera index för \emph{första} förekomsten som det står i uppgiften. Men om vi relaxar kravet till att vår funktion ska returnera \emph{något} index där predikatet gäller så funkar nedan fint:
\begin{Code}
def indexOf(xs: Vector[String], p: String => Boolean): Int = {
  var i = xs.length - 1
  while (i >= 0 && !p(xs(i))) i -= 1
  i
}
\end{Code}
Eller så kan man göra på flera andra sätt. När du ska implementera algoritmer, både på programmeringstentan och i yrkeslivet som systemutvecklare, finns det ofta många olika sätt att lösa uppgiften på som har olika egenskaper, fördelar och nackdelar. Det viktiga är att lösningen fungerar så gott det går enligt kraven, att koden är begriplig för människor och att implementationen inte är så ineffektiv att användarna tröttnar i sin väntan på resultatet...

\QUESTEND




\WHAT{Labbförberedelse: Implementera heltalsregistrering i Array.}

\QUESTBEGIN

\Task \what~Registrering innebär att man räknar antalet förekomster av olika värden. Varje gång ett nytt värde förekommer behöver vi räkna upp en frekvensräknare. Det behövs en räknare för varje värde som ska registreras. Vi ska fortsätta räkna ända tills alla värden är registrerade.

På veckans laboration ska du registrera förekomsten av olika kortkombinationer i kortspelet poker. I denna övning ska du som träning inför laborationen lösa ett liknande registreringsproblem:  frekvensanalys av många tärningskast. Vid tärningsregistrering behövs sex olika räknare. Man kan med fördel då använda en sekvenssamling med plats för sex heltal. Man kan t.ex. låta  plats \code{0} håller reda på antalet ettor, plats \code{1} hålla reda på antalet tvåor, etc.

\Subtask Implementera nedan algoritm enligt pseudokoden:
\begin{Code}
def registreraTärningskast(xs: Seq[Int]): Vector[Int] = {
  val result = ??? /* Array med 6 nollor */
  xs.foreach{ x =>
    require(x >= 1 && x <= 6, "tärninskast ska vara mellan 1 & 6")
    ??? /* räkna förekomsten av x */
  }
  result.toVector
}
\end{Code}

\Subtask Använd funktionen \code{kasta} nedan när du testar din registreringsalgoritm med en sekvenssamling innehållande minst $1000$ tärningskast.
\begin{Code}
def kasta(n: Int) = Vector.fill(n)(util.Random.nextInt(6) + 1)
\end{Code}

\SOLUTION

\TaskSolved \what~

\SubtaskSolved
\begin{Code}
def registreraTärningskast(xs: Seq[Int]): Vector[Int] = {
  val result = Array.fill(6)(0)
  xs.foreach{ x =>
    require(x >= 1 && x <= 6, "tärninskast ska vara mellan 1 & 6")
    result(x - 1) += 1
  }
  result.toVector
}
\end{Code}

\SubtaskSolved
\begin{REPL}
scala> registreraTärningskast(kasta(1000))
res0: Vector[Int] = Vector(171, 163, 166, 152, 184, 164)

scala> registreraTärningskast(kasta(1000))
res1: Vector[Int] = Vector(163, 161, 158, 174, 161, 183)
\end{REPL}

\QUESTEND




\WHAT{Inbyggda metoder för sortering.}

\QUESTBEGIN

\Task \what~Det finns fler olika sätt att ordna sekvenser efter olika kriterier. För  grundtyperna \code{Int}, \code{Double}, \code{String}, etc., finns inbyggda ordningar som gör att sekvenssamlingsmetoden \code{sorted} fungerar utan vidare argument (om du är nöjd med den inbyggda ordningsdefinitionen). Det finns också metoderna \code{sortBy} och \code{sortWith} om du vill ordna en sekvens med element av någon grundtyp efter egna ordningsdefinitioner eller om du har egna klasser i din sekvens.
\begin{Code}
val xs = Vector(1,2,1,3,-1)
val ys = Vector("abra", "ka", "dabra").map(_.reverse)
val zs = Vector('a', 'A', 'b', 'c').sorted

case class Person(förnamn: String, efternamn: String)

val ps = Vector(Person("Kim","Ung"), Person("kamrat", "Clementin"))
\end{Code}
Deklarera ovan i REPL och para ihop uttryck nedan med rätt resultat.
\\\emph{Tips:} Stora bokstäver sorteras före små bokstäver i den inbyggda ordningen för grundtyperna \code{String} och \code{Char}. Dessutom har svenska tecken knasig ordning.\footnote{En kvarleva från föråldrade teckenkodningsstandarder:    \url{https://sv.wikipedia.org/wiki/ASCII}}
\\Läs om sorteringsmetoderna i snabbreferensen och prova i REPL.

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-sort-taskrows-generated.tex}
\end{ConceptConnections}
Vi ska senare i kursen implementera egna sorteringsalgoritmer som träning, men i normala fall använder man inbyggda sorteringar som är effektiva och vältestade. Dock är det inte ovanligt att man vill definiera egna ordningar för egna klasser, vilket vi ska undersöka senare i kursen.

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w06-seq-sort-solurows-generated.tex}
\end{ConceptConnections}
Det blir fel i uttrycket ovan som försöker sortera en sekvens med instanser av \code{Person} direkt med metoden \code{sorted}:
\begin{REPL}
scala> ps.sorted
<console>:13: error: No implicit Ordering defined for Person.
\end{REPL}
Det blir fel eftersom kompilatorn inte hittar någon ordningsdefinition för dina egna klasser. Senare i kursen ska vi se hur vi kan skapa egna ordningar om man vill få \code{sorted} att fungera på sekvenser med instanser av egna klasser, men ofta räcker det fint med \code{sortBy} och \code{sortWith}.
\QUESTEND


\WHAT{Inbyggd metod för blandning.}

\QUESTBEGIN

\Task \what~På veckans laboration ska du implementera en egen blandningsalgoritm och använda den för att blanda en kortlek. Det finns redan en inbygg metod \code{shuffle} i singelobjektet \code{Random} i paketet \code{scala.util}.

\Subtask Sök upp dokumentationen för \code{Random.shuffle} och studera funktionshuvudet. Det står en hel del invecklade saker om \code{CanBuildFrom} etc. Detta smarta krångel, som vi inte går närmare in på i denna kurs, är till för att metoden ska kunna returnera lämplig typ av samling. När du ser ett sådant funktionshuvud kan du anta att metoden fungerar fint med flera olika typer av lämpliga samlingar i Scalas standardbibliotek.

Klicka på \code{shuffle}-dokumentationen så att du ser hela texten. Vad säger dokumentationen om resultatet? Är det blandning på plats eller blandning till ny samling?

\Subtask Prova upprepade blandningar av olika typer av sekvenser med olika typer av element i REPL.

\SOLUTION

\TaskSolved \what~

\SubtaskSolved \code{Random.shuffle} returnerar en ny blandad sekvenssamling av samma typ. Ordningen i den ursprungliga samlingen påverkas inte.

\SubtaskSolved Exempel på användning av \code{random.shuffle}:
\begin{REPL}
scala> import scala.util.Random

scala> val xs = Vector("Sten", "Sax", "Påse")

scala> (1 to 10).foreach(_ => println(Random.shuffle(xs).mkString(" ")))
Sax Påse Sten
Sten Påse Sax
Sten Sax Påse
Sten Sax Påse
Sten Påse Sax
Sten Påse Sax
Sax Sten Påse
Sten Påse Sax
Sax Påse Sten
Sax Påse Sten

scala> scala> (1 to 5).map(_ => Random.shuffle(1 to 6))
res1: IndexedSeq[IndexedSeq[Int]] =
  Vector(Vector(5, 2, 1, 4, 3, 6), Vector(6, 5, 4, 2, 1, 3),
  Vector(3, 1, 4, 6, 5, 2), Vector(3, 2, 6, 5, 1, 4),
  Vector(5, 3, 4, 6, 1, 2))

scala> (1 to 1000).map(_ => Random.shuffle(1 to 6).head).count(_ == 6)
res2: Int = 168
\end{REPL}


\QUESTEND



\clearpage

\ExtraTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\WHAT{Registrering av booleska värden. Singla slant.}

\QUESTBEGIN

\Task \what~

\Subtask Implementera en funktion som registrerar många slantsinglingar enligt nedan funktionshuvud. Indata är en sekvens av booleska värden där krona kodas som \code{true} och klave kodas som \code{false}. För registreringen ska du använda en lokal \code{Array[Int]}. I resultatet ska antalet utfall av \code{krona} ligga på första platsen i 2-tupeln medan på andra platsen ska antalet utfall av \code{klave} ligga.

\begin{Code}
def registerCoinFlips(xs: Seq[Boolean]): (Int, Int) = ???
\end{Code}

\Subtask Skapa en funktion \code{flips(n)} som ger en boolesk \code{Vector} med $n$ stycken slantsinglingar och använd den när du testar din slantsinglingsregistreringsalgoritm.

\SOLUTION

\TaskSolved \what~

\SubtaskSolved
\begin{Code}
def registerCoinFlips(xs: Seq[Boolean]): (Int, Int) = {
  val result = Array.fill(2)(0)
  xs.foreach(x => if (x) result(0) += 1 else result(1) += 1)
  (result(0), result(1))
}
\end{Code}

\SubtaskSolved

\QUESTEND


\WHAT{Kopiering och tillägg på slutet.}

\QUESTBEGIN

\Task \what~
Implementera funktionen \code{copyAppend} som implementerar nedan algoritm, \emph{efter} att du rättat de \textbf{\color{red}{två buggarna}} i algoritmens while-loop:

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{Heltalsarray $xs$ och heltalet $x$}
 \Output{En ny heltalsarray som som är en kopia av $xs$ men med $x$ tillagt på slutet som extra element.}
 $ys \leftarrow$ en ny array med plats för ett element mer än i $xs$\\
 $i \leftarrow 0$  \\
 \While{$i \leq xs.length$}{
  $ys(i) \leftarrow xs(i)$
 }
lägg $x$ på sista platsen i $ys$
\end{algorithm}

\noindent Granska din kod enligt checklistan i tidigare tipsruta. Testa din funktion för de olika fallen: tom sekvens, sekvens med exakt ett element, sekvens med många element.


\SOLUTION

\TaskSolved \what~

\begin{Code}
def copyAppend(xs: Array[Int], x: Int): Array[Int] = {
  val ys = new Array[Int](xs.length + 1)
  var i = 0
  while(i < xs.length) {
    ys(i) = xs(i)
    i += 1
  }
  ys(xs.length) = x
  ys
}
\end{Code}
De två buggarna i algoritmen finns (1) i villkoret som ska vara strikt mindre än och (2) inne i loopen där uppräkningen av loppvariabeln saknas.

\QUESTEND



\WHAT{Välja sekvenssamling.}

\QUESTBEGIN

\Task  \what~Vilken sekvenssamling är lämpligast i respektive situation nedan? Välj mellan \code{Vector}, \code{Array}, \code{ArrayBuffer} och \code{ListBuffer}.

\Subtask Ditt program ska innehålla en sekvens av objekt med data om alla ca $10^7$ medborgare i Sverige. Efter noggranna mätningar visar det sig att tillägg av enstaka objekt på godtyckliga ställen i sekvensen är en flaskhals.

\Subtask Ditt program ska innehålla en förändringsbar sekvens av objekt med data om användare av ett asocialt medium som lagras i den ordning användarna ansluter sig. Det visar sig att det ofta sker förändringar i början av sekvensen. Indexering mitt i sekvensen är mycket ovanliga.

\Subtask Samma förutsättningar som i föregående situation förutom att indexering på godtycklig position istället är mycket vanligt och måste gå snabbt.

\Subtask Ditt program innehåller en sekvens av många osorterade heltal som ska läsas in från fil och sorteras på plats i minnet. Det första talet i filen anger antalet heltal.

\Subtask Ditt program innehåller en sekvens av ett känt antal oföränderliga objekt med data om genomförda banktransaktioner. Sekvensen ska bearbetas parallellt med algortimer som gör indexering på godtyckliga positioner.

\SOLUTION


\TaskSolved \what


\SubtaskSolved  \code{Vector} som är bra på godtyckliga förändringar.

\SubtaskSolved  \code{ListBuffer} som är snabb på fröändringar i början av sekvensen.

\SubtaskSolved  \code{ArrayBuffer} som är snabb på fröändringar i början av sekvensen.

\SubtaskSolved  \code{Array} eftersom sortering på plats efterfrågas och antalet element är känt från början.

\SubtaskSolved  \code{Vector} eftersom ofränderlighet efterfrågas och också underlättar stort för att förhindra buggar vid parallella beräkningar.

\QUESTEND



\WHAT{Algoritm: SEQ-REVERSE-COPY.}

\QUESTBEGIN

\Task  \what~  Implementera nedan algoritm i en funktion med namnet \code{seqReverseCopy}:

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{Heltalsarray $xs$}
 \Output{En ny heltalsarray med elementen i $xs$ i omvänd ordning.}
 $n \leftarrow$ antalet element i $xs$ \\
 $ys \leftarrow$ en ny heltalsarray med plats för $n$ element\\
 $i \leftarrow 0$  \\
 \While{$i < n$}{
  $ys(n - i - 1) \leftarrow xs(i)$ \\
  $i \leftarrow i + 1$
 }
 \Return $ys$
\end{algorithm}

\Subtask Använd en \code{while}-sats på samma sätt som i algoritmen. Prova din implementation i REPL och kolla så att den fungerar i olika fall.

\Subtask Gör en ny implementation som i stället använder en \code{for}-sats som börjar bakifrån. Kör din implementation i REPL och kolla så att den fungerar i olika fall.

\SOLUTION

\TaskSolved \what

\SubtaskSolved  \begin{Code}
def seqReverseCopy(xs: Array[Int]): Array[Int] = {
  val n = xs.length
  val ys = new Array[Int](n)
  var i = 0
  while(i < n) {
    ys(n-i-1) = xs(i)
    i += 1
  }
  ys
}
\end{Code}

\SubtaskSolved  \begin{Code}
def seqReverseCopy(xs: Array[Int]): Array[Int] = {
  val n = xs.length
  val ys = new Array[Int](n)
  for(i <- n - 1 to 0 by -1) ys(n - i - 1) = xs(i)
  ys
}
\end{Code}


\QUESTEND







\clearpage

\AdvancedTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\WHAT{Variabelt antal argument.}

\QUESTBEGIN

\Task  \what~  Det går att deklarera en funktion som tar en argumentsekvens av godtycklig längd, ä.k. \emph{varargs}. Syntaxen består av en asterisk \code{*} efter typen. Funktion sägs ha repeterade parametrar \Eng{repeated parameters}. I funktionskroppen får man tillgång till argumenten i en sekvenssamling. Argumenten anges godtyckligt många med komma emellan. Exempel:
\begin{Code}
/** Ger en vektor med stränglängder för godtyckligt antal strängar. */
def stringSizes(xs: String*): Vector[Int] = xs.map(_.size).toVector
\end{Code}

\Subtask Deklarera och använd \code{stringSizes} i REPL. Vad händer om du anropar \code{stringSizes} med en tom argumentlista?

\Subtask Det händer ibland att man redan har en sekvenssamling, t.ex. \code{xs}, och vill skicka med varje element som argument till en varargs-funktion. Syntaxen för detta är \code{xs: _* } vilket gör att kompilatorn omvandlar sekvenssamlingen till en argumentsekvens av rätt typ.

Prova denna syntax genom att ge en \code{xs} av typen \code{Vector[String]} som argument till \code{stringSizes}. Fungerar det även om \code{xs} är en sekvens av längden 0?

\SOLUTION

\TaskSolved \what

\SubtaskSolved

\begin{REPL}
scala> def stringSizes(xs: String*): Vector[Int] = xs.map(_.size).toVector
scala> stringSizes("hej")
res83: Vector[Int] = Vector(3)

scala> stringSizes("hej", "på", "dej", "")
res84: Vector[Int] = Vector(3, 2, 3, 0)

scala> stringSizes()
res85: Vector[Int] = Vector()
\end{REPL}

\noindent Anrop med tom argumentlista ger en tom heltalssekvens.

\SubtaskSolved

\begin{REPL}
scala> val xs = Vector("hej","på","dej", "")

scala> stringSizes(xs: _*)
res86: Vector[Int] = Vector(3, 2, 3, 0)

scala> stringSizes(Vector(): _*)
res87: Vector[Int] = Vector()
\end{REPL}
Ja, det funkar fint med tom sekvens.



\QUESTEND



\WHAT{Fibonacci-sekvens med ListBuffer.}

\QUESTBEGIN

\Task  \what~ Samlingen \code{ListBuffer} är en förändrinsbar sekvens som är snabb och minnessnål vid tillägg i början \Eng{prepend}. Undersök vad som händer här:
\begin{REPL}
scala> val xs = scala.collection.mutable.ListBuffer.empty[Int]
scala> xs.prepend(1, 1)
scala> while (xs.head < 100) {xs.prepend(xs.take(2).sum); println(xs)}
scala> xs.reverse.toList
\end{REPL}
Talen i sekvensen som produceras på rad 4 ovan kallas Fibonaccital\footnote{\href{https://sv.wikipedia.org/wiki/Fibonaccital}{sv.wikipedia.org/wiki/Fibonaccital}} och blir snabbt mycket stora.

\Subtask Definera och testa följande funktion. Den ska internt använda förändringsbara \code{ListBuffer} men returnera en sekvens av oföränderliga \code{List}.

\begin{Code}
/** Ger en lista med tal ur Fibonacci-sekvensen 1, 1, 2, 3, 5, 8 ...
  * där det största talet är mindre än max. */
def fib(max: Long): List[Long]  = ???
\end{Code}


\Subtask
Hur lång ska en Fibonacci-sekvens vara för att det sista elementet ska vara så nära \code{Int.MaxValue} som möjligt?

\SOLUTION


\TaskSolved \what


\SubtaskSolved

\begin{Code}
def fib(max: Long): List[Long] = {
  val xs = scala.collection.mutable.ListBuffer.empty[Long]
  xs.prepend(1, 1)
  while (xs.head < max) xs.prepend(xs.take(2).sum)
  xs.reverse.drop(1).toList
}

\end{Code}

\SubtaskSolved

\begin{REPL}
scala> fib(Int.MaxValue).size
res0: Int = 46
\end{REPL}

\QUESTEND



\WHAT{Algoritm: SEQ-REVERSE-IN-PLACE.}

\QUESTBEGIN

\Task  \what~  Strängar av typen \code{String} är oföränderliga. Vill man ändra i en sträng utan att skapa en ny kopia kan man använda en \code{StringBuilder} enligt nedan algoritm som vänder bak-och-fram på en sträng. Sök och läs om \code{scala.collection.mutable.StringBuilder} och \TODO

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{En sträng $s$ av typen \texttt{String}}
 \Output{En ny sträng av typen \texttt{String}}
 $sb \leftarrow$ en ny \texttt{StringBuilder} som innehåller $s$ \\
 $n \leftarrow$ antalet tecken i $s$\\
 \For{$i \leftarrow 0$ \KwTo $\frac{n}{2} - 1$}{
  $temp \leftarrow sb(i)$ \\
  $sb(i) \leftarrow sb(n - i - 1)$ \\
  $sb(n - i - 1) \leftarrow temp$ \\
 }
 \Return $sb$ omvandlad till en \texttt{String}
\end{algorithm}

\Subtask Implementera algoritmen ovan i en funktion med signaturen: \\
 \code{def reverseString(s: String): String}

\Subtask Använd din funktion \code{reverseString} från föregående deluppgift i en ny funktion med signaturen:\\
 \code{def isPalindrome(s: String): Boolean} \\ som avgör om en sträng är en palindrom.\footnote{\href{https://sv.wikipedia.org/wiki/Palindrom}{sv.wikipedia.org/wiki/Palindrom}}

\Subtask\Pen Man kan med en \code{while}-sats och indexering direkt i en \code{String} avgöra om en sträng är en palindrom utan att kopiera den till en \code{StringBuilder}. Implementera en ny variant av \code{isPalindrome} som använder denna metod. Skriv först algoritmen på papper i pseudo-kod.

\SOLUTION

\TaskSolved \what

\SubtaskSolved  \begin{Code}
def reverseString(s: String): String = {
  val sb = new StringBuilder(s)
  val n = sb.length
  for (i <- 0 until n / 2) {
    val temp = sb(i)
    sb(i) = sb(n - i - 1)
    sb(n - i - 1) = temp
  }
  sb.toString
}
\end{Code}

\SubtaskSolved  \begin{Code}
def isPalindrome(s: String): Boolean = {s == reverseString(s)}
\end{Code}

\SubtaskSolved  \begin{Code}
def isPalindrome(s: String): Boolean = {
  val n = s.length
  var foundDiff = false
  var i = 0
  while (i < n/2 && !foundDiff)  {
    foundDiff = s(i) != s(n - i - 1)
    i += 1
  }
  !foundDiff
}
\end{Code}

\QUESTEND







\subsection{\TODO Värdera nedan gamla uppgifter}






%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 6








%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 7




\WHAT{Algoritm: SEQ-REGISTER.}

\QUESTBEGIN

\Task \label{task:seq-reg} \what~   Algoritmer för registrering löser problemet att räkna förekomst av olika saker, till exempel antalet tärningskast som gav en sexa. Antag att vi har följande vektor \code{xs} som representerar 13 st tärningskast:
\begin{REPL}
scala> val xs = Vector(5, 3, 1, 6, 1, 3, 5, 1, 1, 6, 3, 2, 6)
\end{REPL}
\Subtask Använd metoderna \code{filter} och \code{size} på \code{xs} för att filtrera ut alla 6:or och räkna hur många de är.

\Subtask Använd metoderna \code{filter} och \code{size} på \code{xs} för att filtrera ut alla jämna kast och räkna hur många de är.

\Subtask Metoden \code{groupBy} på en samling tar en funktion \code{f} som parameter och skapar en ny \code{Map} med nycklar \code{k} som är associerade till samlingar som utgör grupper av värden där
\code{f(x) == k}.  Vad händer här:
\begin{REPL}
scala> xs.groupBy(x => x % 2)
scala> xs.groupBy(_ % 2)
scala> xs.groupBy(_ % 3)
scala> xs.groupBy(_ % 3).foreach(println)
scala> val freqEvenOdd = xs.groupBy(_ % 2).map(p => (p._1, p._2.size))
scala> val nEven = freqEvenOdd(0)
scala> val nOdd = freqEvenOdd(1)
\end{REPL}
\Subtask Använd metoden \code{groupBy} på \code{xs} med den s.k. identitetsfunktionen \code{i => i} som returnerar sitt eget argument. Vad händer?

\Subtask Definiera en \code{val freq: Map[Int, Int]} som räknar antalet olika tärningsutfall i \code{xs}. Använd metoden \code{groupBy} på \code{xs} med identitetsfunktionen följt av en \code{map} med funktionen \code{p => (p._1, p._2.size)}.

\Subtask Du ska nu själv implementera en registreringsalgoritm. Skriv en funktion:
\begin{Code}
def tärningsRegistrering(xs: Array[Int]): Array[Int] = ???
\end{Code}
som implementerar nedan algoritm (som alltså inte använder \code{groupBy} eller andra färdiga metoder på samlingar förutom \code{size} och \code{apply}).

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{En array $xs$ med heltal mellan 1 och 6 som representerar utfall av många tärningskast.}
 \Output{En array $f$ med 7 st element där $f(0)$ innehåller totala antalet kast, $f(1)$ anger antalet ettor, $f(2)$ antalet tvåor, etc. till och med $f(6)$ som anger antalet sexor.}
 $f \leftarrow$ en ny array med $7$ element där alla element initaliseras till 0.\\
 $f(0) \leftarrow$ antalet element i $xs$ \\
 $i \leftarrow 0$  \\
 \While{$i < f(0)$}{
  $f(xs(i)) \leftarrow f(xs(i)) + 1$ \\
  $i \leftarrow i + 1$
 }
 \Return $f$
\end{algorithm}

Testa din funktion med nedan funktionsanrop:
\begin{REPL}
scala> tärningsRegistrering(Array.fill(1000)((math.random * 6).toInt + 1))
res12: Array[Int] = Array(1000, 174, 174, 167, 171, 145, 169)
\end{REPL}

\SOLUTION


\TaskSolved \what


\SubtaskSolved  \code{xs.filter(_ == 6).size}

\SubtaskSolved  \code{xs.filter(_ % 2 == 0).size}

\SubtaskSolved  \begin{REPL}
scala.collection.immutable.Map[Int,scala.collection.immutable.Vector[Int]] =
	Map(1 -> Vector(5, 3, 1, 1, 3, 5, 1, 1, 3), 0 -> Vector(6, 6, 2, 6))
scala.collection.immutable.Map[Int,scala.collection.immutable.Vector[Int]] =
	Map(1 -> Vector(5, 3, 1, 1, 3, 5, 1, 1, 3), 0 -> Vector(6, 6, 2, 6))
scala.collection.immutable.Map[Int,scala.collection.immutable.Vector[Int]] =
	Map(2 -> Vector(5, 5, 2), 1 -> Vector(1, 1, 1, 1), 0 -> Vector(3, 6, 3, 6, 3, 6))
(2,Vector(5, 5, 2))
(1,Vector(1, 1, 1, 1))
(0,Vector(3, 6, 3, 6, 3, 6))
freqEvenOdd: scala.collection.immutable.Map[Int,Int] = Map(1 -> 9, 0 -> 4)
nEven: Int = 4
nOdd: Int = 9
\end{REPL}

\SubtaskSolved  \code{xs.groupBy(i => i)} skapar en map där nycklarna är alla unika element och värdena är av samma värde som respektive nyckel.

\SubtaskSolved  \code{val freq: Map[Int, Int] = xs.groupBy(i => i).map(p => (p._1, p._2.size))}

\SubtaskSolved  \begin{Code}
def tärningsRegistrering(xs: Array[Int]): Array[Int] = {
  val f = Array.fill(7)(0)
  f(0) = xs.size
  var i = 0
  while (i < f(0)) {
    f(xs(i)) += 1
    i += 1
  }
  f
}
\end{Code}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 8




\WHAT{Algoritm: SEQ-REMOVE-COPY.}

\QUESTBEGIN

\Task  \what~  Ibland vill man kopiera alla element till en ny \code{Array} \emph{utom} ett element på en viss plats \code{pos}.

\Subtask\Pen Skriv algoritmen SEQ-REMOVE-COPY i pseudokod med penna på papper.

\Subtask Implementera algoritmen SEQ-REMOVE-COPY i en funktion med denna signatur:
\begin{Code}
def removeCopy(xs: Array[Int], pos: Int): Array[Int]
\end{Code}

\SOLUTION


\TaskSolved \what


\SubtaskSolved

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{En sekvens $xs$ av typen \texttt{Array[Int]} och $pos$}
 \Output{En ny sekvens av typen \texttt{Array[Int]} som är en kopia av $xs$ fast med elementet på plats $pos$ borttaget}
 $n \leftarrow$ antalet element $xs$\\
 $ys \leftarrow$ en ny \texttt{Array[Int]} med plats för $n-1$ element \\
 \For{$i \leftarrow 0$ \KwTo $pos - 1$}{
  $ys(i) \leftarrow xs(i)$
 }
 $ys(pos) \leftarrow x$ \\
 \For{$i \leftarrow pos+1$ \KwTo $n - 1$}{
  $ys(i - 1) \leftarrow xs(i)$
 }
 \Return $ys$
\end{algorithm}

\SubtaskSolved  \begin{Code}
def removeCopy(xs: Array[Int], pos: Int): Array[Int] = {
  val n = xs.size
  val ys = Array.fill(n - 1)(0)
  for (i <- 0 until pos) ys(i) = xs(i)
  for (i <- pos+1 until n) ys(i - 1) = xs(i)
  ys
}
\end{Code}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 9




\WHAT{Algoritm: SEQ-REMOVE.}

\QUESTBEGIN

\Task  \what~  Ibland vill man ta bort ett element på en viss position i en befintlig \code{Array} utan att kopiera alla element till en ny \code{Array}. Ett sätt att göra detta är att flytta alla efterföljande element ett steg mot lägre index och låta sista platsen bli 0.

\Subtask\Pen Skriv algoritmen SEQ-REMOVE i pseudokod med penna på papper.

\Subtask Implementera algoritmen SEQ-REMOVE i en funktion med denna signatur:
\begin{Code}
def remove(xs: Array[Int], pos: Int): Unit
\end{Code}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5


\SOLUTION


\TaskSolved \what


\SubtaskSolved

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{En sekvens $xs$ av typen \texttt{Array[Int]} och $pos$}
 \Output{En uppdaterad sekvens av $xs$ där elementet på plats $pos$ tagits bort och efterföljande element flyttas ett steg mot lägre index med ett sista elementet som är $0$}
 $n \leftarrow$ antalet element $xs$\\
 \For{$i \leftarrow pos+1$ \KwTo $n - 1$}{
  $xs(i - 1) \leftarrow xs(i)$
 }
 $xs(n - 1) \leftarrow 0$ \\
\end{algorithm}

\SubtaskSolved  \begin{Code}
def remove(xs: Array[Int], pos: Int): Unit = {
  val n = xs.size
  for (i <- pos+1 until n) xs(i - 1) = xs(i)
  xs(n-1) = 0
}
\end{Code}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 10




\WHAT{Deterministiska pseudoslumptalssekvenser med \code{java.util.Random}.}

\QUESTBEGIN

\Task  \what~  Klassen \code{java.util.Random} ger möjlighet att generera en sekvens av tal som verkar slumpmässiga. Genom att välja ett visst s.k. \textbf{frö} \Eng{seed} kan man få samma sekvens av pseudoslumptal varje gång.

\Subtask\Pen Sök upp och studera dokumentationen för \code{java.util.Random}. Hur skapar man en ny instans av klassen \code{Random}? Vad gör operationen \code{nextInt} på \code{Random}-objekt.

\Subtask Förklara vad som händer nedan?
\begin{REPL}
scala> import java.util.Random
scala> val frö = 42L
scala> val rnd = new Random(frö)
scala> rnd.nextInt(10)
scala> (1 to 100).foreach(_ => print(rnd.nextInt(10)))
scala> val rnd1 = new Random(frö)
scala> val rnd2 = new Random(frö)
scala> val rnd3 = new Random(System.nanoTime)
scala> val rnd4 = new Random((math.random * Long.MaxValue).toLong)
scala> def flip(r: Random) = if (r.nextInt(2) > 0) "krona" else "klave"
scala> val xs = (1 to 100).map{i =>
			(flip(rnd1), flip(rnd2), flip(rnd3), flip(rnd4))}
scala> xs foreach println
scala> xs.exists(q => q._1 != q._2)
scala> xs.exists(q => q._1 != q._3)
\end{REPL}

\Subtask\Pen Nämn några sammanhang då det är användbart att kunna bestämma fröet till en slumptalssekvens.

\Subtask Blir det samma sekvens om du använder fröet \code{42L} som argument till konstruktorn vid skapandet av en instans av \code{java.util.Random} på en \emph{annan} dator?

\Subtask Sök reda på dokumentationen för \code{java.math.random} och undersök hur denna sekvens skapas.

\Subtask Vad blir det för frö till slumptalssekvensen om man skapar ett \code{Random}-objekt med hjälp av konstruktorn utan parameter?

\SOLUTION


\TaskSolved \what


\SubtaskSolved  Antingen kan du skapa en ny instans av \code{java.util.Random} genom att skriva: \code{val r1 = new java.util.Random}.
Men om \code{java.util.Random} importeras kan “java.util” skippas och istället skrivs: \code{val r2 = new Random}.
Som valfritt argument kan ett slumptalsfrö av typen Long skickas med när en ny instans skapas, e.g. \code{val r3 = new Random(42L)}.
\code{nextInt(x)} skapar ett slumptal från och med 0, upp till x (exklusive x).

\SubtaskSolved  \begin{REPL}
import java.util.Random // Importerar Random

frö: Long = 42 // Ett slumptalsfrö av värdet 42L skapas.

  // Skapar ett Random objekt med slumptalsfrö "frö".
rnd: java.util.Random = java.util.Random@2f410acf

res0: Int = 7 // Slumpade fram ett tal från 0 till och med 9.

9 8 8 8 9 7 2 1 4 0 0 3 8 8 4 5 9 1 3 3 5 1 1
3 3 3 6 3 4 7 5 7 8 7 6 9 7 0 3 0 6 6 1 0 8 1
1 1 0 5 3 5 1 5 3 5 9 9 5 1 8 9 0 6 4 7 5 7 9
6 4 0 8 1 0 9 6 6 3 2 7 9 2 7 0 6 9 8 5 0 0 8
9 2 7 7 3 5 1 3 // Slumpar och skriver ut 100 tal från 0 till och med 9.

  // Skapar ett Random objekt med slumptalsfrö "frö".
rnd1: java.util.Random = java.util.Random@31e4bb20

  // Skapar ett Random objekt med slumptalsfrö "frö".
rnd2: java.util.Random = java.util.Random@45e37a7e

  // Skapar ett Random objekt med slumptalsfrö med
  // värdet av vad tiden är just nu i nanosekunder.
rnd3: java.util.Random = java.util.Random@57eda880

  // Skapar ett Random objekt med slumptalsfrö
  // med värdet (math.random * Long.MaxValue).toLong.
rnd4: java.util.Random = java.util.Random@79da1ec0

flip: (r: java.util.Random)String // Skapar en funktion som singlar slant.

  // Singlar slant med alla fyra Random
  // objekt 100 gånger samt printar ut resultatet.
xs: scala.collection.immutable.IndexedSeq[(String, String, String, String)] =
Vector((krona,krona,krona,klave), (klave,klave,krona,krona), (krona,krona,klave,klave),
(klave,klave,krona,klave), (klave,klave,krona,krona), (krona,krona,klave,krona),
(klave,klave,klave,klave), (krona,krona,klave,krona), (krona,krona,klave,krona),
(klave,klave,krona,klave), (krona,krona,krona,klave), (klave,klave,krona,klave),
(klave,klave,krona,krona), (klave,klave,klave,krona), (klave,klave,klave,krona),
(krona,krona,klave,klave), (klave,klave,klave,klave), (krona,krona,klave,krona),
(krona,krona,klave,klave), (krona,krona,klave,klave), (krona,krona,klave,krona),
(klave,klave,klave,klave), (klave,klave,krona,krona), (klave,klave,klave,klave),
(krona,krona,krona,krona), (krona,krona,krona,klave)...

  // Kollar om det finns något värde som rnd1
  // har genererat men som inte rnd2 genererat.
res1: Boolean = false

  // Kollar om det finns något värde som rnd1
  // har genererat men som inte rnd3 genererat.
res2: Boolean = true

\end{REPL}

\SubtaskSolved  Vid felsökning och vid simulering där man vill att samma “slumpmässiga” sekvens uppstår varenda gång.

\SubtaskSolved  Ja.

\SubtaskSolved  \url{https://docs.oracle.com/javase/7/docs/api/java/lang/Math.html#random%28%29--} säger att den skapar ett nytt java.util.Random-objekt.

\SubtaskSolved  Den skapar ett slumpmässigt slumptalsfrö. För mer information, se: \url{https://docs.oracle.com/javase/8/docs/api/java/util/Random.html#Random--}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 11




\WHAT{Undersök om tärningskast är rektangelfördelade.}

\QUESTBEGIN

\Task  \what~ \footnote{För ett rektangelfördelat slumpvärde gäller att om man drar (nästan oändligt många) slumpvärden så blir det (nästan) lika många av varje möjligt värde. Om man ritar en sådan fördelning i ett koordinatsystem med antalet utfall på y-axeln och de olika värdena på x-axeln, så blir bilden rektangelformad. Du får lära dig mer om sannolikhetsfördelningar i kommande kurser i matematisk statistik.} \\Skriv en funktion \code{def testRandom(r: Random, n: Int): Unit = ???} \\ som ger följande utskrift:
\begin{REPL}
scala> val rnd = new Random(42L)
scala> testRandom(rnd, 1000)
Antal kast: 1000
Antal 1:or: 178
Antal 2:or: 187
Antal 3:or: 167
Antal 4:or: 148
Antal 5:or: 155
Antal 6:or: 165
\end{REPL}

\emph{Tips:}
Anropa din funktion \code{tärningsRegistrering} från uppgift \ref{task:seq-reg}.


\SOLUTION


\TaskSolved \what


\begin{Code}
def testRandom(r: Random, n: Int): Unit = {
  val xs = Array.fill(n)(r.nextInt(6) + 1)
  val f = tärningsRegistrering(xs)
  println("Antal kast: " + f(0))
  for (i <- 1 to 6) println(s"Antal $i:or: " + f(i))
}
\end{Code}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 12




\WHAT{Array och \code{for}-sats i Java.}

\QUESTBEGIN

\Task  \what~

\Subtask Skriv nedan program i en editor och spara i filen \code{DiceReg.java}:

\javainputlisting{examples/DiceReg.java}

\Subtask Kompilera med \code{javac DiceReg.java} och kör med \code{java DiceReg 10000 42} och förklara vad som händer.

\Subtask\Pen Beskriv skillnaderna mellan Scala och Java, vad gäller syntaxen för array och \code{for}-sats. Beskriv några andra skillnader mellan språken som syns i programmet ovan.

\Subtask Ändra i programmet ovan så att loop-variabeln \code{i} skrivs ut i varje runda i varje \code{for}-sats. Kompilera om och kör.

\Subtask Skriv om programmet ovan genom att abstrahera huvudprogrammets delar till de statiska metoderna \code{parseArguments}, \code{registerPips} och \code{printReg} enligt nedan skelett. Notera speciellt hur \jcode{private} och \jcode{public} är angivet. Spara programmet i filen \code{DiceReg2.java} och kompilera med \texttt{javac DiceReg2.java} i terminalen.

\begin{Code}[language=Java]
// DiceReg2.java
import java.util.Random;

public class DiceReg2 {
    public static int[] diceReg = new int[6];
    private static Random rnd = new Random();

    public static int parseArguments(String[] args) {
        // ???
        return n;
    }

    public static void registerPips(int n){
        // ???
    }

    public static void printReg() {
        // ???
    }

    public static void main(String[] args) {
        int n = parseArguments(args);
        registerPips(n);
        printReg();
    }
}
\end{Code}

\Subtask Starta Scala REPL i samma bibliotek som filen \texttt{DiceReg2.class} ligger i och kör nedan satser och förklara vad som händer:
\begin{REPL}
scala> DiceReg2.main(Array("1000","42"))
scala> DiceReg2.diceReg
scala> DiceReg2.registerPips(1000)
scala> DiceReg2.printReg
scala> DiceReg2.registerPips(1000)
scala> DiceReg2.printReg
scala> DiceReg2.rnd
\end{REPL}

\Subtask Växla synligheten på attributen mellan \jcode{private} och \jcode{public}, kompilera om och studera effekten i Scala REPL. Hur lyder felmeddelandet om du försöker komma åt en privat medlem?

\Subtask\Pen Ange en viktig anledning till att man kan vilja göra medlemmar privata.



\SOLUTION


\TaskSolved \what


\SubtaskSolved  -

\SubtaskSolved  \begin{REPL}
Rolling the dice 10000 times with seed 42
Number of 1's: 1654
Number of 2's: 1715
Number of 3's: 1677
Number of 4's: 1629
Number of 5's: 1643
Number of 6's: 1682
\end{REPL}
Simulerar 10000 tärningskast (med slumptalsfrö 42) och skriver ut förekomsten av respektive tärningskast.

\SubtaskSolved  Array i scala deklararas: \code{val scalaArray = Array.ofDim[Int](6)} medan i java skrivs: \code{int[] javaArray = new int[6];}
\code{for}-sats i scala skrivs: \code{for(i <- 0 to n)} medan i java skrivs: \code{for (int i = 0; i < n; i++)}.
I java måste semicolon skrivas efter varje operation samt att typen måste explicit definieras vid variabeldeklaration.
I scala behövs inga semicolon (förutom för att separera operationer på samma rad) och scala bestäms typen implicit, alltså att kompilatorn “gissar” typen av variabeln som deklareras.

\SubtaskSolved  Lägg till \code{System.out.println(i);} i for-looparna

\SubtaskSolved  \begin{Code}[language=Java]
// DiceReg2.java
import java.util.Random;
public class DiceReg2{
	public static int[] diceReg = new int[6];
	private static Random rnd = new Random();

	public static int parseArguments(String[] args){
		int n = 100;
		if(args.length > 0) {
			n = Integer.parseInt(args[0]);
		}
		if(args.length > 1) {
			int seed = Integer.parseInt(args[1]);
			rnd.setSeed(seed);
		}
		return n;
	}

	public static void registerPips(int n) {
		for(int i = 0; i<n; i++) {
			int pips = rnd.nextInt(6);
			diceReg[pips]++;
		}
	}

	public static void main(String[] args) {
		int n = parseArguments(args);
		registerPips(n);
		printReg();
	}
}
\end{Code}

\SubtaskSolved  \begin{REPL}
  // Skriver ut förekomsten av 1000 tärningskast med slumptalsfrö 42.
Number of 1's: 165
Number of 2's: 163
Number of 3's: 178
Number of 4's: 183
Number of 5's: 156
Number of 6's: 155

  // Skriver ut diceReg-attributet
res1: Array[Int] = Array(165, 163, 178, 183, 156, 155)

  // Skriver ut diceReg-attributet efter 1000 till kast.
res2: Array[Int] = Array(329, 325, 349, 360, 324, 313)

  // Skriver ut diceReg-attributet efter 1000 till kast.
res3: Array[Int] = Array(498, 484, 531, 513, 485, 489)

  // Det blir runtime error då attributet rnd är
  // private och kan inte nås via REPL:n.
<console>:11: error: value rnd is not a member of object DiceReg2
	DiceReg2.rnd
				    ^
\end{REPL}

\SubtaskSolved  \begin{REPL}
value [diceReg/rnd] is not a member of object DiceReg2
\end{REPL}

\SubtaskSolved  Om man ska spara under någon data som man inte vill att användaren, eller någon annan, inte ska kunna komma åt.
T.ex. om du gör en bankapp vill du inte att nyckeln som du använder för att autorisera en användare ska vara tillgänglig för då kan hackare använda det för att ta sig in på kontot och stjäla pengar!



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 13




\WHAT{Läsa in tal med \code{java.util.Scanner}.}

\QUESTBEGIN

\Task  \what~  Med \jcode{new Scanner(System.in)} skapas ett objekt som kan läsa in tal som användaren skriver i terminalfönstret.

\Subtask Sök upp och studera dokumentationen för \code{java.util.Scanner}. Vad gör metoderna \jcode{hasNextInt()} och \jcode{nextInt()}?

\Subtask Skriv nedan program i en editor och spara i filen \code{DiceScanBuggy.java}:

\javainputlisting{examples/DiceScanBuggy.java}

\Subtask Kompilera och kör med indatasekvensen \texttt{1 2 3 4 -1} och notera hur registreringen sker.

\Subtask Programmet fungerar inte som det ska. Du behöver korrigera 3 saker för att programmet ska göra rätt. Rätta buggarna och spara det rättade programmet som \texttt{DiceScan.java}. Kompilera och testa att det rättade programmet fungerar med olika indata.


\SOLUTION


\TaskSolved \what


\SubtaskSolved  \code{hasNextInt()} kollar enbart om det finns ett till tal och returnerar \code{true}/\code{false}. \code{nextInt()} “hoppar” till nästa tal och returnerar det.
Se \url{https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#hasNextInt%28%29} och \url{https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextInt%28%29 }.

\SubtaskSolved  -

\SubtaskSolved  -

\SubtaskSolved  \begin{Code}[language=Java,numbers=left]
import java.util.Random;
import java.util.Scanner;

public class DiceScanBuggy {
	public static int[] diceReg = new int[6];
	public static Scanner scan = new Scanner(System.in);

	public static void registerPips() {
		System.out.println("Enter pips separated by blanks: ");
		System.out.println("End with -1 and <Enter>.");
		boolean isPips = true;
		while(isPips && scan.hasNextInt()){
			int pips = scan.nextInt();
			if(pips >= 1 && pips <= 6) {
				diceReg[pips-1]++;
			} else {
				isPips = false;
			}
		}
	}

	public static void printReg(){
		for(int i = 1; i<7; i++) {
		System.out.println("Number of " + i + "'s: " + diceReg[i-1]);
		}
	}

	public static void main(String[] args) {
		registerPips();
		printReg();
	}
}
\end{Code}


\QUESTEND











\WHAT{Algoritm: SEQ-INSERT-COPY.}

\QUESTBEGIN

\Task  \what~

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{En sekvens $xs$ av typen \texttt{Array[Int]} och heltalen $x$ och $pos$}
 \Output{En ny sekvens av typen \texttt{Array[Int]} som är en kopia av $xs$ men där $x$ är infogat på plats $pos$}
 $n \leftarrow$ antalet element $xs$\\
 $ys \leftarrow$ en ny \texttt{Array[Int]} med plats för $n+1$ element \\
 \For{$i \leftarrow 0$ \KwTo $pos - 1$}{
  $ys(i) \leftarrow xs(i)$
 }
 $ys(pos) \leftarrow x$ \\
 \For{$i \leftarrow pos$ \KwTo $n - 1$}{
  $ys(i + 1) \leftarrow xs(i)$
 }
 \Return $ys$
\end{algorithm}

\Subtask Implementera ovan algoritm i en funktion med denna signatur:
\begin{Code}
def insertCopy(xs: Array[Int], x: Int, pos: Int): Array[Int]
\end{Code}

\Subtask Vad måste \code{pos} vara för att det ska fungera med en tom array som argument?

\Subtask Vad händer om din funktion anropas med ett negativt argument för \code{pos}?

\Subtask Vad händer om din funktion anropas med \code{pos} lika med \code{xs.size}?

\Subtask Vad händer om din funktion anropas med \code{pos} större än \code{xs.size}?



\SOLUTION


\TaskSolved \what


\SubtaskSolved  \begin{Code}
def insertCopy(xs: Array[Int], x: Int, pos: Int): Array[Int] = {
  val n = xs.size
  val ys = Array.ofDim[Int](n + 1)
  for (i <- 0 until pos) ys(i) = xs(i)
  ys(pos) = x
  for (i <- pos until n) ys(i + 1) = xs(i)
  ys
}
\end{Code}

\SubtaskSolved  \code{pos} måste vara \code{0}.

\SubtaskSolved  \begin{REPL}
java.lang.ArrayIndexOutOfBoundsException: -1
\end{REPL}

\SubtaskSolved  Elementet \code{x} läggs till på slutet av arrayen, alltså kommer den returnerande arrayen vara större än den som skickades in.

\SubtaskSolved  \begin{REPL}
java.lang.ArrayIndexOutOfBoundsException: 5
\end{REPL}
Man får \code{ArrayIndexOutOfBoundsException} då indexeringen är utanför storleken hos arrayen.


\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 16




\WHAT{Algoritm: SEQ-INSERT.}

\QUESTBEGIN

\Task  \what~  Man kan implementera algoritmen SEQ-INSERT på plats i en \code{Array[Int]} så att alla elementen efter \code{pos} flyttas fram ett steg och att sista elementet ''försvinner''.

\Subtask\Pen Skriv algoritmen SEQ-INSERT i pseudokod med penna och papper.

\Subtask Implemtera SEQ-INSERT i en funktion med denna signatur:
\begin{Code}
def insert(xs: Array[Int], x: Int, pos: Int): Unit
\end{Code}

\SOLUTION


\TaskSolved \what


\SubtaskSolved

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}

 \Input{En sekvens $xs$ av typen \texttt{Array[Int]} och heltalen $x$ och $pos$}
 \Output{En uppdaterad sekvens av $xs$ där elementet $x$ har satts in på platsen $pos$ och efterföljande element flyttas ett steg där sista elementet försvinner}
 $n \leftarrow$ antalet element $xs$\\
 $ys \leftarrow$ en klon av $xs$\\
 $xs(pos) \leftarrow x$\\
 \For{$i \leftarrow pos+1$ \KwTo $n - 1$}{
  $xs(i) \leftarrow ys(i - 1)$
 }
\end{algorithm}

\SubtaskSolved  \begin{Code}
def insert(xs: Array[Int], x: Int, pos: Int): Unit = {
  val n = xs.size
  val ys = xs.clone
  xs(pos) = x
  for (i <- pos + 1 until n) xs(i) = ys(i - 1)
}
\end{Code}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 17




\WHAT{NEEDS A TOPIC DESCRIPTION}

\QUESTBEGIN

\Task  \what~ Implementera funktionen \code{tärningsRegistrering} från uppgift \ref{task:seq-reg} på nytt, men nu med en \code{for}-sats istället.


\SOLUTION


\TaskSolved \what


\begin{Code}
def tärningsRegistrering(xs: Array[Int]): Array[Int] = {
  val f = Array.fill(7)(0)
  f(0) = xs.size
  for(i <- 0 until f(0)) f(xs(i)) += 1
  f
}
\end{Code}



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 18




\WHAT{NEEDS A TOPIC DESCRIPTION}

\QUESTBEGIN

\Task  \what~ Bygg vidare på Keno-uppgiften nummer \ref{task:keno-set} i kapitel \ref{chapter:W04} på sidan \pageref{task:keno-set} och gör registrering av det slumpmässiga utfallet av 365 Keno-dragningar och skriv ut frekvenserna för förekomsten av varje boll. Öka sedan antalet dragningar och undersök hur många dragningar du behöver göra för att frekvenserna ska bli nästan lika?


\AdvancedTasks %%%%%%%%%%%%%%%%%

\SOLUTION


\TaskSolved \what




\AdvancedTasks %%%%%%%%%



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 19




\WHAT{NEEDS A TOPIC DESCRIPTION}

\QUESTBEGIN

\Task  \what~ Sök reda på dokumentationen för metoden \code{patch} på klassen \code{Array}.

\Subtask Använd metoden \code{patch} för att implementera SEQ-INSERT-COPY:
\begin{Code}
def insertCopy(xs: Array[Int], x: Int, pos: Int): Array[Int] =
  xs.patch(???, ???, ???)
\end{Code}

\Subtask Använd metoden \code{patch} för att  implementera SEQ-REMOVE-COPY:
\begin{Code}
def removeCopy(xs: Array[Int], pos: Int): Array[Int] =
  xs.patch(???, ???, ???)
\end{Code}

\SOLUTION


\TaskSolved \what


\SubtaskSolved

\SubtaskSolved



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 20




\WHAT{NEEDS A TOPIC DESCRIPTION}

\QUESTBEGIN

\Task  \what~ Studera skillnader och likheter mellan

\Subtask \code{Array}

\Subtask \code{WrappedArray}

\Subtask \code{ArraySeq}

\noindent genom att läsa mer om dessa arrayvarianter här: \\
\href{http://docs.scala-lang.org/overviews/collections/concrete-mutable-collection-classes}{docs.scala-lang.org/overviews/collections/concrete-mutable-collection-classes} \\
\href{http://docs.scala-lang.org/overviews/collections/arrays.html}{docs.scala-lang.org/overviews/collections/arrays.html}  \\
\href{http://stackoverflow.com/questions/5028551/scala-array-vs-arrayseq}{stackoverflow.com/questions/5028551/scala-array-vs-arrayseq}


\SOLUTION


\TaskSolved \what


\SubtaskSolved

\SubtaskSolved

\SubtaskSolved



\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 21




\WHAT{NEEDS A TOPIC DESCRIPTION}

\QUESTBEGIN

\Task  \what~ Studera vad metoden \code{java.util.Arrays.deepEquals} gör här:\\
\href{https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#deepEquals-java.lang.Object:A-java.lang.Object:A-}{Arrays.html\#deepEquals-java.lang.Object:A-java.lang.Object:A-} \\
Vad skiljer ovan metod från metoden \code{java.util.Arrays.equals}?

\SOLUTION


\TaskSolved \what




\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 22




\WHAT{Använda \code{jline} istället för \code{Scanner} i REPL.}

\QUESTBEGIN

\Task  \what~  Om du använder  \code{java.util.Scanner} i Scala REPL så ekas inte de tecken som skrivs, så som sker om du använder scannern med \code{System.in} i en kompilerad applikation. Om du vill se vad du skriver vid indata i REPL kan du använda \code{jline}\footnote{
\href{https://github.com/jline/jline2}{github.com/jline/jline2}
} och klassen \code{jline.console.ConsoleReader}\footnote{
\href{http://jline.github.io/jline2/apidocs/reference/jline/console/ConsoleReader.html}{jline.github.io/jline2/apidocs/reference/jline/console/ConsoleReader.html}}.
Då får du dessutom editeringsfunktioner vid inmatning med t.ex. Ctrl+A och Ctrl+K så som i en vanlig unixterminal. Med pil upp och pil ner kan du bläddra i inmatningshistoriken.
\begin{REPL}
scala> val scan = new java.util.Scanner(System.in)
scala> scan.next
scala> scan.nextInt
scala> val cr = new jline.console.ConsoleReader
scala> cr.readLine
scala> cr.readLine("> ")
scala> cr.readLine("Ange tal: ").toInt
scala> scala.util.Try{cr.readLine("Ange tal: ").toInt}.toOption
\end{REPL}

\Subtask Prova ovan rader i REPL. Vad händer om du matar in bokstäver i stället för siffror på sista raden ovan? (Mer om \code{Option} i kapitel \ref{chapter:W08}).

\Subtask Skriv ett funktion \code{readPalindromeLoop} som låter användaren mata in strängar och som kollar om de är palindromer så som nedan REPL-körning indikerar. Skriv funktionen i en editor och klistra in den i REPL enligt nedan istället för \code{???}

\begin{REPL}
scala> val cr = new jline.console.ConsoleReader
scala> def isPalindrome(s: String): Boolean = s == s.reverse
scala> :paste
// Entering paste mode (ctrl-D to finish)

def readPalindromeLoop: Unit = ???

// Exiting paste mode, now interpreting.

readPalindromeLoop: Unit

scala> readPalindromeLoop
Ange sträng följt av <Enter>
Programmet avslutas med tom sträng + <Enter>
> gurka
gurka är ingen palindrom
> dallassallad
dallassallad är en palindrom!
>
Tack och hej!
scala>
\end{REPL}

\Subtask Skapa ett objekt med inläsningsstöd enligt nedan specifikation. Objektet ska delegera implementationerna till ett attribut \code{private val reader} som innehåller en referens till ett \code{ConsoleReader}-objekt.
\begin{ScalaSpec}{termutil}
object termutil {
  /** Reads one line from terminal input. */
  def readLine: String = ???

  /** Prints prompt and reads one line. */
  def readLine(prompt: String): String = ???

  /** Reads one line and converts it to an Int.
   *  If a non-integer is input, a NumberFormatException is thrown.  */
  def readInt: Int = ???

  /** Prints prompt, reads one line and converts it to an Int.
   *  If a non-integer is input, a NumberFormatException is thrown.  */
  def readInt(prompt: String): Int = ???

  /** Reads one line and converts it to an Option[Int]
   *  with Some integer or None if the input cannot be converted.  */
  def readIntOpt: Option[Int] = ???

  /** Prints prompt, reads one line and converts it to an Option[Int]
   *  with Some integer or None if the input cannot be converted.  */
  def readIntOpt(prompt: String): Option[Int] = ???
}
\end{ScalaSpec}
Biblioteket jline finns inbyggd i REPL men om du vill kompilera din kod separat kan du ladda ner jar-filen här: \href{http://repo1.maven.org/maven2/jline/jline/2.10/}{repo1.maven.org/maven2/jline/jline/2.10/} eller så hittar du den bland dina Scala-installationsfiler och kan kopiera filen till dit du vill ha den. Placera jline-jar-filen i samma bibliotek som din kod, eller lägg den i ett biblioteket där du vill ha den och placera jarfilen på classpath med optionen \code{-cp} när du kompilerar ungefär så här: \\
\code{scalac -cp "lib/jline-2.10.jar" termutil.scala}\SOLUTION


\TaskSolved \what


\SubtaskSolved

\SubtaskSolved

\SubtaskSolved
\QUESTEND




%%<AUTOEXTRACTED by mergesolu>%%      % Uppgift 23
